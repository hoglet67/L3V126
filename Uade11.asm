;.OPT
;UADE11;> Uade11
;.TTL
;Fileserver file UADE11

.UADE11

	;************************
	;*  Restart one drive   *
	;*  Disc number -> name *
	;*  Disc name -> number *
	;*                      *
	;*  U T I L I T I E S   *
	;************************



;.MPENSR
;	LDA #0
;	JMP MPEXIT


	;MPFRSP: FREE SPACE

	;ENTRY:
	;ARGB = LS(DISC NUMBER)
	;ARGC = MS(DISC NUMBER)
	;ARGD = LS(SIN)
	;ARGE = CS(SIN)
	;ARGF = MS(SIN)
	;ARGG = LS ptr to user info
	;ARGH = MS ptr to user info

	;EXIT:
	;ARGA = RC

	;FUNCTION: MAPTB IS SEARCHED TO FIND THE RELEVANT ENTRY. IF THE SECTOR
	;MAP IS NOT IN STORE IT IS READ IN. THE SIN IS CHECKED TO ENSURE THAT IT
	;POINTS TO THE FIRST BLOCK OF THE CHAIN. ALL THE SECTORS ON THE CHAIN ARE
	;THEN ADDED TO THE FREE CHAIN. THE FREE SECTOR COUNT IS THEN ADJUSTED. THE
	;DIRTY FLAG FOR THE SECTOR MAP IS SET.

.MPFRSP
{
	JSR FNDMAP;GET CURRENT MAP TABLE POSITION
	BNE MPFSND

	LDA #0
	STA ERRTYP
	STA DNDLTE

	LDY #ARGG
	JSR MPFRAD
	BNE MPFSND

	JSR MPDLTE
	BNE MPFSND
	JSR ENSMB
	JSR ENSBM
	LDA #0; REPLY ZERO
.MPFSND
	LDY #ARGG
	JSR MPSETF
	JMP MPEXIT
}

.MPREDR;MPREDR
{
	;*** RESTART ONE DRIVE **

	;ENTRY:
	;ARGB = DRIVE NO.

	;EXIT:
	;ARGA = RC

	LDA #0
	STA ERRTYP
	LDA BBUF
	STA DSCCB+TRADD;SET UP AREA TO READ IN SECTOR TWO
	STA MPSCPT
	LDA BBUF + 1
	STA DSCCB+TRADD + 1
	STA MPSCPT + 1

	LDY #ARGB
	LDA (ARGPTR),Y
	STA CURDRV;SET CURRENT DRIVE
	STA MPDRVE

	JSR RDSTWO;GET SECTOR ZERO TO BIG BUFFER

	JSR CHKDSC;CHECK DISC IS FS DISC
	BNE MPDREX
	JSR SMPPTR;SET POINTER TO RELEVANT MAPTAB ENTRY

	;Store old MAPTB entry, so that if an error
	;occurs, MAPTB can be replaced.
	; Having stored old MAPTB entry, replace with stuff
	;from sector zero.

	LDY #MPDCNO
.MPDRL1
	LDA (MAPPTR),Y
	STA MAPTBF -MPDCNO,Y
	INY
	CPY #MPTBSZ
	BNE MPDRL1

	JSR SMAPEN;Move sector zero info. from BBUF

	JSR MPMPSZ;Get size of disc

	JSR DIVSEC; GET NO. OF TRACKS
	LDY #MPNOCY
	CLC
	LDA MPTMPB;CALCULATE SIZE OF CY.MAP
	STA (MAPPTR),Y; SAVE NO. OF TRACKS
	INY
	ROL MPTMPB; MULTIPLY TRACKS BY TWO
	LDA MPTMPB+ 1
	STA (MAPPTR),Y
	ROL MPTMPB+ 1
	JSR CHMPSZ;CHECK MAP WILL FIT IN AVAILABLE SPACE
	BNE MPDRAB

	JSR MPSTCY;SET CORRECT MAP (MOST RECENT)

	JSR AGENTB;AGE NAME TABLE

	LDA BBUF
	STA MPSCPT
	LDA BBUF + 1
	STA MPSCPT + 1;CHMAPS destroys MPSCPT

	LDA MAPTBF
	STA CURDSC;Set disc no. for FNDDNO
	LDA MAPTBF + 1
	STA CURDSC + 1
	JSR FNDDNO;Find name table entry of old disc
	LDA #UNUSED
	LDY #NTUSED
	STA (DNMPTR),Y;Mark old disc unused

	JSR CHDNAM;CHECK DISC NAME AND PUT IN NAME TABLE
	BNE MPDRAB;POSSIBLY NOT UNIQUE DISC

	LDA #0;=> Success
.MPDREX
	JMP MPEXIT;*** EXIT **

.MPDRAB
	PHA ;Error exit !!

	LDY #MPTBSZ - 1
.MPDNL2
	LDA MAPTBF,Y
	STA (MAPPTR),Y;Restore MAPTB information,
	DEY ;so that state is as before
	BPL MPDNL2

	PLA
	JMP MPDREX
}

	;MPDSND

	;ENTRY:
	;ARGB = LS(DISC NUMBER)
	;ARGC = MS(DISC NUMBER)

	;EXIT:
	;ARGA = RC
	;ARGB = DRIVE NO.
	
	;FUNCTION: SEARCH MAPTB FOR DISC NUMBER
	;AND RETURN DRIVE

.MPDSND
	JSR FNDMAP
	PHA
	LDY #ARGB
	LDA MPDRVE
	STA (ARGPTR),Y
	PLA
	JMP MPEXIT


	;MPDSNB:

	;ENTRY:
	;ARGB = DRIVE NUMBER

	;EXIT:  ARGA = RC
	;ARGB = LS(DISC NUMBER)
	;ARGC = MS(DISC NUMBER)

	;FUNCTION: FINDS THE RELEVANT ENTRY
	;IN MAPTB AND RETURNS THE DISC NUMBER CURRENTLY
	;ON THAT DRIVE.

.MPDSNB
{
	LDY #ARGB;TO FIND DRIVE NUMBER
	LDA (ARGPTR),Y
	CMP DRIVES
	BCS MPDSER;BRANCH IF LEG PULL
	STA CURDRV
	JSR SMPPTR
	
	LDY #MPNOCY
	LDA (MAPPTR),Y
	INY
	ORA (MAPPTR),Y
	BEQ MPDSER;IF NO. OF CYLINDERS == 0

	;ENTRY FOUND SO LOOK AT IT
	LDY #MPDCNO;FOR DISC NUMBER
	LDA (MAPPTR),Y
	LDY #ARGB;TO SAVE IT FOR RETURN
	STA (ARGPTR),Y
	LDY #MPDCNO + 1
	LDA (MAPPTR),Y
	LDY #ARGC
	STA (ARGPTR),Y
	LDA #0;RC
	BEQ MPDSND
.MPDSER
	LDA #MPERRF
.MPDSND
	JMP MPEXIT
}

.MPDNNA;MPDNNA
{
	;ENTRY:
	;ARGB = PTR TO DISC NAME (LO)
	;ARGC = PTR TO DISC NAME (HI)

	;EXIT:
	;ARGB = DISC NO. (LO)
	;ARGC = DISC NO. (HI)

	LDY #ARGB
	LDA (ARGPTR),Y
	STA GENPTR
	INY
	LDA (ARGPTR),Y
	STA GENPTR + 1
	LDY #0

	LDA (GENPTR),Y
	CMP #CR
	BNE MPDNLA
	LDA #MPERRK
	BNE MPDNEX;null disc name

.MPDNLA
	LDA (GENPTR),Y
	CMP #CR
	BEQ MPDNLB;ARG. IS TERMINATED CR, SO NEEDS PADDING
	STA DNMBUF,Y
	INY
	JMP MPDNLA

.MPDNLB
	LDA #SPACE
.MPDNLC
	CPY #DNAMLN;CONTINUE PADDING ?
	BCS MPDNLD;NOPE, Y>=DNAMLN
	STA DNMBUF,Y;YEP, CONTINUE
	INY
	BNE MPDNLC

.MPDNLD
	JSR FNDNAM;LOOK UP NAME IN NAME TABLE
	BNE MPDNEX;NOT FOUND ...

	LDY #NTDNO
	LDA (DNMPTR),Y
	PHA
	INY
	LDA (DNMPTR),Y
	LDY #ARGC

	STA (ARGPTR),Y
	PLA
	DEY
	STA (ARGPTR),Y
	LDA #0

.MPDNEX
	JMP MPEXIT
}

.MPNADN;MPNADN
{
	;**  DISC NO. -> DISC NAME **

	;ENTRY:
	;ARGB = DISC NO. (LO)
	;ARGC = DISC NO. (HI)

	;EXIT:
	;ARGB = PTR. TO NAME (LO)
	;ARGC = PTR. TO NAME (HI)

	;RETURN CODE INDICATES FOUND

	LDY #ARGB
	LDA (ARGPTR),Y
	STA CURDSC
	INY
	LDA (ARGPTR),Y
	STA CURDSC + 1

	JSR FNDDNO
	BEQ MPNDON

	LDA #MPERRA;DISC NO. NOT FOUND
	BNE MPNDEX

.MPNDON
	LDY #ARGB
	CLC
	LDA DNMPTR
	ADC #NTNAME
	STA (ARGPTR),Y
	INY
	LDA DNMPTR + 1
	ADC #0
	STA (ARGPTR),Y
	LDA #0;OK EXIT ...

.MPNDEX
	JMP MPEXIT
}

.MPFREE
{
	; RETURN SIZE OF FREE CHAIN
	;
	; ON ENTRY
	;    ARGB LS(DISC NO)
	;    ARGC MS " "
	;
	; ON EXIT
	;    ARGB LS (SIZE)
	;    ARGC CS (")
	;    ARGD MS (")
	;    ARGE LS (TOTAL SPACE)
	;    ARGF CS (")
	;    ARGG MS (")
	;
	JSR FNDMAP;GET MAP TO STORE
	BNE MPFREX
	LDY #MPCYMP
	LDA (MAPPTR),Y
	STA MPCYPT
	INY
	LDA (MAPPTR),Y
	STA MPCYPT + 1
	LDY #0
	LDA (MPCYPT),Y;GET FREE SPACE
	STA MPTMPA
	INY
	LDA (MPCYPT),Y
	STA MPTMPA + 1
	INY
	LDA (MPCYPT),Y
	STA MPTMPA + 2
	LDY #ARGB
	LDA MPTMPA
	STA (ARGPTR),Y
	INY
	LDA MPTMPA + 1
	STA (ARGPTR),Y
	INY
	LDA MPTMPA + 2
	STA (ARGPTR),Y
	LDY #MPSCTT
	LDA (MAPPTR),Y
	STA MPTMPA
	INY
	LDA (MAPPTR),Y
	STA MPTMPA +1
	INY
	LDA (MAPPTR),Y
	LDY #ARGG
	STA (ARGPTR),Y
	DEY
	LDA MPTMPA +1
	STA (ARGPTR),Y
	DEY
	LDA MPTMPA
	STA (ARGPTR),Y
	LDA #0
.MPFREX
	JMP MPEXIT
}

	;MPZDSK: ZERO AREA OF DISC
	;
	;ENTRY: ARGB LS(DISC NUMBER)
	;ARGC MS(DISC NUMBER)
	;ARGD LS(SIN)
	;ARGE CS(SIN)
	;ARGF MS(SIN)
	;ARGG LS(OLD SIZE)
	;ARGH CS(OLD SIZE)
	;ARGI MS(OLD SIZE)
	;
	;EXIT: ARGA = RC
	;
.MPZDSK
	JSR MPSTTA;MPTMPA := SIN (ARGD,E,F)
				;Y:=ARGG
	LDA (ARGPTR),Y
	STA OLDSZE
	INY
	LDA (ARGPTR),Y
	STA OLDSZE + 1
	INY
	LDA (ARGPTR),Y
	STA OLDSZE + 2
	LDA #0
	STA OLDSZE + 3
	JSR ZERDSK
	JMP MPEXIT

	;**********************************
	;*           M A P M A N          *
	;*        U T I L I T I E S       *
	;**********************************


	; READS THE SPECIFIED BIT MAP INTO STORE
	;
	; ON ENTRY
	;     MPTMPC IS CYLINDER NUMBER OF BIT MAP
	;
	; ON EXIT
	;     MPSCPT POINTS TO BIT MAP
	;     MPBLOK ADDRESS OF BIT MAP BLOCK
.RDBTMP;READ BIT MAP
{
	LDA #0;ZERO OUT SIN
	STA CBSIN
	STA CBSIN + 1
	STA CBSIN + 2
	
	STA MPSCPT
	;STA MPSCPT + 1

	LDY #MPSZCY
	LDA (MAPPTR),Y
	BNE RBMCBM;COMPRESSED BIT MAP

	LDA MPTMPC; GET CYLINDER NUMBER
	STA CBTPPT;SAVE FOR DECREMENTING
	LDA MPTMPC + 1
	STA CBTPPT + 1
	JSR RBMLP
	
.RBMBMP
	JSR SETBM;GET SIZE & POINTER
	JSR GTBTS;READ IN BLOCK IF NECESSARY
	BNE RBMND;NON-ZERO IF FAILED
	
	CLC
	LDA CBSTA;GET STORE ADDRESS (START OF SECTOR)
	STA MPBLOK
	ADC MPSCPT;BYTE OFFSET
	STA MPSCPT
	LDA CBSTA + 1
	STA MPBLOK + 1
	;ADC MPSCPT + 1
	ADC #0
	STA MPSCPT + 1

	LDA ERRTYP
	BEQ RBMR1
	LDA RSTFLG
	BNE RBMR2
	LDA #IERRAJ
	JSR INTERR
	
.RBMR2
	LDA CBSTA
	STA CLRPTR
	LDA CBSTA + 1
	STA CLRPTR + 1
	LDY #0
	LDX #1
	JSR CLRSTR
.RBMR1
	LDA #0
.RBMND
	RTS
	
	;COMPRESSED BIT MAP
.RBMCBM
{
	LDY #MPSCYL;START CYLINDER
	LDA (MAPPTR),Y
	STA CBTPPT
	INY
	LDA (MAPPTR),Y
	STA CBTPPT + 1
	
	JSR RBMLP;CBSIN = SIN OF BIT MAP
	
	LDA MPTMPC; GET CYLINDER NUMBER
	STA CBTPPT;SAVE FOR DECREMENTING
	LDA MPTMPC + 1
	STA CBTPPT + 1
	
.RBMLL
	LDA CBTPPT;CHECK IF CYLINDER FOUND
	ORA CBTPPT + 1
	BEQ RBMBMP;FOUND SO GO AND READ IN 
	
	LDA CBTPPT
	BNE RBMLLA
	DEC CBTPPT + 1
.RBMLLA
	DEC CBTPPT;DECREMENT CYLINDER COUNTER

	LDY #MPSZCY
	CLC
	LDA MPSCPT;BYTE OFFSET
	ADC (MAPPTR),Y;BYTES REQUIRED TO HOLD CYLINDER'S BIT MAP
	BEQ RBMLLB;NEXT SECTOR
	
	STA MPSCPT
	ADC (MAPPTR),Y
	BCC RBMLL
	BEQ RBMLL
	;ELSE, DOESN'T FIT SO NEXT SECTOR
	
.RBMLLB
	;NEXT BIT MAP SECTOR
	LDA #0
	STA MPSCPT
	
	INC CBSIN
	BNE RBMLL
	INC CBSIN + 1
	BNE RBMLL
	INC CBSIN + 2;CBSIN += 1
	JMP RBMLL
}
	
.RBMLP
{
	LDA CBTPPT;CHECK IF CYLINDER FOUND
	ORA CBTPPT + 1
	BEQ RBMND;FOUND SO EXIT AND READ IN 
	
	LDY #MPSPCY;SECTORS / CYLINDER
	CLC
	LDA CBSIN
	ADC (MAPPTR),Y
	STA CBSIN
	INY
	LDA CBSIN + 1;GET TO NEXT BIT MAP
	ADC (MAPPTR),Y
	STA CBSIN + 1
	BCC RBMLP1
	INC CBSIN + 2
.RBMLP1
	LDA CBTPPT ; DECREMENT CYLINDER COUNTER
	BNE RBMLP2
	DEC CBTPPT + 1
.RBMLP2
	DEC CBTPPT
	JMP RBMLP
}
}
	
	;
	; READ THE SPECIFIED MAP BLOCK INTO STORE
	;
	; ON ENTRY
	;     MPTMPA HOLDS SIN
	;     CARRY SET IF BLOCK NOT TO BE READ IN
	;
	; ON EXIT
	;     MAPTMP HOLDS POINTER
	;

.RMPBK2
	JSR MPSTTA;MPTMPA := SIN (ARGD,E,F)
	CLC;READ BLOCK

.RDMPBK;READ IN MAP BLOCK
{
	PHP ;SAVE STATE OF CARRY FLAG
	LDA MPTMPA;GET SIN TO RIGHT PLACE
	STA CBSIN
	LDA MPTMPA + 1
	STA CBSIN + 1
	LDA MPTMPA + 2
	STA CBSIN + 2
	LDA MBCBPT; GET CORRECT POINTER
	STA GNCBPT
	LDA MBCBPT + 1
	STA GNCBPT + 1
	LDA #NOMPBK;NUMBER OF MAP BLOCK ENTRIES
	STA NCBDB
	PLP ;GET CARRY FLAG BACK
	BCS RMBNR;BRANCH IF NOT TO BE READ IN
	JSR GTBTS; GET THE MAP BLOCK TO STORE
	BNE RMBND; NON-ZERO IF FAILED
	LDA CBSTA;SAVE ADDRESS IN CORRECT PLACE
	STA MAPTMP
	STA GNCBPT
	LDA CBSTA + 1
	STA MAPTMP + 1
	STA GNCBPT + 1
	LDY #MBSQNO;POINT TO FIRST SEQUNCE NUMBER
	LDA (GNCBPT),Y
	TAX
	CLC
	LDA GNCBPT
	ADC #LO(LSTSQ)
	STA GNCBPT
	LDA GNCBPT + 1
	ADC #HI(LSTSQ)
	STA GNCBPT + 1
	LDY #0
	TXA
	CMP (GNCBPT),Y;COMPARE WITH LAST NUMBER
	BEQ RDMBND
	LDA #MPERRC
	RTS
.RDMBND
	LDA #0
.RMBND
	RTS
.RMBNR
	JSR FNDMB
	BCC RMBSK1
	LDY #CBSA
	JMP RMBSK2
.RMBSK1
	JSR GETFR;JUST FIND A FREE SPACE
	BNE RMBND
	LDY #CBDR
	LDA MPDRVE
	STA (GNCBPT),Y
	LDY #CAFLG
	LDA (GNCBPT),Y
	ORA #1;FLAG ALLOCATED
	STA (GNCBPT),Y
	INY
	LDA MPTMPA
	STA (GNCBPT),Y
	INY
	LDA MPTMPA + 1
	STA (GNCBPT),Y
	INY
	LDA MPTMPA + 2
	STA (GNCBPT),Y
	INY
.RMBSK2
	LDA (GNCBPT),Y;GET ADDRESS OF FREE STORE
	STA MAPTMP
	STA CLRPTR
	INY
	LDA (GNCBPT),Y
	STA MAPTMP + 1
	STA CLRPTR + 1
	LDY #LO(BTINBK)
	LDX #HI(BTINBK)
	JSR CLRSTR;CLEAR MAP BLOCK TO ZEROES SINCE NOT READ IN
	JMP RDMBND
}

	; CALCULATE THE NUMBER OF SECTORS REQUIRED FROM
	; THE NUMBER OF BYTES REQUIRED.
	;
	;   ON ENTRY
	;           DIVPAR HOLDS THE NUMBER OF BYTES
	;
	;   ON EXIT
	;           DIVPAR HOLDS ODD BYTES
	;           DIVTMP HOLDS THE NUMBER OF BLOCKS
	;           Carry Set if Overflow
	;
.DVDE
{
	LDA #0
	STA DIVTMP
	STA DIVTMP+ 1
	STA DIVTMP+ 2
	LDA DIVPAR
	ORA DIVPAR+ 1
	ORA DIVPAR+ 2
	BEQ DIVONE
.DIVLP
	SEC ;NOW LOOP DO DIVIDE BY BLOCK SIZE
	LDA DIVPAR
	SBC #LO(BTINBK)
	STA DIVPAR
	LDA DIVPAR+ 1
	SBC #HI(BTINBK)
	STA DIVPAR+ 1
	LDA DIVPAR+ 2
	SBC #0
	STA DIVPAR+ 2
	BCC DIVNO;CARRY CLEAR AT END OF DIVISION
	LDA DIVPAR
	ORA DIVPAR + 1
	ORA DIVPAR + 2
	BEQ DIVS1
	INC DIVTMP
	BNE DIVLP
	INC DIVTMP+ 1
	JMP DIVLP
.DIVNO
	LDA DIVPAR;REPLACE LOWER BYTE
	ADC #LO(BTINBK)
	STA DIVPAR
	LDA DIVPAR+ 1
	ADC #HI(BTINBK)
	STA DIVPAR+ 1
	BCC DIVS1
	INC DIVPAR+ 2
.DIVS1
	CLC
	LDA DIVTMP
	ADC #2;AT LEAST TWO BLOCKS LONG
	STA DIVTMP
	BCC DIVOK
	INC DIVTMP + 1
	BNE DIVOK
	INC DIVTMP + 2
	BNE DIVOK
	SEC;OVERFLOW
	RTS
.DIVONE
	INC DIVTMP
.DIVOK
	CLC
	RTS
}
	;GETPOS
	;   FINDS NEXT FREE POSITION IN MAP BLOCK
	; SETS CARRY FLAG IF MAP BLOCK FULL
	;
	; ON ENTRY
	;      MAPGEN POINTS TO START OF MAP BLOCK
	;
	; ON EXIT
	;      MAPGEN POINTS TO NEXT FREE POSITION
	;
	; USES
	;      MPTMPE
	;
.GETPOS
{
	CLC
	LDA MAPGEN
	ADC #LO(MBENTS);GET MAPGEN TO START OF ENTRIES
	STA MAPGEN
	LDA MAPGEN+ 1
	ADC #HI(MBENTS)
	STA MAPGEN+ 1
	LDA #0
	STA MPTMPE
	STA MPTMPE+ 1;CLEAR VARIABLES
.GPLP
	LDA MPTMPE
	CMP #LO(MXENTS- 1);CHECK FOR END OF LIST
	LDA MPTMPE+ 1
	SBC #HI(MXENTS- 1)
	BCS GPEXIT;RETURNS WITH CARRY SET IF END OF LIST
	LDY #0;Y POINTS AT SIN
	LDA (MAPGEN),Y
	BNE GPSK; ZERO IS END OF LIST
	INY
	LDA (MAPGEN),Y
	BNE GPSK
	INY
	LDA (MAPGEN),Y
	BEQ GPFND
.GPSK
	CLC ;LOOK AT NEXT ENTRY
	LDA MAPGEN
	ADC #ENSZ
	STA MAPGEN
	BCC GPSK2
	INC MAPGEN+ 1
.GPSK2
	INC MPTMPE;MPTMPE HOLDS NUMBER OF ENTRIES WE'VE LOOKED AT
	BNE GPLP
	INC MPTMPE+ 1
	JMP GPLP
.GPFND
	CLC
.GPEXIT
	RTS ;RETURNS HERE WITH CARRY CLEAR, ALL OK.
}
	; GET CYLINDER MAP POSITION
	;
	; STARTS A SEARCH FROM MPTMPC FOR THE NEXT
	; CYLINDER WITH A FREE SECTOR
	;
	; ON ENTRY
	;     MPTMPC HOLDS THE CURRENT CYLINDER
	;     MAPGEN POINTS TO START OF CYLINDER MAP
	;     MAPPTR POINTS TO MABTB ENTRY
	;
	; ON EXIT
	;     MAPGEN POINTS TO CYLINDER WITH FREE ENTRY
	;
	; USES
	;     MPTMPE
	;
.GTCYPS
{
	LDA MPTMPC
	STA MPTMPE;SAVE CURRENT POSITION
	LDA MPTMPC+ 1
	STA MPTMPE+ 1
	CLC
	LDA MAPGEN;POINT TO START OF MAP
	ADC #3
	STA MAPGEN
	BCC MELP2
	INC MAPGEN+ 1
.MELP2
	LDA MPTMPE;CHECK IF POSITION FOUND
	ORA MPTMPE+ 1
	BEQ GCPS1
	CLC
	LDA MAPGEN
	ADC #2;FOR NEXT ENTRY
	STA MAPGEN
	BCC GCPSA
	INC MAPGEN + 1
.GCPSA
	LDA MPTMPE
	BNE GCPSB
	DEC MPTMPE+ 1
.GCPSB
	DEC MPTMPE
	JMP MELP2
.GCPS1
	LDA MPTMPC
	STA MPTMPE
	LDA MPTMPC + 1
	STA MPTMPE + 1
.MEFD1
	LDY #0;NOW LOOK FOR POSITION WITH FREE BLOCK
	LDA (MAPGEN),Y
	INY
	ORA (MAPGEN),Y
	BNE GTND;FOUND IF NON ZERO
	INC MPTMPE
	BNE GCPSC
	INC MPTMPE+ 1
.GCPSC
	
	LDA MPTMPE
	LDY #MPNOCY;CHECK FOR END OF CYCLINDER MAP
	CMP (MAPPTR),Y
	INY
	LDA MPTMPE+ 1
	SBC (MAPPTR),Y
	BCS MEFBKG
	
	LDA #2;NOT END SO LOOK AT NEXT ENTRY
.GCPSD
	CLC
	ADC MAPGEN
	STA MAPGEN
	BCC MEFD1
	INC MAPGEN+ 1
	BCS MEFD1;ALWAYS
	
	
.MEFBKG
	LDA #0;END SO BACK TO BEGINNING
	STA MPTMPE
	STA MPTMPE+ 1
	LDY #MPCYMP
	LDA (MAPPTR),Y;GET START OF CYLINDER MAP
	STA MAPGEN
	INY
	LDA (MAPPTR),Y
	STA MAPGEN + 1
	
	LDA #3
	BNE GCPSD
.GTND
	RTS
}
	; FIND CYLINDER
	;
	; FINDS THE CYCLINDER WITH THE LARGEST AMOUNT
	; OF FREE SPACE
	;
	; ON ENTRY
	;     MPCYPT POINTS TO START OF CYLINDER MAP
	;
	; ON EXIT
	;     MPCYPT POINTS TO CYLINDER FOUND
	;
	; USES
	;     MAPTMP
	;     MPTMPA
	;     MPTMPB
	;
.FNDCY
{
	LDA #0
	STA MAPTMP;ZERO VALUES
	STA MAPTMP+ 1
	STA MPTMPA
	STA MPTMPA + 1
	STA MPTMPC
	STA MPTMPC + 1
	CLC
	LDA MPCYPT;GET TO START OF ENTRIES
	ADC #3
	STA MPCYPT
	STA MPTMPB
	LDA MPCYPT+ 1
	ADC #0
	STA MPCYPT+ 1
	STA MPTMPB+ 1
.FNDLP
	LDY #0;NOW SCAN ENTRIES FOR LARGEST
	LDA MAPTMP
	CMP (MPCYPT),Y
	INY
	LDA MAPTMP + 1
	SBC (MPCYPT),Y; MAPTMP HOLDS LARGEST SO FAR
	BCS FNDSK;BRANCH IF NOT LARGER
	LDA (MPCYPT),Y
	STA MAPTMP+ 1
	DEY
	LDA (MPCYPT),Y
	STA MAPTMP
	LDA MPCYPT;SAVE POSITION
	STA MPTMPB
	LDA MPCYPT+ 1
	STA MPTMPB+ 1
	LDA MPTMPA
	STA MPTMPC;SAVE CYLINDER NUMBER
	LDA MPTMPA + 1
	STA MPTMPC + 1
.FNDSK
	CLC
	LDA MPCYPT
	ADC #2;MOVE TO NEXT ENTRY
	STA MPCYPT
	BCC FNDSK2
	INC MPCYPT+ 1
.FNDSK2
	INC MPTMPA
	BNE FNDSK3
	INC MPTMPA + 1
.FNDSK3
	LDY #MPNOCY;CHECK FOR END OF MAP
	LDA (MAPPTR),Y
	CMP MPTMPA
	BNE FNDLP
	INY
	LDA (MAPPTR),Y
	CMP MPTMPA+ 1
	BNE FNDLP
	LDA MPTMPB;END SO RETURN POINTER
	STA MPCYPT
	LDA MPTMPB+ 1
	STA MPCYPT+ 1
	RTS
}
	; RETURNS THE SIZE OF A BLOCK OF STORE
	;
	; ON ENTRY
	;    MPSCPT POINTS TO BIT MAP
	;
	; ON EXIT
	;    MPTMPD HOLDS THE SIZE
	;
	; USES
	;    MPTMPE
	;
.SIZE
{
	LDY #MPSPCY
	LDA (MAPPTR),Y
	STA TMPSPC
	INY
	LDA (MAPPTR),Y
	STA TMPSPC + 1
	LDA #0
	STA MPTMPD;CLEAR VARIABLES
	STA MPTMPD+ 1
	STA MPTMPE
	STA MPTMPE+ 1
	LDY #0
.SZLP2
	LDA (MPSCPT),Y
	BEQ SZNX;NO FREE BITS IN THIS PART
	LDX #8;LOOK AT ALL EIGHT BITS
.SZLP
	ROR A;GET BIT INTO CARRY
	PHA
	BCC SZCHND;CLEAR SO CHECK FOR END
	INC MPTMPD
	BNE SZSK;KEEP A COUNT OF SECTORS
	INC MPTMPD+ 1
.SZSK
	INC MPTMPE
	BNE SZSK2
	INC MPTMPE + 1;AND CHECK HOW MANY BITS WE'VE LOOKED AT
.SZSK2
	JSR TESTME;CEHCK FOR END OF MAP
	BCC SZCNT
	LDA MPTMPD
	ORA MPTMPD +1
	BNE SZNERR
.SZERR
	LDA #&F6
	JSR INTERR
.SZNERR
	PLA ;GET BIT MAP VALUE BACK
.SZGOT
	RTS
.SZCNT
	PLA
	DEX
	BNE SZLP
.SZCNT2
	INY
	JMP SZLP2
.SZCHND
	LDA MPTMPD
	ORA MPTMPD+ 1
	BNE SZNERR;END IF ALREADY SOME COUNT
	BEQ SZSK
.SZNX
	LDA MPTMPD
	ORA MPTMPD + 1
	BNE SZGOT
	CLC
	LDA MPTMPE
	ADC #8;LOOK AT NEXT BYTE OF MAP
	STA MPTMPE
	BCC SZNX2
	INC MPTMPE+ 1
.SZNX2
	JSR TESTME
	BCC SZCNT2
	BCS SZERR
}
;
	; FILL BLOCKS
	;    ALLOCATES REST OF BLOCKS THAT ARE REQUIRED
	;
	; ON ENTRY
	;      DIVTMP HOLDS SIZE
	;      MPSCPT POINTS TO CURRENT BIT MAP
	;      MPTMPC HOLDS CYLINDER NUMBER
	;      MAPTMP POINTS TO MAP BLOCK
	;      MAPPTR POINTS TO MAP TABLE
	;      MPCYPT POINTS TO POSITION IN CYLINDER MAP
	;
	; ON EXIT
	;      C SET IF FAILED
	;

.FLBLKS
{
	LDA DIVTMP;CHECK IF ALL BLOCKS ALLOCATED
	ORA DIVTMP + 1
	ORA DIVTMP + 2
	BEQ FBND
	JSR GETBIT;FIND FIRST FREE BLOCK
	BCS FBTNXT;NONE LEFT SO GET NEXT TRACK
	JSR ABLKS;ALLOCATE THESE BLOCKS
	BCC FLBLKS;KEEP ALLOCATING BLOCKS UNTIL NONE LEFT
	LDA ERRTYP
	BEQ FBTNXT
.FBERR
	SEC
	RTS
.FBTNXT
	INC MPTMPC
	BNE FBSK1
	INC MPTMPC + 1
.FBSK1
	LDA MPTMPC;GET NEXT BIT MAP
	LDY #MPNOCY; CHECK FOR END
	CMP (MAPPTR),Y
	INY
	LDA MPTMPC + 1
	SBC (MAPPTR),Y
	BCS FBTB
	CLC
	LDA MPCYPT;KEEP CYLINDER MAP POINTER UP TO DATE
	ADC #2
	STA MPCYPT
	BCC FBSK2
	INC MPCYPT + 1
.FBSK2
	LDY #0
	LDA (MPCYPT),Y
	INY
	ORA (MPCYPT),Y
	BEQ FBTNXT
	JSR RDBTMP; GET THE BIT MAP
	BNE FBERR
	BEQ FLBLKS; KEEP TRYING TO ALLOCATE
.FBTB
	LDA #0;GO BACK TO THE BEGINNING
	STA MPTMPC
	STA MPTMPC + 1
	LDY #MPCYMP;RETURN CYLINDER MAP TO BEGINNING
	CLC
	LDA (MAPPTR),Y
	ADC #1
	STA MPCYPT
	INY
	LDA (MAPPTR),Y
	ADC #0
	STA MPCYPT + 1
	JMP FBSK1
.FBND
	CLC ;INDICATE OK
	RTS
}
	;
	; GET BIT
	;   FINDS THE FIRST FREE BIT IN THE BIT MAP
	;
	; ON ENTRY
	;     MPSCPT POINTS TO BIT MAP
	;
	; ON EXIT
	;     MPTMPE HOLDS BIT NUMBER
	;     C SET IF NOT BITS FOUND
	;
.GETBIT
{
	LDY #MPSPCY
	LDA (MAPPTR),Y
	STA TMPSPC
	INY
	LDA (MAPPTR),Y
	STA TMPSPC + 1
	LDY #0
	STY MPTMPE
	STY MPTMPE + 1
.GTBTBL
	LDA (MPSCPT),Y; GET BYTE OF BIT MAP
	BEQ GTBTNB; IF NONE FREE GET NEXT BYTE
.GTBTLP
	ROR A; ROTATE UNTIL BIT FOUND
	BCS GTBTFD; BRANCH WHEN FOUND
	INC MPTMPE;KEEP TRACK OF WHERE WE ARE
	BNE GTBTSK
	INC MPTMPE + 1
.GTBTSK
	PHA
	JSR TESTME;CHECK FOR END OF ENTRY
	PLA
	BCC GTBTLP
.GTBTNB
	CLC
	LDA MPTMPE;ADD 8 FOR THIS BYTE
	ADC #8
	STA MPTMPE
	BCC GTBTNJ
	INC MPTMPE + 1
.GTBTNJ
	INY
	JSR TESTME; CHECK FOR END OF BIT MAP
	BCC GTBTBL
	SEC ;WHEN NONE FOUND
	RTS
.GTBTFD
	CLC
	RTS
}
	;
	; CHECK FOR END OF BIT MAP
	;
.TESTME
	LDA MPTMPE
	CMP TMPSPC
	LDA MPTMPE + 1
	SBC TMPSPC + 1
	RTS
	;
	; CORRECT THE CURRENT FREE BLOCK COUNT
	;
	; ON ENTRY
	;     MPTMPB HOLDS NUMBER OF BLOCKS
	;     MPTMPC HOLDS CYLINDER NUMBER
	;     MAPPTR POINTS TO MAP TABLE ENTRY
	;
	; USES MAPGEN
	;
.ADDFR
{
	LDY #MPCYMP
	LDA (MAPPTR),Y
	STA MAPGEN
	INY
	LDA (MAPPTR),Y
	STA MAPGEN + 1;GET POINTER TO CYLINDER MAP
	LDY #0
	CLC
	LDA (MAPGEN),Y;ADD TO FREE COUNT AT START
	ADC MPTMPB
	STA (MAPGEN),Y
	INY
	LDA (MAPGEN),Y
	ADC MPTMPB + 1
	STA (MAPGEN),Y
	INY
	LDA (MAPGEN),Y
	ADC MPTMPB + 2
	STA (MAPGEN),Y
	CLC ; NOW FOUND CYLINDER POSITION
	LDA MAPGEN
	ADC #3;START OF ENTRIES
	STA MAPGEN
	BCC ADDFK
	INC MAPGEN + 1
.ADDFK
	LDA MPTMPC
	ORA MPTMPC + 1
	BEQ GTPSCY
	LDX MPTMPC
	LDY MPTMPC + 1
	JMP TRYX
.ADLP
	CLC
	LDA MAPGEN
	ADC #2
	STA MAPGEN
	BCC TRYX
	INC MAPGEN + 1
.TRYX
	CPX #0
	BEQ TRYY
	DEX
	JMP ADLP
.TRYY
	CPY #0
	BEQ GTPSCY
	DEX
	DEY
	JMP ADLP
.GTPSCY
	LDY #0
	CLC ;NOW ADD THE NEW VALUES
	LDA (MAPGEN),Y
	ADC MPTMPB
	STA (MAPGEN),Y
	INY
	LDA (MAPGEN),Y
	ADC MPTMPB + 1
	STA (MAPGEN),Y
	RTS
}

.MPMKFR
{
	LDA (ARGPTR),Y;form zero page pointer from supplied info
	STA GENPTR
	INY
	LDA (ARGPTR),Y
	STA GENPTR+1
.MPSETB
	RTS

.*MPSETF

	TAX
	BNE MPSETB;non-zero => dont update the free store
	JSR MPMKFR
	CLC
	TAX
	LDA GENPTR
	ADC #UTUSID
	LDY #ARGB
	STA (NEWARG),Y
	INY
	BCC MPSETG
	INX
.MPSETG
	TXA
	STA (NEWARG),Y

	LDX #LO(-4)
.MPSETA
	INY
	LDA MPNWFR - LO(-4),X ;:LSB: -4,X;write calculated new free space
	STA (NEWARG),Y
	INX
	BNE MPSETA
	LDA #9
	JSR SETRTN
	JMP USRMAN
}

.MPSTTA
	LDY #ARGD
	LDA (ARGPTR),Y
	STA MPTMPA
	INY ;Y:=ARGE
	LDA (ARGPTR),Y
	STA MPTMPA + 1
	INY ;Y:=ARGF
	LDA (ARGPTR),Y
	STA MPTMPA + 2
	INY ;Y:=ARGG
	RTS

.MPFRAD
{
	JSR MPMKFR;setup pointer
	JSR RMPBK2;get the map block
	BNE MPFRAC;exit

	LDA MAPTMP
	STA MPMBPT
	LDA MAPTMP+1
	STA MPMBPT+1
	JSR MPGTSZ

	LDX #LO(-3)
	LDY #UTFREE
	CLC

.MPFRAB
	LDA (GENPTR),Y
	ADC MPTMPA - LO(-3),X
	STA MPNWFR - LO(-3),X;save it away
	INY
	INX
	BNE MPFRAB

	;deal with extra length byte

	LDA (GENPTR),Y
	ADC #0;'cos size only three bytes
	STA MPNWFR + 3,X

	TXA ;return ok
.MPFRAC
	RTS
}


;IF FS=0;[ FS=0
;<1
;ENDIF ;]
;.LNK
;UADE12

