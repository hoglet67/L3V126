;.OPT
;UADE0E;FILE > Uade0E
;.TTL
;Fileserver file UADE0E

.UADE0E

	;********************************
	;* DIRMAN U T I L I T I E S  2  *
	;********************************
	
.DETALS
{
	CLC ;COPY CRNTEN DETAILS INTO INFPTR
	LDA CRNTEN
	ADC #DRTITL
	STA MOVFRM
	LDA CRNTEN + 1
	ADC #0
	STA MOVFRM + 1

	LDY #INFDIS - 1;COPY LOAD ADDR -> SIN
.DETASB
	LDA (MOVFRM),Y
	STA (INFPTR),Y
	DEY
	BPL DETASB

	;COPY DISC NO & SIZE OF OBJECT INTO DETAILS AREA

	JSR CRNSIN;OBJSIN := SIN OF CRNTEN
	JMP RETDSZ
}

	;********** MAKDIR RTN **********

	;MAKDIR : CREATE A VIRGIN DIR

	;ENTRY: DRDISC = DISC NUMBER
	;DIRTMP := SIZE OF DIR REQUIRED(APPROX)
	;EXIT: A := RC
	;ARGPTR STACK INITIALISED FOR PRESERVE


.MAKDIR
{
	LDA #1;MapMan.CreateSpace
	JSR STDSN2;PUT DISC NO ON NEWARG STACK
	
	LDY #ARGD
	LDA DIRTMP
	STA (NEWARG),Y;LS(SIZE)
	INY
	LDA DIRTMP + 1;DIRTMP := SIZE OF NEW DIR
	STA (NEWARG),Y;CS(SIZE)
	INY
	LDA DIRTMP + 2
	STA (NEWARG),Y;MS(SIZE)

	;** 3/10/84 **

	JSR JUSING;pass pointer to user info

	JSR MAPMAN;MAPMAN.CREATE SPACE
	BNE MAKDRX

	;SETUP DETAILS ON ARGPTR STACK FOR RETAIN RTN

	LDY #ARGD
	LDA (NEWARG),Y
	STA DIRSIN
	LDY #ARGQ
	STA (ARGPTR),Y
	LDY #ARGE
	LDA (NEWARG),Y
	STA DIRSIN + 1
	LDY #ARGR
	STA (ARGPTR),Y
	LDY #ARGF
	LDA (NEWARG),Y
	STA DIRSIN + 2;DIRSIN := SIN OF NEW DIR
	LDY #ARGS
	STA (ARGPTR),Y
	JSR DRSOBJ;OBJSIN := SIN OF NEW DIR
	
	LDY #ARGF
	LDA #0
.MAKDRD
	STA (ARGPTR),Y;LOAD ADDR:=EXEC ADDR:=0
	INY
	CPY #ARGN
	BCC MAKDRD

	LDA #(TYPDIR OR LOCKED)
	STA (ARGPTR),Y;TYPE & ACCESS INFO

	INY ;Y:=ARGO
	LDA DATE
	STA (ARGPTR),Y
	INY
	LDA DATE + 1
	STA (ARGPTR),Y;DATE CREATED

	JSR LOADDR;LOAD DIR INTO STORE
	BEQ MAKDRF

	CMP #DRERRB
	BEQ MAKDRG

	;IF WE CANNOT LOAD IT THEN CLEAN UP

	PHA ;REMEMBER RC
	JSR ARGOBJ;OBJSIN:=SIN OF NEWDIR
	JSR DELB;FREE SPACE ALLOCATED IN DISC MAP
	PLA
.MAKDRX
	RTS
	
.MAKDRG
	JSR INCCNT

	;CLEAR DRFRST -> DRENTS

.MAKDRF
	LDA DIRSTA
	STA CLRPTR
	STA GENPTR
	LDA DIRSTA + 1
	STA CLRPTR + 1;CLRPTR := DIRSTA
	STA GENPTR + 1;GENPTR := DIRSTA
	
	LDY #DRSTAR + DRENSZ
	LDX #0
	JSR CLRSTR
	
	;CREATE PARENT ENTRY
	
	LDY #DRSTAR
	LDA #&FF
	STA (GENPTR),Y
	INY
	STA (GENPTR),Y
	
	LDY #DRSTAR + DRSIN;SIN OF PARENT DIR
	LDA EXRTN
	STA (GENPTR),Y
	INY
	LDA EXRTN + 1
	STA (GENPTR),Y
	INY
	LDA EXRTN + 2
	STA (GENPTR),Y

	;NOW FORMAT IT

	CLC
	LDA DIRSTA
	ADC #DRSTAR + DRENSZ;2ND ENTRY
	STA CRNTEN
	LDA DIRSTA + 1
	ADC #0
	STA CRNTEN + 1;CRNTEN PTS TO FIRST ENTRY TO BE MARKED FREE
	
	JSR FORMAT
	BEQ MAKDRZ

	JSR DELOBJ;DELETE THE OBJECT

.MAKDRZ
	RTS
}

	;FORMAT: RTN TO INCREASE THE NO OF FREE ENTRIES IN A DIR

	;ENTRY:OBJSIN = SIN OF DIR
	;CRNTEN = PTR TO NEXT POSN TO BE PLACED ON FREE CHAIN
	;DIRTMP = SIZE OF DIR (IN BYTES)
	;DPTRLD = PTR TO FIRST BYTE OF DIR

	;EXIT : A = RC
	;N.B. CRNTEN & DIRTMP ARE DESTROYED
	;DPTRTR IS UPDATED


.FORMAT
{
	JSR DECCRN;CRNTEN -:=DRENSZ

	CLC ;WE WANT TO SUBTRACT ONE AS WELL
	LDA DIRTMP
	SBC #DRENSZ
	STA DIRTMP
	BCS FORMTA
	DEC DIRTMP + 1;N.B. WE SUBTRACT ONE FOR THE TRAILING SQ NO
.FORMTA
	CLC
	LDA DIRTMP
	ADC DIRSTA
	STA DIRTMP
	LDA DIRTMP + 1
	ADC DIRSTA + 1
	STA DIRTMP + 1;DIRTMP:=DIRSTA+DIRSIZE-DRENSZ-1

.FORMTD
	JSR INCCRN;CRNTEN +:= DRENSZ

	LDA DIRTMP
	CMP CRNTEN
	LDA DIRTMP + 1
	SBC CRNTEN + 1
	BCC FORMTM;BRANCH IF CRNTEN > DIRTMP

	JSR FREECH;PLACE CRNTEN ON THE FREE CHAIN
	JMP FORMTD

	;NOW SHRINK THE DIR TO AN 'EXACT' SIZE

.FORMTM
	LDA #3
	JSR STDSN2;PLACE DISCNO & OBJSIN ON NEWARG STACK

	LDA CRNTEN
	STA DIRSZE
	STA DPTRTR
	LDA CRNTEN + 1
	STA DIRSZE + 1;DIRSZE := CRNTEN
	STA DPTRTR + 1;DPTRTR := PTR TO LAST BYTE OF DIR (SQ.NO.)
	INC DIRSZE;ADD ON 1 FOR TRAILING SQ. NO.
	BNE FORMTG
	INC DIRSZE + 1;DIRSZE := CRNTEN + 1
.FORMTG
	SEC
	LDA DIRSZE
	SBC DIRSTA
	STA DIRSZE
	LDY #ARGG
	STA (NEWARG),Y;LS(SIZE)
	LDA DIRSZE + 1
	SBC DIRSTA + 1
	STA DIRSZE + 1;DIRSZE := CRNTEN + 1 - DIRSTA
	INY
	STA (NEWARG),Y;CS(SIZE)
	INY
	LDA #0
	STA (NEWARG),Y

	JSR JUSINF;** 3/10/84 **

	JSR MAPMAN;MAPMAN.CHANGESIZE
	BNE FORMTZ

	;NOW INSERT TRAILING SQ. NO. AND THEN

	LDY #DRSQNO
	LDA (DPTRLD),Y
	LDY #0
	STA (DPTRTR),Y;SET TRAILING SQ. NO. = LEADING SQ. NO.

	;NOTE FORMAT DOES NOT ENSURE THE DIR OR THE MAP.
	;SO WE MARK THE DIR DIRTY IN CASE IT GETS REMOVED FROM THE CACHE.

	LDA DPTRLD
	STA GENPTR
	LDA DPTRLD + 1
	STA GENPTR + 1
	JSR MRKDRT;MARK IT DIRTY

	LDA #0;RC := 0

.FORMTZ
	RTS
}

.JUSING
	LDY #ARGB;21/12/84
	LDA (ARGPTR),Y;passed in original call
	TAX
	INY
	LDA (ARGPTR),Y

	LDY #ARGH
	STA (NEWARG),Y
	DEY
	TXA
	STA (NEWARG),Y
	RTS

.DECCRN
{
	SEC ;CRNTEN -:= DRENSZ
	LDA CRNTEN
	SBC #DRENSZ
	STA CRNTEN
	BCS DECCRZ
	DEC CRNTEN + 1
.DECCRZ
	RTS
}


	;********* EXAMINE UTILS ********


.EXRTNA
{

	;ALL INFO IN MACHINE READABLE FORM
	;AND FILE TITLE.

	;ON ENTRY, INFPTR POINTS TO RESULT
	;AREA. ON EXIT, INFPTR POINTS TO
	;BYTE AFTER RESULT.

	JSR MOVEFT;10 BYTE FILE TITLE

	LDY #DRLOAD
	LDX #0

.EXRALA;EXRALA

	;MOVE ALL OTHER INFO FROM DIR. TO
	;RESULT AREA.

	LDA (CRNTEN),Y
	STA (INFPTR,X)
	JSR INCIPT
	INY
	CPY #DRENSZ
	BNE EXRALA
	JSR CRNSIN;GET SIN OF CURRENT ENTRY
	JSR SINSZE;GET SIZE ON STACK
	BNE ERTNAX
	LDY #ARGB
	LDX #0;COPY SIZE -> INFO AREA
.EXRALB
	LDA (NEWARG),Y
	STA (INFPTR,X)
	JSR INCIPT
	INY
	CPY #ARGE
	BNE EXRALB
	TXA ;Successful exit

.ERTNAX
	RTS




.*EXRTNB

	;ALL INFORMATION, FORMATTED IN CHAR. STRING

	JSR OUTENT;Output entry details
	BNE ERTNBX

.*ERTNBZ
	LDA #ENTTRM;Terminate string
	JSR OUTCH
	LDA #0
.ERTNBX
	RTS
}


.OUTENT
{
	JSR MOVEFT;Print file title
	JSR OUTSP
	JSR OUTLEX
	JSR OUTSZE
	BNE OUTEE;Map error
	JSR OUTACC
	LDX #4
	JSR OUTSPS
	JSR OUTDAT
	JSR OUTSIN
	LDA #0;Successful exit
.OUTEE
	RTS
}


.EXRTNC

	;FILE TITLE + TITLE LENGTH, M/C READABLE

	LDX #0
	LDA #NAMLNT
	STA (INFPTR,X);File title length
	JSR INCIPT
	JSR MOVEFT;Note pointer to locn. after f.t.
	LDA #0
	RTS ;Successful exit




.EXRTND


	;FILE TITLE + ACCESS IN CHAR FORM

	JSR MOVEFT
	JSR OUTSP
	JSR OUTACC

	JMP ERTNBZ



	;*** MINOR UTILITIES ***


.MOVEFT
{

	;MOVE FILE TITLE FROM DIRECTORY TO
	;!INFPTR. ON EXIT, INFPTR POINTS TO
	;BYTE AFTER FILE TITLE.

	LDY #DRTITL
	LDX #0
.MFTLP
	LDA (CRNTEN),Y
	STA (INFPTR,X)
	INY
	JSR INCIPT
	CPY #DRTITL + NAMLNT
	BCC MFTLP

	RTS
}


.OUTZRO
{
	LDX #8
	LDA #'0';Used to put out root load/exec addresses
.OUTZLP
	JSR OUTCH
	DEX
	BNE OUTZLP
	RTS
}


.OUTSPS
	JSR OUTSP
	DEX
	BNE OUTSPS
	RTS



.OUTSP

	;OUTPUT A SPACE AND INCREMENT INFPTR.

	LDA #SPACE
.OUTCH
	STX DMSTX
	LDX #0
	STA (INFPTR,X)
	LDX DMSTX
	JMP INCIPT;INCREMENT POINTER


.OUTHEX

	;FOUR BYTES IN REVERSE ORDER IN HEX
	;FROM CURRENT DIR. ENTRY

	;Y POINTS TO CURRENT ENTRY DATA.

	INY
	INY
	INY
	LDA #0
	STA FILLFL;Set space fill ON
	LDA (CRNTEN),Y
	JSR OUTBYT;TOP DIGIT
	DEY
	LDA (CRNTEN),Y
	JSR OUTBYT
	DEY
	LDA (CRNTEN),Y
	JSR OUTBYT;TWO DIGITS
	DEY
	LDA (CRNTEN),Y
	;JMP OUTBYT


.OUTBYT;OUTBYT

	;OUTPUT TOP OF A IN HEX

	PHA
	LSR A
	LSR A
	LSR A
	LSR A
	JSR OUTDIG

	PLA
.OUTDIG
{
	AND #&F
	BNE ODON;Non-zero, don't worry about fill
	BIT FILLFL
	BPL ODON;Switch -ev => fill space
	LDA #SPACE
	BNE OUTCH;Space and exit

.ODON
	PHA
	LDA #0;Printing a digit, so switch leading 0's off
	STA FILLFL
	PLA
	CMP #&A
	BCC ODRTS
	ADC #6
.ODRTS
	ADC #&30
	BNE OUTCH
}


.OUTSIN

	;THREE BYTE SIN IN HEX

	LDY #DRSIN + 2
	LDA #&0
	STA FILLFL

	LDA (CRNTEN),Y
	JSR OUTBYT
	DEY
	LDA (CRNTEN),Y
	JSR OUTBYT
	DEY
	LDA #0
	STA FILLFL;Switch leading spaces off
	LDA (CRNTEN),Y
	JMP OUTBYT


.OUTDAT

	;OUTPUT DATE TO INFPTR IN DD/MM/YY FORMAT

	LDY #DRDATE
	LDA (CRNTEN),Y
	STA TDATE
	INY
	LDA (CRNTEN),Y
	STA TDATE + 1

.OUTRTD
{
	;ENTRY POINT FOR PRINTING ROOT DATE, SET IN
	;TDATE DURING INITDV
	
	LDA TDATE
	LDX TDATE + 1
	JSR CDTE

	LDA TWORK + 2
	JSR OUTDEC;DAY
	LDA #':'
	JSR OUTCH
	LDA TWORK + 1
	JSR OUTDEC;MONTH
	LDA #':'
	JSR OUTCH
	LDA TWORK
	JSR OUTDEC;YEAR
	JMP OUTSP
}


.OUTDEC;OUTDEC
{

	;OUTPUT A IN DECIMAL. NOTE A IS
	;ASSUMED <100 COZ ROUTINE ONLY
	;USED IN WRITING DATE.

	LDX #&FF;TOP DIGIT IS IN X
	SEC

.ODLP
	INX
	SBC #&A
	BCS ODLP;IF >=10, CARRY ON

	ADC #&A
	PHA

	TXA ;OUTPUT TOP DIGIT
	JSR OUTNUM

	PLA

.OUTNUM
	CLC
	ADC #'0';CONVERT TO CHAR.
	JMP OUTCH
}



.OUTACC

	;OUTPUT ACCESS BYTE AS A PADDED
	;CHAR STRING, 7 BYTE LONG. ON
	;EXIT, INFPTR POINTS TO BYTE AFTER
	;ACCESS STRING.

	LDY #DRACCS;OFFSET IN DIR. ENTRY
	LDA (CRNTEN),Y
	ASL A;ONE LEFT SO ACCESS BITS ROATATED INTO B.7
.OUTACA
{
	LDX #0
	LDY #0

	;LOOP ROUND FIRST FOUR ACCESS FIELDS

.OALP
	JSR OACCCH
	INX
	CPX #4
	BNE OALP

	PHA
	LDA #'/'
	JSR OUTCH
	PLA

	JSR OACCCH;OWNER ACCESS WRITE
	INX

	;FINALLY OWNER ACCESS READ
	JSR OACCCH

	;NOW PAD TO THE RIGHT, Y BEING
	;NO OF SPACES NEEDED.

.OALPA
	JSR OUTSP
	DEY
	BNE OALPA
	RTS

.ACCTAB
	EQUB "DLWRWR"

.OACCCH
	ASL A
	PHA
	BMI OAONA
	INY ;ACCESS NOT SET, INC SPACE COUNT
	PLA
	RTS

.OAONA
	LDA ACCTAB,X
	JSR OUTCH
	PLA
	RTS
}



.OUTSZE

	;GET SIZE FROM MAP AND OUTPUT IN
	;HEX (3 BYTES, 5 DIGITS).

	JSR CRNSIN;SET CURRENT SIN TO A VARIABLE
.OUTSZA
{
	JSR SETDSN;SET DISC NO. + SIN ON STACK
	JSR SINSZE;GET SIZE FROM MAP
	BNE OSZEEX;ERROR ... EXIT

	LDY #ARGD;TOP BYTE OF SIZE
	LDA #0;NO leading spaces
	STA FILLFL
	LDA (NEWARG),Y
	JSR OUTBYT;TOP DIGIT

	DEY
	LDA (NEWARG),Y
	JSR OUTBYT

	DEY
	LDA (NEWARG),Y
	JSR OUTBYT
	LDX #3
	JSR OUTSPS
	LDA #0;SUCCESSFUL EXIT

.OSZEEX
	RTS
}


.INCIPT
{
	INC INFPTR
	BNE INCRTS
	INC INFPTR + 1
.INCRTS
	RTS
}

{
.ENTTAB
	EQUB MAXENA
	EQUB MAXENB
	EQUB MAXENC
	EQUB MAXEND

.*CHKENS;CHKENS

	;CHECK THAT THE NUMBER OF ENTRIES
	;ASKED FOR OF A CERTAIN TYPE OF
	;EXAMINE IS LESS THAN MAX. NO.

	LDX EXARG
	CPX #4
	BEQ CHENOK;Asking for dir.name only, exit, C clear
	CMP #0
	BEQ CHENK2
	CMP ENTTAB,X
	RTS
.CHENK2
	LDA ENTTAB,X
.CHENOK
	CLC
	RTS
}



	;************ RETAIN *************

	;RETAIN: RTN TO RETAIN A SIN IN A
	;SPECIFIED DIRECTORY, WITH
	;GIVEN FILE NAME.

	;ENTRY: ARGUMENTS ON ARGPTR STACK, AS SPECIFIED
	;FOR DIRMAN.DRPRES.

	;EXIT : A = RC
	;ARGB = LS(DISC NO)
	;ARGC = MS(DISC NO)
	;ARGD = LS(SIN)
	;ARGE = CS(SIN)
	;ARGF = MS(SIN OF OBJECT TO BE DELETED)

	;NOTE OBJSIN CAN BE DESTROYED BY RETAIN

	;FUNCTION:

	;IF TYPE = TYPDIR
	;THEN PUT LAST COMPONENT OF FILE TITLE IN DIR HEADER
	;FI;
	;IF ENTRY ALREADY EXISTS
	;THEN CHECK THAT IT MAY BE DELETED;
	;CHECK THAT TYPES AGREE;
	;CALL MAPMAN.ENSURE(MAP)
	;NOTE SIN OF OBJECT TO BE DELETED;
	;UPDATE DIR ENTRY (all except access - including name);
	;ENSURE DIRECTORY UPTO DATE ON DISC;
	;RETURN(success,disc no,sin)
	;ELIF ROOM FOR A NEW ENTRY
	;THEN CALL MAPMAN.ENSURE(MAP);
	;UPDATE DIRECTORY;
	;ENSURE DIR UPTO DATE ON DISC;
	;RETURN(success,0,0)
	;ELSE RETURN(directory full)
	;FI


.RETAIN
	LDA #LO(-1)
.RETA12
{
	STA TEMPA;skip DELCHK entry point
	JSR LOADTX
	
	LDA TXTNAM
	JSR TSTSYM
	BNE RETANA
	LDA TXTNAM + 1
	CMP #SPACE
	BNE RETANA
	LDA #DRERRA;BAD FILE TITLE
	BNE RETCLN	
	
.RETANA
	JSR FNDTEX;DOES TEXT NAME ALREADY EXIST ?
	BNE RETANM

	;ENTRY ALREADY EXISTS

	LDA TEMPA;check entry point
	BEQ RETANB;skip if RENAME involved ** 25/9/84 **

	JSR DELCHK;CAN IT BE DELETED ?
	BEQ RETANB
.RETCLN
	JSR UNLOCK;UNLOCK THE LOADED DIR
.RETANX
	RTS

	;SEE IF TYPES MATCH

.RETANB
	LDY #ARGN
	LDA (ARGPTR),Y;TYPE & ACCESS OF OBJECT TO BE PRESERVED
	AND #TYPE
	STA TEMPA
	LDY #DRACCS
	LDA (CRNTEN),Y
	STA OBJACC;OBJACC:=OLD ACCESS FIELD IN DIR
	AND #TYPE
	CMP TEMPA
	BEQ RETAND
	LDA #DRERRK;TYPES DON'T MATCH
	BNE RETCLN

.RETAND
	JSR RATDIR;IF DIR THEN UPDATE NAME IN HEADER
	BNE RETCLN

	JSR ENSMAP;ENSURE MAP OF OBJECT TO BE RETAINED
	BNE RETANX

	JSR CRNSIN;OBJSIN:=SIN OF OBJECT TO BE DELETED
	JSR COPYDT;COPY OBJECT DETAILS INTO DIR
	JSR COPYNM;Copy name TXTNAM -> dir. entry
	LDY #DRACCS;BUT KEEP OLD ACCESS FIELD
	LDA OBJACC
	STA (CRNTEN),Y
	JSR ARGDSN;MOVE DISC NO & OBJSIN ONTO ARGPTR STACK
	JMP ENSRIT;STRMAN.ENSURE(DIR)

	;MAKE A NEW DIR ENTRY

.RETANM
	JSR SETFRE;DIRFRE := ADDR OF FREE ENTRY PTR
	BNE RETANP
	JSR UNLOCK

	;THE DIR IS FULL SO TRY AND INCREASE ITS SIZE

	JSR CHZSZE;INCREASE DIR SIZE
	BNE RETANX
	JSR LOADDR;RELOAD THE DIR
	BEQ RETANA;TRY AGAIN
	RTS

.RETANP
	JSR RATDIR;IF DIR THEN UPDATE NAME IN HEADER
	BNE RETCLN;GO AND UNLOCK THE LOADED DIR

	JSR ENSMAP;ENSURE MAP OF OBJECT TO BE RETAINED
	BNE RETCLN

	;REMOVE ENTRY FROM FREE CHAIN AND INSERT
	;IT IN APPROPRIATE POSITION, ON THE IN USE CHAIN.

	LDY #DRLINK
	LDA (PREVEN),Y
	STA TEMPA
	INY
	LDA (PREVEN),Y
	STA TEMPA + 1;TEMPA := [PREVEN]

	DEY ;Y:= DRLINK
	LDA (DIRFRE),Y
	STA (PREVEN),Y
	INY
	LDA (DIRFRE),Y
	STA (PREVEN),Y;[PREVEN] := [DIRFRE]

	JSR SETCRN;CRNTEN := STORE ADDRESS OF [DIRFRE]

	LDY #DRLINK
	LDA (CRNTEN),Y
	STA (DIRFRE),Y
	INY
	LDA (CRNTEN),Y
	STA (DIRFRE),Y;[DIRFRE] := [CRNTEN]
	DEY ;Y:=DRLINK
	LDA TEMPA
	STA (CRNTEN),Y
	INY
	LDA TEMPA + 1
	STA (CRNTEN),Y;[CRNTEN] := TEMPA

	;INCREMENT DIR ENTRY COUNT

	JSR SETGEN;GENPTR := [DIRSTA]

	CLC
	LDY #DRENTS
	LDA (GENPTR),Y
	ADC #1
	STA (GENPTR),Y
	INY
	LDA (GENPTR),Y
	ADC #0
	STA (GENPTR),Y;[DIRSTA + DRENTS] +:= 1

	;COPY TEXT NAME INTO DIR ENTRY

	JSR COPYNM

	;COPY DETAILS ON ARGPTR STACK INTO DIR ENTRY

	JSR COPYDT
	JSR ENSRIT;STRMAN.ENSURE(directory)
	JSR ARGDSN;Copy Disc & SIN to stack, then zero SIN

	;CLEAR SIN TO ZERO

	LDA #0
	LDY #ARGD
	LDX #3
.RETANQ
	STA (ARGPTR),Y;:=0
	INY
	DEX
	BNE RETANQ
.RETANZ
.*RATDRZ
	RTS
}

	;RATDIR: IF RETAINING A DIR - WE COPY INTO ITS HEADER
	;THE LAST COMPONENT OF A FILE TITLE.
	;THIS IS THE DIR'S NAME & PROVIDED FOR THOSE
	;CLIENTS WANTING TO DISPLAY A DIR'S NAME
	;DURING EXAMINE.


.RATDIR
{
	LDY #ARGN
	LDA (ARGPTR),Y
	AND #TYPDIR
	BEQ RATDRZ

	;AS WE ARE RETAINING A DIR WE MUST COPY THE CONTENTS
	;OF TXTNAM INTO THE HEADER OF THIS DIR.

	JSR ARGOBJ;OBJSIN:=SIN OF OBJECT TO BE PRESERVED
	JSR SINSZE;FIND OUT THE DIR'S SIZE
	BNE RATDRZ
	LDY #ARGE
	LDA (NEWARG),Y;LS(NO OF BLOCKS)
	PHA
	INY
	LDA (NEWARG),Y;MS(NO OF BLOCKS)
	PHA
	LDA #1
	JSR STDSN2;PUT DISCNO & OBJSIN ON NEWARG STACK
	INY ;Y:=ARGG
	LDA #0
	STA (NEWARG),Y
	INY
	STA (NEWARG),Y;BLOCK NO. = 0
	PLA
	LDY #ARGJ
	STA (NEWARG),Y;MS(NO OF BLOCKS)
	PLA
	DEY ;Y:= ARGI
	STA (NEWARG),Y;LS(NO OF BLOCKS)
	JSR STRMAN;STRMAN.DISC ADDR->STORE ADDR
	BNE RATDRZ

	;NOW THE DIR IS LOADED - SO COPY THE CONTENTS OF
	;TXTNAM INTO THE HEADER OF THE DIR

	LDY #ARGB
	LDA (NEWARG),Y
	STA GENPTR
	INY
	LDA (NEWARG),Y
	STA GENPTR + 1
	CLC
	LDA GENPTR
	ADC #DRNAME
	STA MOVTO
	LDA GENPTR + 1
	ADC #0
	STA MOVTO + 1
	LDA #LO(TXTNAM)
	STA MOVFRM
	LDA #HI(TXTNAM)
	STA MOVFRM + 1
	LDX #NAMLNT
	JSR MOVE
	
	;PARENT DIR ENTRY?
	LDY #DRSTAR
	LDA #&FF
	CMP (GENPTR),Y
	BNE RATDRY
	INY
	CMP (GENPTR),Y
	BNE RATDRY
	
	LDY #DRSTAR + DRSIN
	LDA DIRSIN
	STA (GENPTR),Y
	INY
	LDA DIRSIN + 1
	STA (GENPTR),Y
	INY
	LDA DIRSIN + 2
	STA (GENPTR),Y
	

.RATDRY
	JSR MRKDRT;MARK IT DIRTY
	LDA #2
	JSR SETRTN;N.B. STR ADDR ALREADY ON NEWARG STACK
	LDY #ARGD
	LDA #UNLKIT
	STA (NEWARG),Y;ENSURE & UNLOCK THE DIR
	JMP STRMAN
}

	;COPYDT: COPY LOAD ADDR -> SIN, WHICH ARE ON ARGPTR STACK,
	;INTO THE DIR ENTRY POINTED TO BY CRNTEN.


.COPYDT
	LDA #ARGF
	STA OFF1;Move from offset
	LDA #DRLOAD
	STA OFF2;Move to offset
	LDX #ARGPTR;Move from ptr.
	LDY #CRNTEN;Move to ptr.
	LDA #&E;Move 14 bytes
	JMP MOVBLK



.COPYNM

	;Copy object name from TXTNAM to dir. entry

	LDA #LO(TXTNAM)
	STA MOVFRM
	LDA #HI(TXTNAM)
	STA MOVFRM + 1
	CLC
	LDA CRNTEN
	ADC #DRTITL
	STA MOVTO
	LDA CRNTEN + 1
	ADC #0
	STA MOVTO + 1
	LDX #NAMLNT
	JMP MOVE



.INCCRN
{
	CLC ;CRNTEN +:= DRENSZ
	LDA CRNTEN
	ADC #DRENSZ
	STA CRNTEN
	BCC INCCRZ
	INC CRNTEN + 1
.INCCRZ
	RTS
}


.ARGOBJ
	LDY #ARGQ;OBJSIN:=SIN OF OBJECT TO BE PRESERVED
	LDA (ARGPTR),Y
	STA OBJSIN
	INY
	LDA (ARGPTR),Y
	STA OBJSIN + 1
	INY
	LDA (ARGPTR),Y
	STA OBJSIN + 2
	RTS


.ENSMAP
	JSR ARGOBJ;ENSURE OBJECT'S MAP IS UPTO DATE ON DISC
.ENSOMP
	LDA #6
	JSR STDSN2;PUT DISC NO & OBJSIN ON NEWARG STACK
	JMP MAPMAN;MAPMAN.ENSUREMAP


.DELOBJ
{
	PHA ;REMOVE NEWDIR FROM CACHTB
	JSR ARGOBJ;OBJSIN:=SIN OF OBJECT WHICH WAS TO BE PRESERVED
	JSR REMOVE;remove the cache entry
	
	TAX ;save RC
	PLA
	BNE DELOB4
	TXA ;substitute RC here
.DELOB4
	CMP #&C9;look for 'write protect'
	BEQ DELOB1

	PHA
	JSR DELB;rest of DLETIT
	TAX ;save RC
	PLA ;get old RC
	BNE DELOB1;skip if there is previous error
	TXA ;else return new error
.DELOB1
	RTS
}


; JSR REMOVE ;REMOVE OBJECT FROM CACHE
; BNE DELZ ;**** 17/3/83 ****
.DELB
{
	LDA #2
	JSR STDSN2
	JSR JUSING;** 21/12/84 **
	JSR MAPMAN;MAPMAN.FREESPACE
	BNE DELX
	LDA #6
	JSR STDSN2
	JSR MAPMAN;MAPMAN.ENSURE MAP
	BEQ DELZ
.DELX
	JSR INTERR
.DELZ
	RTS
}


.REMOVE
	LDA #5
	JSR STDSN2;REMOVE OBJSIN FROM CACHE
	JMP STRMAN;STRMAN.REMOVE


	;CHZSZE: INCREASE THE SIZE OF A DIR

	;ENTRY: DIRSIN = SIN OF DIR TO HAVE ITS SIZE CHANGED
	;EXIT: A = RC

.CHZSZE
{
	JSR DRSOBJ;OBJSIN := DIRSIN
	JSR REMOVE;REMOVE OBJSIN FROM THE CACHE
	JSR SINSZE
	BNE CHZSZX

	LDY #ARGB
	LDA (NEWARG),Y
	STA CRNTEN
	INY
	LDA (NEWARG),Y
	STA CRNTEN + 1;CRNTEN:=EXACT CURRENT SIZE OF DIR
	LDY #ARGE
	LDA (NEWARG),Y
	STA BREGA
	INY
	LDA (NEWARG),Y
	STA BREGA + 1;BREGA := NUMBER OF BLOCKS
	LDA #0
	STA BREGA + 2
	JSR MULTBS;BREGA *:= BLKSZE
	CLC
	LDA BREGA
	ADC #LO(BLKSZE)
	STA DIRTMP
	LDA BREGA + 1
	ADC #HI(BLKSZE)
	STA DIRTMP + 1;DIRTMP:=SIZEOFDIR+BLKSZE(INTEGRAL NB OF BLKS)

	;TEST FOR MAX SIZE OF DIR ALLOWED
	LDA #LO(MAXDIR)
	CMP DIRTMP
	LDA #HI(MAXDIR)
	SBC DIRTMP+1
	BCS CHZSZD

	LDA #DRERRM
.CHZSZX
	RTS


.CHZSZD
	LDA #3
	JSR STDSN2
	INY
	LDA DIRTMP
	STA (NEWARG),Y;LS(NEW SIZE)
	INY
	LDA DIRTMP + 1
	STA (NEWARG),Y;CS(NEW SIZE)
	INY
	LDA #0
	STA (NEWARG),Y;MS(NEW SIZE)

	JSR JUSINF;** 3/10/84 **

	JSR MAPMAN;MAPMAN.CHANGESIZE
	BNE CHZSZZ

	JSR LDDR;LOAD CURRENT DIR
	BNE CHZSZZ

	LDA CRNTEN
	BNE CHZSZF 
	DEC CRNTEN + 1
.CHZSZF
	DEC CRNTEN;CRNTEN-:=1(TO OVERWRITE OLD TRALNG SQ NO)
	
	CLC
	LDA DIRSTA
	ADC CRNTEN
	STA CRNTEN
	LDA DIRSTA + 1
	ADC CRNTEN + 1
	STA CRNTEN + 1;CRNTEN PTS TO NEXT ENTRY TO BE MADE FREE

	JSR FORMAT;FORMAT DIR

	JSR ENSRIT;ENSURE ITS UPTO DATE ON DISC & UNLOCKIT
	BNE CHZSZZ
	;ENSURE THE OBJECT MAP

	JSR ENSOMP;N.B. OBJSIN MUST = SIN OF DIR
	BEQ CHZSZZ
	JSR INTERR

.CHZSZZ
	RTS
}

;.LNK
;UADE0F
;
