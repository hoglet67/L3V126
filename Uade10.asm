;.OPT
;UADE10;> Uade10
;.TTL
;Fileserver file UADE10

.UADE10

	;**********************************
	;*           M A P M A N          *
	;**********************************

	;THE MAP TABLE (MAPTB) CONTAINS :-
	;0) DISC NUMBER (2 BYTES)
	;1) NO. OF SECTORS?TRACKS ON DISC (2 BYTES)
	;2) SIN OF ROOT DIRE CTORY (3 BYTES)
	;3) DATE ROOT CREATED (2 BYTES)
	;DRIVE NUMBER PROVIDES THE OFFSET IN MAPTB.
	;POSSIBLE STATES ARE :-

.MAPMAN
{
	LDX #16;MAPMAN HAS 16 ENTRY POINTS
	LDA #MODMAP;A := NAME OF THIS MODULE
	JSR ENTRY
	LDA MPRTNS,X;GET ADDRESS OF ROUTINE TO JUMP TO
	STA MPJUMP + 1
	LDA MPRTNS + 1,X
	STA MPJUMP + 2;N.B.NO NEED FOR SETFS
	LDA #20
	JSR SETFS
.MPJUMP
	JMP MPJUMP;JUMP TO CORRECT ROUTINE

	;ADDRESSES OF ENTRY POINTS FOR EACH ROUINE
.MPRTNS
	EQUW MPCRSP;1 => CREATE SPACE
	EQUW MPFRSP;2 => FREE SPACE
	EQUW MPCHSZ;3 => CHANGE SIZE
	EQUW MPSNRT;4 => SIN OF ROOT
	EQUW MPSZIN;5 => SIZE OF CHAIN
	EQUW MPENSR;6 => WRITE MAP TO DISC
	EQUW MPREST;7 => START
	EQUW MPDSNB;8 => RETURN DISC NUMBER FOR A GIVEN DRIVE
	EQUW MPREDR;9 => RESTART ONE DRIVE
	EQUW MPDNNA;10 => RETURN NUMBER FOR GIVEN DISC NAME
	EQUW MPNADN;11 => RETURN NAME FOR GIVEN DISC NO.
	EQUW MPFREE;12 => FREE AREA ON DISC
	EQUW MPZDSK;13 => ZERO AREA OF DISC
	EQUW MPCHSJ;14 => changesize without space check
	EQUW MPDSND;15 => RETURN DRIVE FOR GIVEN DISC NUMBER
	EQUW MPNSUR;16 => WRITE MAP TO DISC 
}
.MPENSR
	LDA #0
.MPEXIT
	JMP EXIT
	
.MPBLTX
	EQUB "paMseJ";Mapblocktext

	;MPCRSP: CREATE SPACE

	;ENTRY: ARGB = LS(DISC NUMBER)
	;ARGC = MS(DISC NUMBER)
	;ARGD = LS(NUMBER OF BYTES WANTED)
	;ARGE = CS(NUMBER OF BYTES WANTED)
	;ARGF = MS(NUMBER OF BYTES WANTED)

	;EXIT:  ARGA = RC
	;ARGB = LS(DISC NUMBER)
	;ARGC = MS(DISC NUMBER)
	;ARGD = LS(SIN)
	;ARGE = CS(SIN)
	;ARGF = MS(SIN)
	;ARGG = LS ptr to user info
	;ARGH = MS ptr to user info

	;FUNCTION: MAPTB IS SEARCHED TO FIND THE RELEVANT ENTRY. IF THE SECTOR MAP
	;IS NOT IN STORE, IT IS READ IN. THE FREE SPACE COUNT IS CHECKED TO SEE IF
	;THE SPACE IS AVAILABLE. A CHAIN IS CREATED, THE FREE COUNT IS DECREMENTED
	;AND THE MAP IS MARKED DIRTY. THE SIN OF THE FIRST BLOCK OF THE CHAIN IS
	;RETURNED.

.MPCRSP
{
	LDY #ARGG
	JSR MPMKFR;make pointer
	LDA #ARGD
	STA MAPTMP
	LDA #UTFREE
	STA MAPTMP+1
	LDX #LO(-(UTFRLN-1))
	SEC

.MPCRSA
	LDY MAPTMP+1
	LDA (GENPTR),Y
	LDY MAPTMP
	SBC (ARGPTR),Y
	STA MPNWFR - LO(-(UTFRLN-1)),X ; :LSB: -(UTFRLN-1),X;save this result
	INC MAPTMP
	INC MAPTMP+1
	INX
	BNE MPCRSA

	LDY MAPTMP+1
	LDA (GENPTR),Y
	SBC #0;extra length byte
	STA MPNWFR +(UTFRLN-1)

	LDA #MPERRN;error code to return with insufficient free space
	BCC MPCRSX

	LDA #0
	STA ERRTYP;NO ERRORS YET!!!
	STA DNDLTE
	JSR FNDMAP;GET POINTER TO MAPTB
	BEQ MPCSS2
.MPCRSX
	JMP MPCRND
.MPCSS2
	LDY #ARGD;NUMBER OF BYTES REQUIRED
	LDA (ARGPTR),Y
	STA DIVPAR
	INY
	LDA (ARGPTR),Y
	STA DIVPAR+ 1
	INY
	LDA (ARGPTR),Y
	STA DIVPAR+ 2
	JSR DVDE;TO FIND MOST LIKELY NUMBER OF BLOCKS
	BCC MPCSZ1
	JMP MPCSR2
.MPCSZ1
	LDY #MPCYMP;READY TO CHECK IF ENOUGH ROOM
	LDA (MAPPTR),Y
	STA MPCYPT
	INY
	LDA (MAPPTR),Y
	STA MPCYPT + 1
	SEC
	LDY #0
	LDA (MPCYPT),Y
	SBC DIVTMP;FOR NUMBER OF BLOCKS
	STA (MPCYPT),Y
	INY
	LDA (MPCYPT),Y
	SBC DIVTMP + 1
	STA (MPCYPT),Y
	INY
	LDA (MPCYPT),Y
	SBC DIVTMP+ 2
	STA (MPCYPT),Y
	BCS MPCSS1;BRANCH IF NO ROOM
.MPCSL1
	JMP MPNORM
.MPCSS1
	JSR FNDCY;FIND LARGEST CYCLINDER
	JSR RDBTMP;READ IN THE BIT MAP
	BNE MPCSL1
	JSR ALBLK;ALLOCATE ONE BLOCK AS MAP BLOCK
	LDA MPTMPA
	LDY #ARGD
	STA (ARGPTR),Y; SAVE SIN OF NEW FILE
	INY
	LDA MPTMPA + 1
	STA (ARGPTR),Y
	INY
	LDA MPTMPA+ 2
	STA (ARGPTR),Y
	
	LDA DIVTMP;ONE LESS BLOCK REQUIRED
	BNE MPCSL3
	LDA DIVTMP + 1
	BNE MPCSL2
	DEC DIVTMP + 2
.MPCSL2
	DEC DIVTMP + 1
.MPCSL3
	DEC DIVTMP
	
	SEC
	JSR RDMPBK;ALLOCATE SPACE FOR MAP BLOCK
	LDA DIVTMP + 2
	ORA DIVTMP+ 1
	ORA DIVTMP;CHECK IF ONLY ONE BLOCK REQUIRED
	BEQ MPCSJD;BRANCH IF JUST ONE BLOCK
	LDA MAPTMP
	STA MPMBPT
	LDA MAPTMP + 1
	STA MPMBPT + 1
	LDA MPTMPB;POINTS TO CYCLINDER MAP
	STA MPCYPT
	LDA MPTMPB+ 1
	STA MPCYPT + 1
	LDY #0
	LDA (MPCYPT),Y;CHECK FOR NO FREE SPACR
	INY
	ORA (MPCYPT),Y
	BEQ MPCSSK;BRANCH TO GET NEW CYLINDER
	JSR ABLKS; ALLOCATE THE REST OF THE BLOCKS
.MPCSSK
	LDA DIVTMP
	ORA DIVTMP+ 1
	ORA DIVTMP+ 2;CHECK IF ALL BLOCKS ALLOCATED
	BEQ MPCSOB;OK IF THEY HAVE
	JSR FLBLKS;OTHERWISE CONTINUE ALLOCATING BLOCKS
	BCC MPCSOB;CARRY CLEAR IF OK
.MPCSDE
	LDA ERRTYP
	STA DNDLTE
	JSR MPDLTE;CLEAR ALL BLOCKS
	JSR ULMB
	JSR ENSMB
	JSR ENSBM
	JMP MPNORM;INDICATE NO ROOM
.MPCSJD
.MPCSOB
	JSR RMPBK2

	LDA MAPTMP
	STA MPSCPT
	STA CBSTA
	LDA MAPTMP+ 1
	STA MPSCPT+ 1
	STA CBSTA + 1

	LDY #BLKSN
	LDX #5;mapblock identifier text
.MPJLTX
	LDA MPBLTX,X
	STA (MPSCPT),Y
	INY
	DEX
	BPL MPJLTX

	LDY #BILB
	LDA DIVPAR;FILL IN ODD BYTES
	STA (MPSCPT),Y
	INY
	LDA DIVPAR + 1
	STA (MPSCPT),Y
	JSR MMBWT
	JSR ENSBM;ENSURE THE BIT MAPS
	JSR ENSMB;ENSURE THE MAP BLOCKS
	LDA ERRTYP
	BNE MPCSDE
	BEQ MPCRND;INDICATES ALL WAS WELL
.MPNORM
	CLC
	LDY #0
	LDA (MPCYPT),Y
	ADC DIVTMP
	STA (MPCYPT),Y
	INY
	LDA (MPCYPT),Y
	ADC DIVTMP + 1
	STA (MPCYPT),Y
	INY
	LDA (MPCYPT),Y
	ADC DIVTMP + 2
	STA (MPCYPT),Y
	LDA ERRTYP
	BEQ MPCSR2
	SEC
	LDY #0
	LDA (MPCYPT),Y
	SBC #1
	STA (MPCYPT),Y;MAP BLOCK LEFT!
	INY
	LDA (MPCYPT),Y
	SBC #0
	STA (MPCYPT),Y
	INY
	LDA (MPCYPT),Y
	SBC #0
	STA (MPCYPT),Y
	LDA #MPERRC
	BNE MPCRND
.MPCSR2
	LDA #MPERRB
.MPCRND
	LDY #ARGG
	JSR MPSETF;update the user free store if operation ok
	JMP MPEXIT
}

	;MPNSUR

	;ENSURE BIT MAPS & MAP BLOCKS
	;AND RESET FLAGS IN CACHES

.MPNSUR
{
	JSR ENSBM;ENSURE THE BIT MAPS
	JSR ENSMB;ENSURE THE MAP BLOCKS
	
	JSR SETBM;SET VALUES FOR BIT MAP
	JSR RFLGS
	
	JSR SETMB;SET VALUES FOR MAP BLOCKS
	JSR RFLGS
	
	JMP MPEXIT
	
.RFLGS;RESET FLAGS
	LDX NCBDB
	LDY #CAFLG
.RFLGSL
IF CAFLG=0
	TYA ;A:=0
ELSE
	LDA #0
ENDIF
	STA (GNCBPT),Y
	JSR ADGNCB;GNCBPT += CBSZ
				;X & Y PRESERVED
	DEX
	BNE RFLGSL
	
	TXA ;A:=0
	RTS
}


	;MPCHSZ: CHANGE THE SIZE OF A CHAIN ON DISC

	;ENTRY: ARGB = LS(DISC NO)
	;ARGC = MS(DISC NO)
	;ARGD = LS(SIN)
	;ARGE = CS(SIN)
	;ARGF = MS(SIN)
	;ARGG = LS(NEW SIZE IN BYTES)
	;ARGH = CS(NEW SIZE IN BYTES)
	;ARGI = MS(NEW SIZE IN BYTES)
	;ARGJ = LS ptr to user info
	;ARGK = MS ptr to user info

	;EXIT:  ARGA = RC

	;FUNCTION: MAPTB IS SCANNED TO FIND THE RELEVANT ENTRY. IF NECESSARY
	;THE SECTOR MAP IS READ INTO STORE. THE CURRENT SIZE IS DISCOVERED AND IT
	;IS DECIDED WHETHER IT IS AN INCREASE OR A DECREASE IN SIZE.
	;THE RELEVANT NUMBER OF BLOCKS ARE THEN ALLOCATED/DEALLOCATED.



.MPCHSZ
{
	JSR FNDMAP
	BNE MPCSZE

	LDY #ARGJ
	JSR MPFRAD;get size of chain
	BNE MPCSZE;catch errors

	LDX #LO(-3)
	LDY #ARGG
	SEC
.MPCHJA
	LDA MPNWFR - LO(-3),X
	SBC (ARGPTR),Y
	STA MPNWFR - LO(-3),X
	INY
	INX
	BNE MPCHJA;calculate new size required

	LDA MPNWFR+3
	SBC #0
	STA MPNWFR+3

	LDA #MPERRN
	BCC MPCSZE;exit 'cos there's no room
	BCS MPCSCN

.*MPCHSJ
	JSR FNDMAP
	BNE MPCSZE

.MPCSCN
	LDA #0;CLEAR VARIABLES
	STA ERRTYP;NO ERRORS
	STA DNDLTE
	STA MPTMPB
	STA MPTMPB + 1
	STA MPTMPB + 2
	STA SAVSC;FIRST BLOCK FLAGGED
	
	JSR MPSTTA;MPTMPA := SIN (ARGD,E,F)
			;Y:=ARGG
	
	LDA (ARGPTR),Y;GET LENGTH IN BYTES
	STA DIVPAR
	INY
	LDA (ARGPTR),Y
	STA DIVPAR + 1
	INY
	LDA (ARGPTR),Y
	STA DIVPAR + 2
	CLC
	JSR RDMPBK;READ IN RELEVANT MAP BLOCK
	LDA ERRTYP
	BEQ MPCSR3
	LDA #MPERRC
.MPCSZE
	JMP MPCHEN;REPORT DISC ERROR
	
.MPCSR3
	JSR DVDE;DIVIDE BYTES TO GET BLOCKS
	BCC MPCSZ2

	LDA #MPERRB; FLAG NO ROOM
	BNE MPCSZE
.MPCSZ2
	LDA DIVTMP;DECREMENT SINCE NO MAP BLOCK REQUIRED
	BNE MPCSZ4
	LDA DIVTMP + 1
	BNE MPCSZ3
	DEC DIVTMP + 2
.MPCSZ3
	DEC DIVTMP + 1
.MPCSZ4
	DEC DIVTMP
	LDA #0
	STA MPTMPB
	STA MPTMPB + 1
	STA MPTMPB + 2

.REPLP2
	LDA MAPTMP;ADDRESS OF MAP BLOCK
	STA MPMBPT
	LDA MAPTMP + 1
	STA MPMBPT + 1
	CLC
	LDA MPMBPT;GET TO POINT AT ENTRIES
	ADC #LO(MBENTS)
	STA MPMBPT
	LDA MPMBPT + 1
	ADC #HI(MBENTS)
	STA MPMBPT + 1
.REPLP1
	LDY #0
	LDA (MPMBPT),Y;CHECK IF NEXT POINTER IS ZERO
	INY
	ORA (MPMBPT),Y
	INY
	ORA (MPMBPT),Y
	BEQ NDLP1

	CLC
	LDA MAPTMP
	ADC #LO(LSTENT)
	TAX
	LDA MAPTMP + 1
	ADC #HI(LSTENT)
	CPX MPMBPT
	BNE CSES1
	CMP MPMBPT + 1
	BNE CSES1
	LDY #0;YES, SO THIS POINTER IS SIN OF MAP BLOCK
	LDA (MPMBPT),Y
	STA MPTMPA;PREPARE TO READ NEW MAP BLOCK
	INY
	LDA (MPMBPT),Y
	STA MPTMPA + 1
	INY
	LDA (MPMBPT),Y
	STA MPTMPA + 2
	CLC
	JSR RDMPBK;READ IN NEW MAP BLOCK
	JMP REPLP2
.CSES1
	CLC ; KEEP ADDING UP NUMBER OF BLOCKS
	LDY #3
	LDA (MPMBPT),Y
	ADC MPTMPB
	STA MPTMPB
	INY
	LDA (MPMBPT),Y
	ADC MPTMPB + 1
	STA MPTMPB + 1
	BCC CSES2
	INC MPTMPB + 2
.CSES2
	LDA MPTMPB
	CMP DIVTMP;CHECK IF ENOUGH BLOCKS FOUND
	LDA MPTMPB + 1
	SBC DIVTMP + 1
	LDA MPTMPB + 2
	SBC DIVTMP + 2
	BCS NDLP1;BRANCH IF ENOUGH FOUND
	CLC ;HERE IF JUST LOOK AT NEXT ENTRY
	LDA MPMBPT
	ADC #LO(ENSZ)
	STA MPMBPT; LOOK AT NEXT ENTRY
	LDA MPMBPT + 1
	ADC #HI(ENSZ)
	STA MPMBPT + 1
	JMP REPLP1
.NDLP1
	LDA MPTMPB;NOW SEE ABOUT THE SIZE
	CMP DIVTMP
	LDA MPTMPB + 1
	SBC DIVTMP + 1
	LDA MPTMPB + 2
	SBC DIVTMP + 2
	BCS CSSK2;BRANCH IF MORE SPACE REQUIRED
	JMP NEEDMR
.CSSK2
	LDA MPTMPB
	CMP DIVTMP
	BNE DARGP;IF THESE ARE NOT THE SAME, ODD BLOCKS MUST BE DISCARDED
	LDA MPTMPB + 1
	CMP DIVTMP + 1
	BNE DARGP
	LDA MPTMPB + 2
	CMP DIVPAR + 2
	BNE DARGP;THEY ARE EQUAL SO NO PART GROUPS TO DEALLOCATE
	JMP DARST
.DARGP
	SEC ;FIND ODD NUMBER FOR DEALLOCATION
	LDA MPTMPB
	SBC DIVTMP
	STA MPTMPB
	LDA MPTMPB + 1
	SBC DIVTMP + 1
	STA MPTMPB + 1
	LDA MPTMPB + 2
	SBC DIVTMP + 2
	STA MPTMPB + 2
	LDY #3
	SEC ;GET NUMBER OF THIS GROUP TO DEALLOCATE
	LDA (MPMBPT),Y
	SBC MPTMPB
	STA MPTMPD
	STA (MPMBPT),Y
	INY
	LDA (MPMBPT),Y
	SBC MPTMPB + 1
	STA MPTMPD + 1
	STA (MPMBPT),Y
	LDA #0
	SEC
	SBC MPTMPB + 2
	STA MPTMPD + 2
	LDA MAPTMP
	STA CBSTA
	LDA MAPTMP + 1
	STA CBSTA + 1
	JSR MMBWT
	LDY #0
	CLC ; FIND DISC ADDRESS FOR DEALLOCATION
	LDA (MPMBPT),Y
	ADC MPTMPD
	STA MPTMPE
	INY
	LDA (MPMBPT),Y
	ADC MPTMPD + 1
	STA MPTMPE + 1
	INY
	LDA (MPMBPT),Y
	ADC MPTMPD + 2
	STA MPTMPE + 2
	INY
	LDA (MPMBPT),Y
	INY
	ORA (MPMBPT),Y
	BNE NBZ
	LDY #0
	TYA
	STA (MPMBPT),Y
	INY
	STA (MPMBPT),Y
	INY
	STA (MPMBPT),Y
.NBZ;FIND CYLINDER NUMBER
	LDA #0
	STA MPTMPC;ZERO CYLINDER COUNT
	STA MPTMPC + 1
.CNTLP
	SEC
	LDY #MPSPCY
	LDA MPTMPE
	SBC (MAPPTR),Y
	STA MPTMPE
	INY
	LDA MPTMPE + 1
	SBC (MAPPTR),Y
	STA MPTMPE + 1
	LDA MPTMPE + 2
	SBC #0
	STA MPTMPE + 2
	BCC CYFD; FOUND IF GONE NEGATIVE
	INC MPTMPC
	BNE CNTLP
	INC MPTMPC + 1
	JMP CNTLP
.CYFD
	JSR RDBTMP;READ THE RELEVANT BIT MAP
				;SETS MPBLOK
	BEQ CYFD2
	JMP MPCHEN
.CYFD2
	JSR MBMLKD;USES MPBLOK
	LDY #MPSPCY
	CLC
	LDA MPTMPE
	ADC (MAPPTR),Y
	STA MPTMPD
	INY
	LDA MPTMPE + 1
	ADC (MAPPTR),Y
	STA MPTMPD + 1
	LDY #0
.DECLP
	LDA MPTMPD + 1
	BNE DECCT; CANNOT OF GOT TO THE RIGHT PLACE IF THIS NON-ZERO
	LDA MPTMPD
	CMP #8;CHECK FOR LESS THAN EIGHT
	BCC DECFN;IF LESS GO AND FIND ACTUAL BIT
.DECCT
	INY
	SEC
	LDA MPTMPD; KEEP DECREMENTING
	SBC #8
	STA MPTMPD
	BCS DECLP
	DEC MPTMPD + 1
	JMP DECLP		;MM BCC DECLP
.DECFN
	LDA MPTMPB
	PHA ; SAVE THIS COUNT
	LDA MPTMPB + 1
	PHA
	LDX #9; X TRACKS POSITION IN CURRENT BYTE
	LDA (MPSCPT),Y; GET THE BYTE
.FNLP
	ROR A; KEEP ROTATING FOR POSITION
	DEX
	DEC MPTMPD
	BPL FNLP
.DANX
	SEC ;MARK BLOCK FREE
	ROR A
	PHP ; SAVE THESE VALUES
	PHA
	DEX
	BEQ TSTNX; CHECK FOR END OF THIS BYTE
.DECNX
	LDA MPTMPB
	BNE DECNX2
	DEC MPTMPB + 1
.DECNX2
	SEC
	SBC #1;CHECK IF ALL BLOCKS HAVE BEEN FREED
	STA MPTMPB
	ORA MPTMPB + 1
	BEQ ALLDN; ZERO WHEN ALL DEALLOCATED
	PLA
	PLP ;GET VALUES BACK
	JMP DANX;JUMP BACK TO FREE NEXT
.TSTNX
	STA (MPSCPT),Y;SAVE THIS VALUE
	LDX #8;SET UP FOR WHOLE BYTE
	INY ;POINT TO NEXT ENTRY IN BIT MAP
	PLA
	PLP ;JUST TO GET RID OF THEM
	LDA (MPSCPT),Y; GET NEW BYTE
	ROR A;SET UP FOR FREEING BLOCKS
	PHP
	PHA
	JMP DECNX
.ALLDN
	PLA
	PLP ;CLEAR VALUES ON STACK
.CSRT
	ROR A
	DEX
	BNE CSRT
	STA (MPSCPT),Y; AND SAVE HIS VALUE
	PLA ; RETRIEVE BLOCK COUNT
	STA MPTMPB + 1
	PLA
	STA MPTMPB
	JSR ADDFR; ADD FREED BLOCKS TO BLOCK COUNT
	JSR MBMWT;MARK BIT MAP WRITTEN
	
.DARST
	LDY #ENSZ; NOW REST OF ENTRIES CAN BE DEALLOCATED
	LDA (MPMBPT),Y;CHECK FOR LAST ENTRY
	INY
	ORA (MPMBPT),Y
	INY
	ORA (MPMBPT),Y
	BEQ CSENS
	;IF NONE LEFT WE'VE FINSHED
	SEC
	LDA MPMBPT; RETRIEVE ADDRESS OF MAP BLOCK
	SBC MAPTMP; AND GET OFFSET
	STA MPSCPT
	LDA MPMBPT + 1
	SBC MAPTMP + 1
	STA MPSCPT + 1
	CLC ;NOW POINT AT NEXT ENTRY
	LDA MPSCPT
	ADC #LO(ENSZ)
	STA MPSCPT
	LDA MPSCPT + 1
	ADC #HI(ENSZ)
	STA MPSCPT + 1
	LDA #0
	STA MPTMPE;don't delete this map block
	JSR CLRBLK
.CSENS
	JSR ULBM
	JSR ENSMB
	JSR ENSBM
	LDA ERRTYP
	BEQ MPCSR4
	LDA #MPERRC
	JMP MPCHEN
.MPCSR4
	JMP CSEND;FINISH REDUCTION
}
	;
	; SIZE TO BE INCREASED
	;
.NEEDMR
{
	SEC ;GET THE POINTER
	LDA MPMBPT
	SBC MAPTMP
	STA SAVPTA;SAVE THE OFFSET IN THE MAP BLOCK IN CASE IT NEEDS TO BE RESTORED
	LDA MPMBPT + 1
	SBC MAPTMP + 1
	STA SAVPTA + 1
	LDA MPTMPA;SAVE THE SIN OF THE MAP BLOCK
	STA SAVPTB
	LDA MPTMPA + 1
	STA SAVPTB + 1
	LDA MPTMPA + 2
	STA SAVPTB + 2
	SEC ;DISCOVER HOW MUCH NEEDS TO BE ALLOCATED
	LDA DIVTMP
	SBC MPTMPB
	STA DIVTMP
	LDA DIVTMP + 1
	SBC MPTMPB + 1
	STA DIVTMP + 1
	LDA DIVTMP + 2
	SBC MPTMPB + 2
	STA DIVTMP + 2
	LDY #MPCYMP;GET ADDRESS OF CYLINDER MAP
	LDA (MAPPTR),Y
	STA MAPGEN
	INY
	LDA (MAPPTR),Y
	STA MAPGEN + 1
	SEC
	LDY #0; CHECK IF THERE IS ENOUGH SPACE
	LDA (MAPGEN),Y
	SBC DIVTMP
	STA (MAPGEN),Y
	INY
	LDA (MAPGEN),Y
	SBC DIVTMP + 1
	STA (MAPGEN),Y
	INY
	LDA (MAPGEN),Y
	SBC DIVTMP + 2
	STA (MAPGEN),Y
	BCS RPRM
	JMP RPNRM; BRANCH IF THERE IS NO ROOM
.RPRM
	LDA SAVPTA
	CMP #MBENTS
	BNE NMNB
	LDA SAVPTA + 1
	BEQ NMUS; EMPTY MAP BLOCK SO ALLOCATE FROM SIN
.NMNB
	SEC
	LDA MPMBPT
	SBC #LO(ENSZ)
	STA MPMBPT
	LDA MPMBPT + 1
	SBC #HI(ENSZ)
	STA MPMBPT + 1
	LDY #0; GET A CURRENT DISC ADDRESS
	LDA (MPMBPT),Y
	STA MPTMPA
	INY
	LDA (MPMBPT),Y
	STA MPTMPA + 1
	INY
	LDA (MPMBPT),Y
	STA MPTMPA + 2
	CLC
	LDA MPMBPT
	ADC #LO(ENSZ)
	STA MPMBPT
	LDA MPMBPT + 1
	ADC #HI(ENSZ)
	STA MPMBPT + 1
.NMUS
	JSR DIVSEC; FIND CYLINDER FROM SIN
	LDA MPTMPB;GET CYLINDER TO SOMEWHERE USEFUL
	STA MPTMPC
	LDA MPTMPB + 1
	STA MPTMPC + 1
	JSR GTCYPS; FIND A CLOSE CYLINDER WITH FREE BLOCKS
	LDA MPTMPE
	STA MPTMPC
	LDA MPTMPE + 1
	STA MPTMPC + 1
	JSR RDBTMP
	BNE NMUSE
	LDA MAPGEN
	STA MPCYPT; READY TO ALLOCATE BLOCKS
	LDA MAPGEN + 1
	STA MPCYPT + 1
	JSR ABLKS; ALLOCATE ONE LOT OF BLOCKS
	BCS GTRD; BRANCH IF FAILED
	LDA DIVTMP
	ORA DIVTMP + 1
	ORA DIVTMP + 2
	BEQ CSEND; CHECK IF FINISHED
	JSR FLBLKS; FILL IN THE REST OF THE BLOCKS
	BCS GTRD; BRANCH IF ALL WENT WELL
	JSR ENSBM
	JMP CSEND
.GTRD
	LDA SAVPTB; IT FAILED SO DEALLOCATE ANY BLOCKS STILL ALLOCATED
	STA MPTMPA; GET SIN BACK
	LDA SAVPTB + 1
	STA MPTMPA + 1
	LDA SAVPTB + 2
	STA MPTMPA + 2
	LDA SAVPTA; GET OFFSET BACK
	STA MPSCPT
	LDA SAVPTA + 1
	STA MPSCPT + 1
	LDA #0; LEAVE CURRENT MAP BLOCK ALONE
	STA MPTMPE
	JSR CLRBLK; TIDY UP
.RPNRM
	CLC
	LDY #0
	LDA (MAPGEN),Y
	ADC DIVTMP
	STA (MAPGEN),Y
	INY
	LDA (MAPGEN),Y
	ADC DIVTMP + 1
	STA (MAPGEN),Y
	INY
	LDA (MAPGEN),Y
	ADC DIVTMP + 2
	STA (MAPGEN),Y
	LDA ERRTYP
	BEQ MPCSR5
	LDA #MPERRC
.NMUSE
	BNE MPCHEN
.MPCSR5
	LDA #MPERRB; FLAG NO ROOM
	BNE MPCHEN
}

.CSEND
	JSR RMPBK2
	
	LDA MAPTMP
	STA MPMBPT
	STA CBSTA
	LDA MAPTMP + 1
	STA MPMBPT + 1
	STA CBSTA + 1
	LDY #BILB; POSITION OF ODD BYTES
	LDA DIVPAR; BYTES FROM DIVISION
	STA (MPMBPT),Y
	INY
	LDA DIVPAR + 1
	STA (MPMBPT),Y
	JSR MMBWT
	JSR ENSMB
	JSR ENSBM
	LDA #0; INDICATE SUCCESS

.MPCHEN
{
	BNE MPCHXX
	LDY #ARGA
	LDA (ARGPTR),Y
	EOR #14;detect special case
	BEQ MPCHXX
	LDY #ARGJ
	LDA #0
	JSR MPSETF
.MPCHXX
	JMP MPEXIT
}

	;MPREST:

	;FUNCTION: LOADS THE MAP TABLE FROM DISC.
	;CHECKS THAT ALL MAPS ARE O.K. ALSO
	;SETS UP TABLE FOR FREE STORE MANAGEMENT

.MPREST
{
	LDA #0;CLEAR ALL VARS.
	STA ERRTYP
	STA MAPTMP
	STA MAPTMP + 1
	STA MPTMPA
	STA MPTMPA + 1
	STA MPTMPB

	LDX DRIVES;FOR LOOP
	LDY #MPTBSZ
	JSR SETTAB;SET MAP TABLE AND CLEAR STORE
	STY MAPTB
	STY MAPPTR
	STX MAPTB + 1
	STX MAPPTR + 1

	LDX #NTSIZE
	LDY #NTENSZ
	JSR SETTAB;SET NAME TABLE
	STY NAMETB
	STX NAMETB + 1

	STY DNMPTR
	STX DNMPTR + 1
	LDX #NTSIZE
	LDA #UNUSED
	LDY #NTUSED

	;MARK ALL NAME TABLE ENTRIES UNUSED

.MPRELP
	STA (DNMPTR),Y
	PHA
	JSR INAMPT
	PLA
	DEX
	BNE MPRELP

	LDX #1
	STX NXTDNO
	DEX
	STX NXTDNO + 1;SET DISC ALLOCATION NO.
	JSR INBKMN

	LDA #0
	STA MPDRVE
	STA LDRNB
.MPRENG
	LDA MPDRVE
	STA DRIVNO
	LDA FREPTR
	STA MPSCPT;GENERAL PTR. TO SEC. ZERO DATA
	LDA FREPTR + 1
	STA MPSCPT + 1
	LDA DRIVNO;CURRENT DRIV NUMBER

	JSR RDDATA;GET INFO FROM DISC
	BNE MPRESB
	JSR CHKDSC;CHECK IS FS DISC
	BNE MPRESB

	;NOW SET MAP TABLE ENTRY FOR THIS DRIVE

	JSR SMAPEN

	JSR CHDNAM;PUT IN NAME TABLE
	BEQ MPRESA;OK, NO ERROR
	
	LDA #0
	LDY #MPNOCY
	STA (MAPPTR),Y
	INY
	STA (MAPPTR),Y
	BNE MPRESB;ALWAYS

	;NOW CREATE CYCLINDER MAP FOR THIS DISC'S MAP
.MPRESA
	JSR MPMPSZ;GET SIZE OF MAP
	JSR DIVSEC; GET NO. OF TRACKS
	LDY #MPNOCY
	CLC
	LDA MPTMPB;CALCULATE SIZE OF CY.MAP
	STA (MAPPTR),Y; SAVE NO. OF TRACKS
	INY
	ROL MPTMPB; MULTIPLY TRACKS BY TWO
	LDA MPTMPB+ 1
	STA (MAPPTR),Y
	ROL MPTMPB+ 1
	CLC ;NOW INCREASE SIZE TO HOLD FREE SPACE COUNT
	LDA MPTMPB
	ADC #3
	TAY
	LDA MPTMPB+ 1
	ADC #0
	TAX
	JSR GETVEC; GET SPACE FOR CYCLINDER MAP
	TYA ; SAVE ADDRESS OF CY.MAP
	LDY #MPCYMP
	STA (MAPPTR),Y
	INY
	TXA
	STA (MAPPTR),Y
	JSR MPSTCY

.MPRESB
	INC MPDRVE
	JSR MPADMP
	INC LDRNB
	LDA LDRNB
	CMP DRIVES
	BNE MPRENG

	LDA #0;RC
	JMP MPEXIT
}

	;MPSZIN: RETURNS THE LENGTH OF A CHAIN IN BYTES AND BLOCKS

	;ENTRY:
	;ARGB = LS(DISC NO)
	;ARGC = MS(DISC NO)
	;ARGD = LS(SIN)
	;ARGE = CS(SIN)
	;ARGF = MS(SIN)

	;EXIT:
	;ARGA = RC
	;ARGB = LS(SIZE IN BYTES)
	;ARGC = CS(SIZE IN BYTES)
	;ARGD = MS(SIZE IN BYTES)
	;ARGE = LS(SIZE IN BLOCKS)
	;ARGF = MS(SIZE IN BLOCKS)

	;FUNCTION: GETS THE RELEVANT ENTRY IN MAPTB. CHECKS THAT
	;THE SIN POINTS TO THE START OF A CHAIN. RETURNS THE LENGTH OF THE CHAIN.

.MPSZIN
{
	JSR FNDMAP;GET MAP TO MAPPTR
	BNE MPSZND
	
	JSR RMPBK2
	BEQ MPSZOK
	
	LDA #MPERRC;ERROR RETURN OF NOT START
	BNE MPSZND;AND RETURN
.MPSZOK
	LDA MAPTMP
	STA MPMBPT
	LDA MAPTMP + 1
	STA MPMBPT + 1
	JSR MPGTSZ;GET SIZE OF MAP
	LDY #ARGB
	LDA MPTMPA;SIZE IS IN MPTMPA
	STA (ARGPTR),Y
	INY
	LDA MPTMPA + 1
	STA (ARGPTR),Y
	INY
	LDA MPTMPA + 2
	STA (ARGPTR),Y
	LDY #ARGE
	LDA MPTMPD
	STA (ARGPTR),Y;SAVE NUMBER OF BLOCKS
	INY
	LDA MPTMPD + 1
	STA (ARGPTR),Y
	LDA #0;RC
.MPSZND
	JMP MPEXIT
}

	;MPSNRT: RETURNS THE SIN OF THE ROOT DIRECTORY
	;ENTRY:
	;ARGB = LS(DISC NO)
	;ARGC = MS(DISC NO)

	;EXIT:
	;ARGA = RC
	;ARGB = LS(SIN OF ROOT DIRECTORY)
	;ARGC = CS(SIN OF ROOT DIRECTORY)
	;ARGD = MS(SIN OF ROOT DIRECTORY)
	;ARGE = DATE ROOT CREATED (LO)
	;ARGF =  ""   ""    ""    (HI)


.MPSNRT
{
	JSR FNDMAP
	BNE MPSNND
	LDY #MPRTSN
.MPSNLA
	LDA (MAPPTR),Y
	PHA
	INY
	CPY #MPRTSN + 5
	BNE MPSNLA

	LDY #ARGF
.MPSNLB
	PLA
	STA (ARGPTR),Y
	DEY
	CPY #ARGA
	BNE MPSNLB

	LDA #0
.MPSNND
	JMP MPEXIT
}

;.LNK
;UADE11
