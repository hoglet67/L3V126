;.OPT
;UADE04; FILE > Uade04
;.TTL
;Fileserver file UADE04

.UADE04

	;*********************************
	;*   FILE SERVER INITIALISATION  *
	;*********************************


.INIT
{
	LDA #7
	JSR SETRTN
	JSR MAPMAN;MAPMAN.RESTART
	BNE INITY

	LDA #4
	JSR SETRTN
	JSR USRMAN;USRMAN.RESTART
	BNE INITY

	LDA #4
	JSR SETRTN
	JSR RNDMAN;RNDMAN.RESTART
	BNE INITY

	LDX #&1F
	LDY #2
	JSR SETTAB;Table of qualifiers/directory handles
	STY CDIRTB;for DOS conversion.
	STX CDIRTB + 1

	LDA #6
	JSR SETRTN
	JSR STRMAN;STRMAN.RESTART
.INITX
	BEQ INITZ

.INITY
	PHA
	JSR USRERR
	PLA

.INITZ
	RTS


.*RSTAUT;RESART AUTMAN
	LDA #6
	JSR SETRTN
	JSR AUTMAN;AUTMAN.RESTART
	JMP INITX
}

.STRTFS

	CLD

	JSR MEMTST;Test memory.
	BEQ ASKDAT;OK

	JSR VSTRIN
	EQUB "Memory fault found",CR
	EQUB "File Server unable to start",CR
	EQUB "Ended",CR
	NOP

	RTS ;STOP !!


.ASKDAT
	JSR STDATE
	JSR RDDRVS;HOW MANY DRIVES?


.INITCO;INITCO
{
	;Main start point of any FS command.
	;Resets ENDPTR, FREPTR and re-allocates all tables.
	;NOTE !! It is therefore assumed that maps etc.
	;have been ensured to disc !!

	LDA #LO(DYNSTA)
	STA FREPTR
	LDA #HI(DYNSTA)
	STA FREPTR + 1;FREPTR := DYNSTA

	LDA MEMEND
	STA ENDPTR
	LDA MEMEND + 1
	STA ENDPTR + 1

	;GET SOME SPACE FOR THE ARGUMENT STACK AND SETUP ARGPTR

	LDY #LO(STKSZE)
	LDX #HI(STKSZE)
	JSR GETVEC
	STY ARGPTR
	STX ARGPTR + 1

	;NOW CLEAR THE ARGUMENT STACK TO ZERO

	STY CLRPTR
	STX CLRPTR + 1;CLRPTR:=ADDR OF ARGUMENT STACK
	LDY #LO(STKSZE)
	LDX #HI(STKSZE)
	JSR CLRSTR

	JSR VSTRIN
	EQUB CR,"Command :"
	NOP
	JSR CURSON
	JSR OSECHO
	PHA
	JSR CURSOF
	PLA
	LDX #4
.INITLA
	CMP FSCTBA,X
	BEQ INITLB
	DEX
	BPL INITLA

	JSR VSTRIN
	EQUB CR,"S, A, * ONLY"
	NOP
	JMP INITCO

.INITLB
	TXA
	ASL A
	TAX
	LDA FSCTBB,X
	STA TEMPA
	LDA FSCTBB + 1,X
	STA TEMPA + 1
	JMP (TEMPA)
}

.FSCTBA
	EQUB "SA*sa"

.FSCTBB
	EQUW STRTUP
	EQUW ASKDAT
	EQUW OSCMD
	EQUW STRTUP
	EQUW ASKDAT

.OSCMD
	JSR RDLINE
	LDX #0
	LDY #1
	JSR OSCLI
	JMP INITCO
	

	;NORMAL FILE SERVER STARTUP
.STRTUP
{
	JSR RDUSRS
	LDA #1
	JSR SETFS
	JSR INIT
	BEQ STRTLA
	JMP INITCO;Error => do again
	
.STRTLA
	LDX #LO(DOBRK)
	LDY #HI(DOBRK)
	JSR SETBRK
	JSR RSTAUT;RESTART AUTMAN
	JMP CMND;JUMP TO FILE SERVER COMMAND PROCESSOR
}


.RDDRVS
IF MAXDRV > 1
	JSR VSTRIN;FINDOUT HOW MANY DRIVES THERE ARE
	EQUB CR,"Number of drives:"
	NOP
	JSR RDLINE
	JSR GETINT;X:=NUMBER OF DISCS
	BNE RDDRVS
	TXA
	BEQ RDDRVS
	CMP #MAXDRV + 1
	BCS RDDRVS
ELSE
	LDA #1
ENDIF
	STA DRIVES;DRIVES:=NUMBER OF DRIVES ATTACHED TO FS
	RTS


.RDUSRS
	JSR VSTRIN
	EQUB CR,"Stations:"
	NOP

	JSR RDLINE
	JSR GETINT;X:=NUMBER OF STATIONS
	BNE RDUSRS

	TXA
	BEQ RDUSRS

	CMP #MAXUSE + 1; USRLIM
	BCS RDUSRS

	STA USERS
	RTS


	;PRNTDG: PRINT A DECIMAL NUMBER < 100
	;ENTRY A:= NUMBER

.PRNTDG
	CLC;LEADING ZEROES
.PRTNUM
{
	PHP
	LDX #&FF
	SEC
.PRNTGA
	INX
	SBC #10
	BCS PRNTGA
	ADC #10
	PLP
	PHA
	TXA ;OUTPUT TOP DIGIT
	BEQ PRSPC
	JSR OUTDGT
	JMP NXDG
.PRSPC
	LDA #'0'
	BCC PRZER
	LDA #SPACE
.PRZER
	JSR OSWRCH
.NXDG
	PLA
.OUTDGT
	CLC
	ADC #'0';CONVERT TO CHAR
	JMP OSWRCH
}
	
	;READ RTC AND CONVERT TO FS DATE
.UPDTE;MM 11/01/22
		;ACKNOWLEDGEMENT: Reference made to J.G.Harston's Y2K fix
{
	JSR RDTIME
	SEC
	LDA DYEAR
	SBC #BASEYR
	BCS UPDTEJ
	ADC #100
.UPDTEJ;A=(DYEAR-BASEYR) MOD 100
	ASL A
	PHA
	AND #&E0
	ORA DDAY
	STA DATE
	PLA
	ASL A
	ASL A
	ASL A
	ORA DMONTH
	STA DATE + 1
	RTS
}

	;CONVERT FROM FS DATE
	;ENTRY: A=YR/DAY, X=YR/MONTH
	;EXIT:  DATE IN TWORK AS YY/MM/DD
.CDTE
{
	PHA
	AND #&1F
	STA TWORK+2;DAY

	TXA
	AND #&0F
	STA TWORK+1;MONTH

	TXA;LSBs
	LSR A
	LSR A
	LSR A
	LSR A
	STA TWORK
	
	PLA;MSBs
	LSR A
	AND #&F0
	ORA TWORK;7 BIT YEAR
	
	CLC
	ADC #BASEYR
	CMP #100
	BCC CDTEJ
	SBC #100
.CDTEJ
	STA TWORK;YEAR
	RTS
}

.PRTIM
{
	JSR UPDTE
	
	LDA DDAY
	CMP OLDDAY
	BEQ LZ
	JSR PRDTEQ;reprint the date

.LZ	JSR DWIND;set up window
	JSR VSTRIN
	EQUB 31,30,1
	NOP
	LDA HRS
	JSR PRNTDG
	LDA #':'
	JSR OSWRCH
	LDA MINS
	JSR PRNTDG
	;LDA #':'
	;JSR OSWRCH
	;LDA SECS
	;JSR PRNTDG
	JMP MWIND;reset window and return
}

.PRDTE
	JSR UPDTE;RDDONG
.PRDTEQ
	JSR DWIND;set window

	JSR VSTRIN
	EQUB 12,31,0,1
	NOP
	JSR PRTDMY

	;reset the window

.MWIND;set window for monitor
	JSR VSTRIN
	EQUB 28,0,21,39,4,31
.POS
	EQUB 0
.VPOS
	EQUB 0
	NOP
	RTS

.DWIND;set window for printing the date in

	LDA #&86
	JSR OSBYTE;read cursor position
	STX POS
	STY VPOS
	JSR VSTRIN
	EQUB 28, 0, 24, 39, 22
	NOP
	RTS
	
IF LNGDAT
.PRTDMY
{
	;PRINT DAY
	LDA DDAY
	STA OLDDAY
	SEC
	JSR PRTNUM
	
	LDA DDAY
	CMP #10
	BCC ND1
	SBC #10
	CMP #10
	BCC TH1
.GTLP
	SBC #10
	CMP #10
	BCS GTLP
.ND1
	TAY
	BEQ TH1
	CPY #4
	BCC XX
.TH1
	LDY #4
.XX
	DEY
	LDX SUFFIX,Y
.LOOP2
	LDA WORD,X
	BEQ DONE
	JSR OSWRCH
	INX
	BNE LOOP2
.DONE
	JSR PRTSPC

	;PRINT MONTH
	LDX DMONTH
	LDY MTAB1 - 1,X
.LOOP
	LDA MONTHS,Y
	BEQ YR
	JSR OSWRCH
	INY
	BNE LOOP

.YR
	JSR PRTSPC
	LDA #YRHUND
	JSR PRNTDG
	LDA DYEAR
	JMP PRNTDG

.WORD
.ST
	EQUB "st", 0
.ND
	EQUB "nd", 0
.RD
	EQUB "rd", 0
.TH
	EQUB "th", 0

.SUFFIX
	EQUB ST -WORD
	EQUB ND -WORD
	EQUB RD -WORD
	EQUB TH -WORD

.MONTHS
.JAN
	EQUB "January", 0
.FEB
	EQUB "February", 0
.MAR
	EQUB "March", 0
.APR
	EQUB "April", 0
.MAY
	EQUB "May", 0
.JUN
	EQUB "June", 0
.JUL
	EQUB "July", 0
.AUG
	EQUB "August", 0
.SEP
	EQUB "September", 0
.OCT
	EQUB "October", 0
.NOV
	EQUB "November", 0
.DEC
	EQUB "December", 0

.MTAB1
	EQUB JAN -MONTHS
	EQUB FEB -MONTHS
	EQUB MAR -MONTHS
	EQUB APR -MONTHS
	EQUB MAY -MONTHS
	EQUB JUN -MONTHS
	EQUB JUL -MONTHS
	EQUB AUG -MONTHS
	EQUB SEP -MONTHS
.MTAB2
	EQUB OCT -MONTHS
	EQUB NOV -MONTHS
	EQUB DEC -MONTHS	
}
ELSE
.PRTDMY
{
	LDA DDAY
	JSR PRNTDG
	LDA #'/'
	JSR OSWRCH
	LDA DMONTH
	JSR PRNTDG
	LDA #'/'
	JSR OSWRCH
	LDA DYEAR
	JMP PRNTDG
}
ENDIF


.MW30D
	EQUB 4,6,9,11	;Months with only 30 days
	
.CHKDTE
{
	LDA DDAY,Y
	BEQ CHKDNG
	CMP #32
	BCS CHKDNG
	LDA DMONTH,Y
	BEQ CHKDNG
	CMP #13
	BCS CHKDNG
	CMP #2
	BEQ CHLPYR	;FEB
	LDA DDAY,Y
	CMP #31
	BCC DTOK
	LDX #4
	LDA DMONTH,Y
.CHDTLP
	CMP MW30D - 1,X
	BEQ CHKDNG
	DEX
	BNE CHDTLP
	BEQ DTOK
.CHLPYR			;LEAP YEAR?
	LDA DDAY,Y
	CMP #29
	BCC DTOK	;<29
	CMP #30
	BCS CHKDNG	;>29
	LDA DYEAR,Y
	AND #3
	BNE CHKDNG
.DTOK
	CLC
	RTS
.CHKDNG
	SEC
.^STDTEX
	RTS
}

.STDATE
{
	LDX #0
	STX SECS
	DEX;X:=&FF
	STX RTCSWI;SWI=11
	JSR DONGLE
	BEQ STDTEX;IF DONGLE PRESENT
	LSR RTCSWI;SWI=01
	JSR RDRTC
	BEQ STDTEX;IF ON BOARD RTC
	LSR RTCSWI;SWI=00

	;If here, no time chip, so prompt for date
	JSR VSTRIN;SETUP THE DATE
	EQUB CR,"Date (DD/MM/YY) = "
	NOP

	JSR RDLINE;READ A COMPLETE LINE
	
	JSR GETINT;X:=DAY
	BNE STDATE
	STX DDAY

	LDA (COMPTR),Y
	CMP #'/'
	BNE STDATE
	JSR INCCOM;COMPTR +:=1
	
	JSR GETINT;X:=MONTH
	BNE STDATE
	STX DMONTH
	
	LDA (COMPTR),Y
	CMP #'/'
	BNE STDATE
	JSR INCCOM;COMPTR +:=1
	
	JSR GETINT;X:=YEAR
	BNE STDATE
	STX DYEAR
	
	LDY #0
	JSR CHKDTE
	BCS STDATE

	JSR PRDTE

.STTIME
	JSR VSTRIN
	EQUB CR,"Time (HH:MM)    = "
	NOP

	JSR RDLINE;INPUT TIME
	JSR GETINT;X:=HOURS
	BNE STTIME
	CPX #24;CHECK LESS THAN 24 HOURS
	BCS STTIME
	STX HRS
	LDA (COMPTR),Y
	CMP #':';CHECK CORRECT SEPARATOR
	BNE STTIME
	JSR INCCOM;NEXT INTEGER
	
	JSR GETINT;X:=MINUTES
	BNE STTIME
	CPX #60
	BCS STTIME
	STX MINS
}
	
.SETTME
{
	BIT RTCSWI
	BMI J1
	BVC J2
	RTS
.J1	JMP WRDONG	

.J2	LDA #0

	LDX #4
.SETJL1
	STA TIME,X
	DEX
	BPL SETJL1

	JSR ZEROTM
	LDA HRS
	STA OTIME;PREPARE TO CALCULATE CENTISECONDS
	JSR M60;MULTIPLY BY 60
	JSR M60;DITTO
	JSR M100;TO GET CENTISECONDS
	JSR TIMADD;KEEP TRACK OF TIME
	JSR ZEROTM
	LDA MINS

	STA OTIME
	JSR M60
	JSR M100;TO GET CENTISECONDS
	JSR TIMADD;KEEP TOTAL
	JSR ZEROTM

	LDA SECS
	STA OTIME
	JSR M100;FOR CENTISECONDS
	JSR TIMADD;KEEP TOTAL
	JSR TMTOT
	
	LDX #LO(TIME)
	LDY #HI(TIME)
	LDA #2
	JSR OSWORD
	JMP PRTIM

.TMTOT
{
	LDX #4
.TMJL1
	LDA TIME,X
	STA OTIME,X
	DEX
	BPL TMJL1

	RTS
}

.ZEROTM
{
	LDA #0

	LDX #4
.ZERJL1
	STA OTIME,X
	DEX
	BPL ZERJL1

	RTS
}

.TIMADD
{
	CLC
	LDY #4
	LDX #0
.TIMJL2
	LDA TIME,X
	ADC OTIME,X
	STA TIME,X
	INX
	DEY
	BPL TIMJL2

	RTS
}

.M60
{
	JSR TXOTN
	LDX #6
	JSR SHNTBX
	LDX #2
	JSR SHOTBX
	SEC

	LDX #0
	LDY #4
.M60JL1
	LDA NTIME,X
	SBC OTIME,X
	STA OTIME,X
	INX
	DEY
	BPL M60JL1

	RTS
}

.M100
{
	JSR TXOTN
	LDX #6
	JSR SHNTBX
	LDX #2
	JSR SHOTBX
	CLC

	LDX #0
	LDY #4
.XL5
	LDA NTIME,X
	ADC OTIME,X
	STA NTIME,X
	INX
	DEY
	BPL XL5

	LDX #3
	JSR SHOTBX
	CLC

	LDY #4
	LDX #0
.XL4
	LDA NTIME,X
	ADC OTIME,X
	STA OTIME,X
	INX
	DEY
	BPL XL4

	RTS
}

.TXOTN
{
	LDX #4
.TXOTN1
	LDA OTIME,X
	STA NTIME,X
	DEX
	BPL TXOTN1

	RTS
}


.SHNTBX
	ASL NTIME
	ROL NTIME +1
	ROL NTIME +2
	ROL NTIME +3
	ROL NTIME +4
	DEX
	BNE SHNTBX
	RTS

.SHOTBX
	ASL OTIME
	ROL OTIME +1
	ROL OTIME +2
	ROL OTIME +3
	ROL OTIME +4
	DEX
	BNE SHOTBX
.^PRTRT
	RTS
}

.RDTIME
{
	BIT RTCSWI
	BMI J1
	BVC J2
	JMP RDRTC
.J1	JMP RDDONG

.J2	LDX #LO(TIME)
	LDY #HI(TIME)
	LDA #1
	JSR OSWORD
	JSR DIV100
	JSR DIV60
	LDA REM
	STA SECS
	JSR DIV60
	LDA REM
	STA MINS
	JSR DIV24
	LDA REM
	STA HRS

	LDX #4
	LDA #0
.JLO1
	ORA TIME,X
	DEX
	BPL JLO1
	TAX
	BEQ PRTRT
	
	LDX #LO(TIME)
	LDY #HI(TIME)
	LDA #1
	JSR OSWORD
	SEC
	LDA TIME +1;GONE PAST MIDNIGHT SO SET BACK TO APROX. ZERO
	SBC #&D6
	STA TIME +1
	LDA TIME +2
	SBC #&83
	STA TIME +2
	LDA TIME +3
	SBC #0
	STA TIME +3
	LDA TIME +4
	SBC #0
	STA TIME +4
	LDX #LO(TIME)
	LDY #HI(TIME)
	LDA #2
	JSR OSWORD
	JMP INCDAY

.TDVD
	STA DVSOR
	LDA #0
	LDX #4
.XL0
	STA OTIME,X
	DEX
	BPL XL0

	LDY #&28
.L1
	DEY
	BEQ L10
	ASL TIME
	ROL TIME +1
	ROL TIME +2
	ROL TIME +3
	ROL TIME +4
	BPL L1
.L2
	LDX #LO(-5)	;:LSB: -5
.JLR1
	ROL TIME - LO(-5),X	; :LSB: -5,X
	INX
	BNE JLR1

	LDX #LO(-5)	;:LSB: -5
.JLR2
	ROL OTIME - LO(-5),X	;:LSB: -5,X
	INX
	BNE JLR2

	SEC
	LDA OTIME
	SBC DVSOR
	PHA
	LDA OTIME +1
	SBC #0
	PHA
	LDA OTIME +2
	SBC #0
	PHA
	LDA OTIME +3
	SBC #0
	TAX
	LDA OTIME +4
	SBC #0
	BCC L3
	STA OTIME +4
	STX OTIME +3
	PLA
	STA OTIME +2
	PLA
	STA OTIME +1
	PLA
	STA OTIME
	BCS L4
.L3
	PLA
	PLA
	PLA
.L4
	DEY
	BNE L2
.L10
	LDA OTIME
	STA REM

	RTS

.DIV100
	LDA #100
.DODVD
	JSR TDVD

	LDX #0
	LDY #4
.DODVD1
	ROL TIME,X
	INX
	DEY
	BPL DODVD1

	RTS

.DIV60
	LDA #60
	JMP DODVD

.DIV24
	LDA #24
	JMP DODVD
	
	;Keep track of days without dongle
.INCDAY
{
	LDA DDAY
	CMP #28
	BCS CHMN;IF DAY>=28
.JINCD
	INC DDAY
	BNE IDRET
.CHMN
	LDA DMONTH
	CMP #2
	BEQ CHLPY;IF FEB
	LDA DDAY
	CMP #30
	BCC JINCD;IF DAY<30
	LDX #4
	LDA DMONTH
.CHMLP
	CMP MW30D - 1,X
	BEQ THDM;IF 30 DAY MONTH
	DEX
	BNE CHMLP
	LDA DDAY
	CMP #31
	BNE JINCD
.THDM;NEW MONTH
	LDA DMONTH
	CMP #12
	BEQ ICY;IF DEC
	INC DMONTH
	LDA #1
	STA DDAY
	BNE IDRET
.CHLPY;FEB
	LDA DDAY
	CMP #29
	BEQ THDM
	LDA DYEAR
	AND #3
	BNE THDM;IF NOT LEAP YEAR
	BEQ JINCD
.ICY;NEW YEAR
	LDA #1
	STA DDAY
	STA DMONTH
	INC DYEAR
	LDA DYEAR
	EOR #100
	BNE IDRET
	STA DYEAR
.IDRET
	RTS
}
}

	; Dongle has 4 time set registers :- MINS,HOURS,DATE,MONTH
	; Also has 4 alarm registers which are treated as RAM
	; to store YEAR and OLDMONTH to try to deal with year changes
	; Because cursed chip can not handle years.
	; All number are BCD coded in the chip

	; DESIGNATION AS FOLLOWS :-

	; TIME SET REGISTERS,
	;     0=MONTH      2=DATE    4=HOURS     6=MINS

	; RAM REGISTERS,
	;  1=YEAR in lower 4 bits                        (Was Months)
	;  3=OLDMONTH and bit &10 to indicate LEAP pending (Was date)
	;
	;  5=Not Used
	;  7=User to determine presence of chip            (Was Mins)

	; MM 15/01/22
	; RAM REGISTERS
	; 1(5 bits)=Not used
	; 3(6 bits)=OLDMONTH & LEAP pending
	; 5(6 bits)=Used to test chip present
	; 7(7 bits)=YEAR (00-99) - r/w in binary

	; >>> MM NOTE : CHANGES UNTESTED <<<


.DONGLE;check that the read time clock is present
{
	LDX #5
	LDA #&71
	JSR TSET;write the MONTH alarm register

	LDX #5;read the same register
	JSR TREAD
	EOR #&0D;devious eh

IF FALSE
	BNE RTCX;fail

	LDX #5
	JSR TSET;write zero as well

	LDX #5
	JSR TREAD;read result
	CMP #0
	
.RTCX
ENDIF
	RTS ;returns EQ if dongle present
}

.WRDONG
{
	LDA DYEAR
	LDX #7
	JSR TBSET;set Year

	LDA DMONTH
	LDX #0
	STX OLDDAY
	JSR TSET;set month
	
	JSR SETMFX
	LDX #3
	JSR TSET; Set oldmonth to month and flag

	LDA MINS
	LDX #6
	JSR TSET

	LDA HRS
	LDX #4
	JSR TSET

	LDA DDAY
	LDX #2
	JSR TSET

	JMP PRTIM;SHOW DATE ON SCREEN
		
.SETMFX				; FIX MONTH AND FLAG ON SET TIME
{
	LDX DMONTH
	CPX #2
	BCC SETJAN		; Branch if Jan
	BNE LHNOF		; >JAN so no flag pending

	LDA DDAY
	CMP #29
	BCS LHNOF		; >= 29 so no flag pending

.SETJAN				; befor Feb 29 so check for leap
	LDA DYEAR
	AND #3
	BNE LHNOF		; Not leap so flag clear

	TXA
	ORA #&10		; set flag on month
	RTS

.LHNOF
	TXA
	RTS
}
}

.RDDONG
{
	LDX #6;read minutes
	JSR TREAD
	STA MINS

	LDX #4;hours
	JSR TREAD
	STA HRS

	LDX #2;days
	JSR TREAD
	STA DDAY

	LDX #0;months
	JSR TREAD
	STA DMONTH

	LDX #3;oldmonth
	JSR TREAD
	STA TWORK;  somewhere but where

	LDX #7;year (in alarm register)
	JSR TBREAD
	STA DYEAR

	; FIX year changes
	; Fix date on reading dongle
	; ENTRY DATE+1  has perceived month and year
	;       OTIME+2 has OLDMONTH and Flag
	;       OTIME+3 used

	LDA TWORK
	AND #&0F
	STA TWORK+1
	
	LDA DMONTH; A has month
	CMP TWORK+1
	BCS LHLYCK	;IF MONTH >= OLDMONTH
					; Months are ok so leap year checks
					
					; Here month has decreased so reset year
	INC DYEAR
	LDA DYEAR
	EOR #100
	BNE RFIXX2
	STA DYEAR
	BEQ RFIXX2		; Branch always
					; REWRITE DONGLE
.LHLYCK
	LDA TWORK
	AND #&10
	BNE LHFXNX		; Flag set
	
.RFIXXZ
	RTS

.LHFXNX
	LDA DMONTH		; Load new Month
	CMP #3
	BCC RFIXXZ		; Not MAR yet so exit
	
					; Here it is March (or Later) in a leap year
					; So fix dates
	DEC DDAY		; DEC DAYS
	BNE RFIXX2		; RE WRITE DONGLE

					; DAYS Became ZERO !
	DEC DMONTH		; Decrement month is ok
	LDA DMONTH		; Get new month saves confusion
	CMP #2
	BNE LHNFEB		; IS NOT FEB SO CHECK OTHERS
	
	LDA #29			; Must be 29th
	BNE RFIXEX		; Re Write DONGLE (ALWAYS)

.LHNFEB
	LDX #4
.LHCHKL
	CMP MW30D - 1,X
	BEQ LHCKLX		; FOUND SO EXIT
	DEX
	BNE LHCHKL
	LDA #31
	BNE RFIXEX

.LHCKLX
	LDA #30
.RFIXEX
	STA DDAY
.RFIXX2
	JMP SETTME
}	

	;*** READ/WRITE DONGLE ***
{
	;READ TIME COUNTER/REGISTER
	;ENTRY:
	;X = ADDRESS
	;EXIT:
	;A = VALUE IN BCD
.*TBREAD
.DNG00
	TXA
	JSR DNG05			;SEND ADDRESS
	
	LDY #&06;bits 7,5 are POWERFAIL and ALARM
	JSR DNG55			;Write DDRB, PB0 = INPUT
	JSR DNG10			;SEND LOAD PULSE
	LDA #&04			;DLEN = HIGH, CLOCK = LOW
	JSR DNG45
	
	;READ 7 BIT WORD
	
	JSR DNG50			;FIRST BIT (LA)
	LDX #6
.DNG25
	LDA #&06			;DLEN = HIGH, CLOCK = HIGH
	JSR DNG45
	JSR DNG50			;READ BIT (LB, THEN LC,LD,UA,UB,UC)	
	LDA #&04			;DLEN = HIGH, CLOCK = LOW
	JSR DNG45
	DEX
	BNE DNG25
	
	JSR DNG15			;RESET ORB (DLEN = LOW)
	LDA SR
	LSR A
	RTS ;all done

	;SEND ADDRESS
	;ENTRY:
	;A = ADDRESS
.DNG05
	LDY #&07
	JSR DNG55			;Write DDRB, PB0 = OUTPUT
	
	ASL A				;A = 4 BIT WORD: A1(MSB),A0,S,0(LSB)
	LDX #4
	;fall thru'

	;SEND WORD
	;X = WORD SIZE
	;A = DATA
.DNG30
	ROR A
	PHA
	PHP
	LDA #3
	ROL A				;DLEN = HIGH, CLOCK = HIGH, DATA = C
	JSR DNG45
	PLP
	LDA #2
	ROL A				;DLEN = HIGH, CLOCK = LOW, DATA = C
	JSR DNG45
	PLA
	DEX
	BNE DNG30
	RTS


	;SEND LOAD PULSE
.DNG10
	JSR DNG15
	LDA #&02			;DLEN = LOW, CLOCK = HIGH, DATA = LOW
	JSR DNG45
	
.DNG15
	LDA #&00			;DLEN = LOW, CLOCK = LOW, DATA = LOW

.DNG45;WRITE ORB = A
		;X PRESERVED
	TAY
	TXA
	PHA
	
IF DBG3
	tya
	pha
	lda #'o'
	jsr OSWRCH
	pla
	pha
	jsr WHEX
	pla
	tay
ENDIF
	
	LDA #151
	LDX #&60
	JSR OSBYTE
	JSR WAIT;NOT TOO FAST!
	JSR WAIT
	JSR WAIT;BUT HOW LONG?
	PLA
	TAX
.WAIT
	RTS

.DNG50;READ IRB, SHIFT BIT 0 (DATA) INTO SR
		;PRESERVES X
	TXA
	PHA
IF DBG3
	lda #'i'
	jsr OSWRCH
ENDIF
	LDA #150
	LDX #&60
	JSR OSBYTE
	TYA
	ROR A
	ROR SR
	PLA
	TAX
	RTS

.DNG55;WRITE DDRB = Y
		;PRESERVES A
	PHA
	LDA #151
	LDX #&62
	JSR OSBYTE
IF DBG3
	lda #'d'
	jsr OSWRCH
	tya
	jsr WHEX
ENDIF
	PLA
	RTS


	;WRITE TIME COUNTER/ALARM REGISTER
	;ENTRY:
	;X = ADDRESS
	;A = VALUE IN BINARY
.*TSET
	JSR TOBCD;convert to BCD (without corrupting X)
	
	;A = 7 BIT WORD: UC(MSB),UB,UA,LD,LC,LB,LA(LSB)
	
.*TBSET
	CPX #0;detect writing munths
	BNE DNG99
	ORA #&40			;SET UC
	
.DNG99
	PHA
	TXA
	JSR DNG05			;SEND ADDRESS
	PLA
	LDX #7
	JSR DNG30			;SEND 7 BIT WORD
	JSR DNG10			;SEND LOAD PULSE
	JMP DNG15			;RESET ORB (DLEN = LOW)

.*TREAD
	JSR DNG00
	;JMP TOBIN
}

.TOBIN;convert BCD to BIN
{
	TAY
	BEQ DNG75
	
	LDY #0
	SED
.DNG80
	INY
	SEC
	SBC #1
	BNE DNG80
	CLD
	
	TYA
.DNG75
	RTS
}

.TOBCD;make BIN to BCD
{
	TAY
	BEQ DNG94
	LDA #0
	SED
	
.DNG90
	CLC
	ADC #1
	DEY
	BNE DNG90
	
.DNG94
	CLD
	RTS
}

.RDRTC
{
	;Read RTC, using OSWORD 14
	LDX #0
	STX	DDAY
	STX DMONTH
	INX
	STX DBLK		;Function 1 == Return BCD clock value
	
	LDX #LO(DBLK)
	LDY #HI(DBLK)
	LDA #14
	JSR OSWORD

	LDA DDAY
	ORA DMONTH
	BEQ J3			;If failed
	
	;If successful, on exit values in BCD are:
	;DBLK	?0 = year	(&00-&99)
	;		?1 = month	(&01-&12)
	;		?2 = date (&01-&31)
	;		?3 = day of week (&01-&07, Sun-Sat, or &00=not returned)
	;		?4 = hours (&00-&23)
	;		?5 = minutes (&00-&59)
	;		?6 = seconds (&00-&59)
	
	;CONVERT TO BINARY
	LDX #7

.J1	LDA DBLK-1,X
	JSR TOBIN
	STA DBLK-1,X
	DEX
	BNE J1

	RTS				;&00=Ok
	
.J3	LDA #&FF
	RTS				;&FF=No Clock
}


;.LNK
;UADE05
