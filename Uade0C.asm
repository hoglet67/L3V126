;.OPT
;UADE0C;FILE > Uade0C
;.TTL
;Fileserver file UADE0C

.UADE0C

	;**********************************
	;*           D I R M A N          *
	;**********************************

	;DIRMAN: THE DIRECTORY MANAGER.
	;DIRMAN HAS 10 ENTRY POINTS:-
	;1) PRESERVE SIN OF AN OBJECT IN A DIR
	;2) RETRVE SIN OF AN OBJ WITH GIVEN FILE TITLE
	;3) DELETE - REMOVE A DIR ENTRY
	;4) SETATTRIBS
	;5) CREATE DIR
	;6) CHANGE OBJECT SIZE
	;7) EXAMINE
	;8) FORMATTED DETAILS OF DIR ENTRY
	;9) MAKE DIRECTORY removed ** 3/10/84 **
	;10) GIVE DISC NAME FROM FILE TITLE
	;11) Remove a directory ** 24/9/84 **
	;12) Preserve object (without DELCHK) ** 25/9/84 **

.DIRMAN
{
	LDX #12
	LDA #MODDIR
	JSR ENTRY
	LDA DRRTNS,X
	STA DRJUMP + 1
	LDA DRRTNS + 1,X
	STA DRJUMP + 2
	LDA #&19
	JSR SETFS
.DRJUMP
	JMP DRJUMP
.DRRTNS
	EQUW DRPRES;1 => PRESERVE OBJECT
	EQUW DRRETR;2 => RETRIEVE OBJECT
	EQUW DRDELT;3 => DELETE OBJECT
	EQUW DRSACC;4 => SET ATTRIBUTES
	EQUW DRCRDR;5 => CREATE DIRECTORY
	EQUW DRCHSZ;6 => CHANGE SIZE OF OBJECT (??????)
	EQUW DREXAM;7 => GIVE DETAILS FOR EXAMINE
	EQUW DRINFO;8 => DETAILS OF OBJECT(CHAR STRING FORMAT)
	EQUW DRMAKE;9 => MAKE A DIR (DON'T PRESERVE)
	EQUW DRFTDN;10 => FILE TITLE -> DISC NO.
	EQUW DRDELT;11 => Remove a directory
	EQUW DRPRES;12 => Preserve object without delchk
}
.DREXIT
	JMP EXIT

	;*********** DRPRES ***********

	;DRPRES: PRESERVE THE SIN OF AN OBJECT WITH A GIVEN TITLE

	;ENTRY: ARGB = LS
	;ARGC = MS(PTR TO USERINFO)
	;ARGD = LS
	;ARGE = MS(PTR TO FILE TITLE)
	;ARGF = LS
	;ARGG = B1
	;ARGH = B2
	;ARGI = MS(LOAD ADDR)
	;ARGJ = LS
	;ARGK = B1
	;ARGL = B2
	;ARGM = MS(EXEC ADDR)
	;ARGN = TYPE AND ACCESS (TLWR/WR)
	;ARGO = LS
	;ARGP = MS(DATE CREATED)
	;ARGQ = LS(SIN)
	;ARGR = CS(SIN)
	;ARGS = MS(SIN)
	;ARGT = WILD CARD FLAG

	;EXIT : ARGA = RC
	;ARGB = LS(DISC NO)
	;ARGC = MS(DISC NO)
	;ARGD = LS(SIN)
	;ARGE = CS(SIN)
	;ARGF = MS(SIN OF OBJECT TO BE DELETED)
	;ARGG = Access byte

	;N.B. IF ARGD!ARGE!ARGF = 0 THEN NO DELETE NEEDED


.DRPRES
{
	LDY #ARGT;get wild card flag
	LDA (ARGPTR),Y
	STA DIRWC;save flag for decoding routines
	JSR INITDV;INIT VARIABLES
	BNE DRPRSY

	;CHECK FOR OWNER ACCESS

	JSR TSTOWN
	BNE DRPRSY

	;RETRIEVE APPROPRIATE DIR

	JSR RETDIR
	BNE DRPRSY

	LDY #ARGA
	LDA (ARGPTR),Y;check entry code
	EOR #12;dont do DELCHK in retain

	JSR RETA12;special case
.DRPRSY
	PHA
	LDA OBJACC
	LDY #ARGG
	STA (ARGPTR),Y
	PLA
	JMP DREXIT
}


	;************ DRRETR ************


	;DRRETR: RETRIEVE DETAILS OF A SPECIFIED OBJECT

	;ENTRY:
	;ARGB = LS(PTR TO USERINFO)
	;ARGC = MS(PTR TO USERINFO)
	;ARGD = LS(PTR TO FILE TITLE)
	;ARGE = MS(PTR TO FILE TITLE)
	;ARGF = LS(ADDRESS OF STORE AREA TO CONTAIN DETAILS)
	;ARGG = MS(PTR TO STORE AREA)
	;ARGH = WILD CARD FLAG

	;EXIT:
	;ARGA = RC
	;ARGB = TYPE OF OBJECT & MAX ACCESS ALLOWED TO IT
	;       Also contains "lock" bit and OWNER/PUBLIC bit

	;DETAILS INCLUDE:-
	;FILE TITLE (10 BYTES)
	;LOAD ADDR (4BYTES),
	;EXEC ADDR (4BYTES),
	;ACC INFO (1 BYTE),
	;CREATION DATE (2 BYTE),
	;SIN (3BYTES),
	;DISC NO (2BYTES),
	;SIZE (3BYTES).


.DRRETR
{
	LDY #ARGH
	LDA (ARGPTR),Y
	ORA #&02
	STA DIRWC;get wild card flag
	JSR INITDV
	BEQ DDREL1
	JMP DRRERZ
.DDREL1

	JSR INFSPT
	
	LDY #INFDIS;DISC NUMBER
	LDA DRDISC
	STA (INFPTR),Y
	INY
	LDA DRDISC + 1
	STA (INFPTR),Y

	;RETRIEVE RELEVENT DIR

	JSR TSTROT;TEST FOR <root><terminator>, I.E. '$',CR
	BNE DRREL3

	;SUPPLY DETAILS OF ROOT DIR

.DRREL2
	LDY #INFLOA
	LDX #8
	LDA #0
.DRRERB
	STA (INFPTR),Y;LOAD ADDRESS:=EXEC ADDR:=0
	INY
	DEX
	BNE DRRERB

	LDA DIRACC
	LDY #ARGB
	STA (ARGPTR),Y;ACCESS TO ROOT DIR
	
	LDY #INFDTE
	LDA TDATE;(DATE OF CREATION ROOT)
	STA (INFPTR),Y
	INY			;MISSING IN 1.06 & 1.24
	LDA TDATE + 1
	STA (INFPTR),Y
	
	LDY #INFACC
	LDA #TYPDIR
	STA (INFPTR),Y
	
	LDA DIRSIN
	LDY #INFSIN
	STA (INFPTR),Y
	LDA DIRSIN + 1
	INY
	STA (INFPTR),Y
	LDA DIRSIN + 2
	INY
	STA (INFPTR),Y
	
	JSR DRSOBJ;OBJSIN := DIRSIN
	JSR RETDSZ;PLACE DISC NO & SIZE IN INFPTR
	JMP DRRERX
	
.DRREL3;NOT ROOT, SO?
	JSR TSTPAR;PARENT DIR?  TEST FOR <parent><terminator>, I.E. '^',CR
	BNE DRREL6
	
.DRREL4
	CLC
	LDA DIRSTA;STORE ADDRESS OF DIR
	ADC #DRNAME
	STA MOVFRM
	LDA DIRSTA + 1
	ADC #0
	STA MOVFRM + 1
	
	LDY #9;COPY NAME
.DRREL5
	LDA (MOVFRM),y
	STA (INFPTR),Y
	DEY
	BPL DRREL5
	BMI DRREL2;AS PER ROOT


.DRREL6;NOT '^', SO?
	LDY #1
	LDA (NAMPTR),Y
	CMP #TERMIN
	BNE DRRERD
	DEY
	LDA (NAMPTR),Y
	JSR TSTSYM;&, % or @?
	BNE DRRERD
	
	JSR LOADDR
	BNE DRRERZ

.DRREL7
	JSR UNLOCK
	JMP DRREL4

.DRRERD
	LDY #ARGH;get flag
	LDA (ARGPTR),Y
	ROR A
	BCC DRRELA
	JSR RETEND;get directory
	JMP DRRELB
.DRRELA
	JSR RETENT
.DRRELB
	BNE DRRERZ

	JSR TSTPSP;TEST TXTNAM STARTS WITH '^' FOLLOWED BY SPACE
	BEQ DRREL7;YES

	;COPY DETAILS INTO STORE AREA POINTED TO BY INFPTR

	JSR DETALS
	PHA ;Push return code

	;NOW CALCULATE CALLER'S ACCESS TO THE OBJECT

	JSR MAXACC

	LDY #ARGB
	STA (ARGPTR),Y;TYPE & MAX ACCESS ALLOWED TO OBJECT
	JSR UNLOCK;STRMAN.UNLOCK (DIR)
	PLA ;Pull DETALS return code
	BNE DRRERZ;Error

.DRRERX
	LDA #0;RC:=0

.DRRERZ
	JMP DREXIT
}
	

.INFSPT	;MAKE INFPTR POINT TO DETAILS AREA
	LDY #ARGF
	LDA (ARGPTR),Y
	STA INFPTR
	INY ;Y:=ARGG
	LDA (ARGPTR),Y
	STA INFPTR + 1
	INY	;Y:=ARGH
	RTS




	;************ DRDELT ************


	;DRDELT: DELETE

	;ENTRY: ARGB = LS(PTR TO USERINFO)
	;ARGC = MS(PTR TO USERINFO)
	;ARGD = LS(PTR TO FILE TITLE)
	;ARGE = MS(PTR TO FILE TITLE)
	;ARGG = WILD CARD FLAG

	;EXIT : ARGA = RC
	;ARGB = LS(DISC NO)
	;ARGC = MS(DISC NO)
	;ARGD = LS(SIN)
	;ARGE = CS(SIN)
	;ARGF = MS(SIN OF OBJECT TO BE DELETED)


.DRDELT
{
	LDY #ARGG
	LDA (ARGPTR),Y
	STA DIRWC;get wild card flag
	JSR INITDV;INIT VARIABLES
	BNE DRDLTY

	;CHECK FOR OWNER ACCESS

	JSR TSTOWN
	BNE DRDLTY

	;RETRIEVE APPROPRIATE DIR ENTRY

	JSR RETENT;RETRIEVE REQ'D ENTRY
	BNE DRDLTY

	;FIRST CHECK THAT ENTRY MAY BE DELETED

	LDY #ARGA;check entry code
	LDA (ARGPTR),Y;** 24/9/84 **
	CMP #11
	BEQ DRDLTC;skip delete check if 'remove' called

	JSR DELCHK
	BEQ DRDLTC
	JSR UNLOCK
	BNE DRDLTY

	;NOW REMEMBER DISC NO & SIN OF OBJECT TO BE DELETED

.DRDLTC
	JSR CRNSIN;OBJSIN := SIN OF CRNTEN
	JSR ARGDSN;PLACE DISC NO & SIN ON ARGPTR STACK

	;NOW UNCHAIN CURRENT DIR ENTRY & PLACE
	;IT ON THE FREE CHAIN

	LDY #DRLINK
	LDA (CRNTEN),Y
	STA (PREVEN),Y
	INY
	LDA (CRNTEN),Y
	STA (PREVEN),Y;[PREVEN] := [CRNTEN]

	JSR FREECH;PLACE CRNTEN ENTRY ON FREE CHAIN

	;NOW DECREMENT COUNT OF NUMBER OF DIR ENTRIES

	JSR SETGEN;GENPTR := [DIRSTA]
	SEC
	LDY #DRENTS
	LDA (GENPTR),Y
	SBC #1
	STA (GENPTR),Y
	INY
	LDA (GENPTR),Y
	SBC #0
	STA (GENPTR),Y;[DIRSTA + DRENTS] -:= 1

	;ENSURE UPTO DATE ON DISC

	JSR ENSRIT

.DRDLTY
	JMP DREXIT
}

	;************ DRSACC ************


	;DRSACC: SET ATTRIBUTES

	;ENTRY: ARGB = LS(PTR TO USERINFO)
	;ARGC = MS(PTR TO USERINFO)
	;ARGD = LS(PTR TO FILE TITLE)
	;ARGE = MS(PTR TO FILE TITLE)
	;ARGF = WILD CARD FLAG

	;ARGG = FN
	;     FN = 1 => SET LOAD/EXEC & ACCESS
	;     FN = 2 => SET LOAD ADDR
	;     FN = 3 => SET EXEC ADDR
	;     FN = 4 => SET ACCESS BYTE
	;     FN = 5 => SET DATE
	;ARGH +n (depending on ARGF) = ATTRIBUTES TO SET

	;EXIT : ARGA = RC


	;FORMAT OF ACCESS BYTE:-

	;BIT0->PUBLIC HAS READ ACCESS
	;BIT1->PUBLIC HAS WRITE ACCESS
	;BIT2->OWNER HAS READ ACCESS
	;BIT3->OWNER HAS WRITE ACCESS
	;BIT4->ENTRY IS LOCKED

.DRSAT1
	EQUB DRLOAD;Offsets in directory entry
	EQUB DRLOAD
	EQUB DREXEC
	EQUB DRACCS
	EQUB DRDATE

.DRSAT2
	EQUB 9;Length of data
	EQUB 4
	EQUB 4
	EQUB 1
	EQUB 2

.DRSACC
{
	LDA #0
	STA DMTEMP + 2;save space for Access arg
	LDY #ARGF
	LDA (ARGPTR),Y
	STA DIRWC;get wild card flag
	JSR INITDV;INITIALISE VARIABLES
	BNE DRSAC5

	LDY #ARGG;CHECK IF JUST DATE UPDATE
	LDA (ARGPTR),Y
	CMP #5
	BEQ DRSACA;NO NEED FOR OWNER ACCESS

	;CHECK FOR OWNER ACCESS

	JSR TSTOWN
	BNE DRSAC5

	;RETRIEVE APPROPRIATE DIR ENTRY

.DRSACA
	JSR RETENT
	BNE DRSAC5

.DRSACL
	LDY #ARGG
	LDA (ARGPTR),Y
	STA DMTEMP + 1;Store for later
	LDY #ARGH;Position of access if A=4
	CMP #4;If SETACCESS, must mask off access bits
	BEQ DRSAC4;Is SETACCESS -> check access byte
	CMP #5;** 31/1/85 **
	BEQ DRSAC2
	CMP #1
	BNE DRSAC1;Is "all attribs" so check access
	LDY #ARGP;Position of access if A = 1

.DRSAC4
	STY DMTEMP;Store offset of access
	LDA (ARGPTR),Y;Read access byte
	AND #ACCMSK;Mask off access bits
	ORA DMTEMP + 2
	STA DMTEMP + 2
	STA (ARGPTR),Y
	TAX ;Store for later

	;** 15/11/84 ** w/ access illegal
	AND #&0C;owner bits set
	BEQ DRSAC8
	AND #&04;at least r bit set
	BNE DRSAC8
	LDA #SAERRA;'bad attribute' error
	BNE DRSAC3

.DRSAC8
	JSR ISDIR
	BNE DRSAC2;Is not a directory, so continue
	TXA
	AND #ACCMSK-RWMSK;just the lock bit
	ORA #TYPDIR;Or in directory info. if a dir.
	LDY DMTEMP
	STA (ARGPTR),Y;Stuff access argument
	LDA DMTEMP + 1;Load function no.
	CMP #1
	BNE DRSAC2;Check not setting load/exec. of a dir.

.DRSAC1
	JSR ISDIR
	BNE DRSAC2;Cannot set load/exec address of dir., so error
	LDA #DRERRF;Bad arg.

.DRSAC3
	JSR UNLOCK;Otherwise, error
.DRSAC5
	JMP DRSACY;Error exit

.DRSAC2
	LDY #ARGG;Here, all checks made, so set attribs
	LDA (ARGPTR),Y
	TAY
	LDA #ARGH;Set args for block move from stack
	STA OFF1;to some offset in CRNTEN
	LDA DRSAT1 - 1,Y;Get offset in dir. entry
	STA OFF2;"Move to" offset
	LDA DRSAT2 - 1,Y;Length to move
	LDX #ARGPTR;"Move from" ptr.
	LDY #CRNTEN;"Move to" ptr.
	JSR MOVBLK;Move args to stack

	LDY #ARGG
	LDA (ARGPTR),Y
	CMP #5;DON'T SET ALL DATES
	BEQ DRDSET

	JSR FNDTEZ;try for any more entries
	BNE DRDSET
	JMP DRSACL

.DRDSET
	JSR ENSRIT;Ensure directory and exit

.DRSACY
	JMP DREXIT


}

	;************ DRCRDR ************


	;DRCRDR: CREATE & PRESERVE A NEW DIRECTORY

	;ENTRY: ARGB = LS(PTR TO USERINFO)
	;ARGC = MS(PTR TO USERINFO)
	;ARGD = LS(PTR TO FILE TITLE)
	;ARGE = MS(PTR TO FILE TITLE)
	;ARGF = Size of directory ** 15/9/83 **
	;ARGG = WILD CARD FLAG

	;EXIT : ARGA = RC
	;ARGB = LS(DISC NO)
	;ARGC = MS(DISC NO)
	;ARGD = LS(SIN)
	;ARGE = CS(SIN)
	;ARGF = MS(SIN OF OBJECT TO BE DELETED)

.DRCRDR
{
	LDY #ARGG
	LDA (ARGPTR),Y
	STA DIRWC;get wild card flag
	JSR INITDV
	BNE DRCRRY

	;CHECK FOR OWNER ACCESS

	JSR TSTOWN
	BNE DRCRRY

	JSR RETDIR
	BNE DRCRRY
	
	LDA DIRSIN
	STA EXRTN
	LDA DIRSIN + 1
	STA EXRTN + 1
	LDA DIRSIN + 2
	STA EXRTN + 2

	JSR UNLOCK

	JSR TSTPAR
	BEQ DRCRRK
	
	LDY #0
	LDA (NAMPTR),Y
	JSR TSTSYM
	BNE DRCRRB;NOT SYMBOL
	
	JSR TSTCR1
	BEQ DRCRRK;FOLLOWED BY CR

	;CREATE A VIRGIN DIRECTORY

.DRCRRB
	LDY #ARGG
	LDA (ARGPTR),Y
	STA DIRWC
	JSR INITDV
	BNE DRCRRY


	LDY #ARGF
	LDA (ARGPTR),Y
	STA DIRTMP + 1;DIRTMP := SIZE OF DIRECTORY REQD.
	LDA #0
	STA DIRTMP
	STA DIRTMP + 2
	JSR MAKDIR;SETUP ARGPTR ARGUMENTS FOR DIRMAN.PRESERVE
	BNE DRCRRY

	;NOW UNLOCK THE CREATED DIR - THE RETAIN RTN
	;ENSURES THAT ITS UPTO DATE ON DISC

	JSR UNLOCK

	;NOW HAVE IT RETAINED

	JSR INITDV;REINITIALISE VARIABLES
	BEQ DRCRRJ

.DRCRRI;OBJSIN:=SIN OF NEW DIR(RETAIN DESTROYS OBJSIN)
	JSR DELOBJ;**** 17/3/83 ****
	JMP DRCRRY

	;LOAD APPROPRATE DIR

.DRCRRJ
	JSR RETDIR
	BNE DRCRRI

	;NOW HAVE IT RETAINED IN THIS DIR

	JSR RETAIN
	BNE DRCRRI
.DRCRRY
	JMP DREXIT
	
.DRCRRK
	LDA #DRERRA
	BNE DRCRRY
}

	;************ DRCHSZ ************


	;DRCHSZ: CHANGE SIZE OF A FILE

	;ENTRY: ARGB = LS
	;ARGC = MS(PTR TO USERINFO)
	;ARGD = LS
	;ARGE = MS(PTR TO FILE TITLE)
	;ARGF = LS
	;ARGG = CS
	;ARGH = MS(NEW SIZE)

	;EXIT : ARGA = RC

	;FUNCTION:-
	;REMOVE ALL OF THE OBJECT FROM THE CACHE;
	;IF TYPE OF OBJECT = FILE
	;THEN CHECK FOR WRITE ACCESS;
	;CHECK THAT FILE IS NOT OPEN;
	;CHANGE SIZE;
	;ENSURE OBJECT MAP UPTO DATE ON DISC
	;ELIF TYPE OF OBJECT = DIR
	;THEN RC:=WRONG TYPE #AUTOMATICALLY DONE IN RETAIN#
	;FI


.DRCHSZ;GONE!
	LDA #3
	JMP INTERR;
	
	
	;******** EXAMINE ROUTINE ********

	;DREXAM : GIVE DETAILS OF ENTRY(S) IN A DIR.
	;ENTRY: ARGB = LS
	;ARGC = MS(PTR TO USER INFO)
	;ARGD = LS
	;ARGE = MS(PTR TO FILE TITLE)
	;ARGF = LS
	;ARGG = MS(ADDRESS OF STORE FOR RESULT)
	;ARGH = TYPE OF RESULT REQURIED
	;0 => ALL INFO, M/C READABLE
	;1 => ALL INFO, CHAR STRING
	;2 => FILE TITLE + FILE NAME LENGTH, M/C
	;3 => ACCESS+FILE TITLE, CHAR STRING
	;4 => GIVE LAST COMPONENT F.T. ONLY
	;ARGI = ENTRY POINT TO DIR.
	;ARGJ = NO. OF ENTRIES (0=> ALL DIR.)
	;ARGK = WILD CARD FLAG

	;EXIT : ARGB = LS
	;ARGC = MS(PTR TO BYTE AFTER RESULT END)
	;ARGD = NO. OF ENTRIES
	;ARGE = SEQ. NO. OF DIRECTORY BEING EXAMINED

	;WHEN ARGH IS 4, ARGD IS MAX. ACCESS TO DIR,
	;ARGE IS SEQUENCE NUMBER OF DIR., AND
	;ARGF/G ARE DISC. NO LO/HI

{
.DEXTAB;DEXTAB

	;TABLE OF EXAMINE ROUTINE ENTRY POINTS

	EQUW EXRTNA
	EQUW EXRTNB
	EQUW EXRTNC
	EQUW EXRTND


.*DREXAM
	LDA #0
	STA DIRFLG
	LDY #ARGK
	LDA (ARGPTR),Y
	ORA #&02
	STA DIRWC;get wild card flag
	ROR A;look at bit0
	BCC DREXCA
	LDA #&80
	STA DIRFLG
	
.DREXCA
	JSR INITDV
	BNE DEXRTZ

	JSR INFSPT;STORE RESULT PTR.

	;Y:=ARGH
	LDA (ARGPTR),Y
	CMP #5
	BCC DEXONQ;IF <5, OK

	LDA #DRERRO;BAD ARG. TO EXAMINE
	BNE DEXRTZ

.DEXONQ
	STA EXARG;TYPE OF RESULT
	INY
	LDA (ARGPTR),Y
	STA EXENTR;ENTRY TO DIR.
	INY
	LDA (ARGPTR),Y

	JSR CHKENS
	BCC DEXONY;OK

	LDA #DRERRN;TOO MANY ENTRIES REQUESTED
.DEXRTZ
	JMP DEXRTS


.DEXONY
	STA EXENTS;NO. OF ENTRIES

	JSR GETDRD;LOAD APPROPRIATE DIR
	BNE DEXRTZ

	LDA #4
	CMP EXARG
	BNE DEXOND

	;IF HERE, COPY FILE NAME FROM DIRECTORY
	;INTO RESULT AREA.

	LDY #DRNAME;OFFSET IN DIR.
	LDX #0
.DEXLPZ
	LDA (DPTRLD),Y
	STA (INFPTR,X)
	INY
	JSR INCIPT
	CPY #DRFREE
	BNE DEXLPZ

	LDY #DRSQNO
	LDA (DPTRLD),Y;Read dir. sequence number
	PHA ;Store for later use

	LDA DIRACC
	LDY #ARGD
	STA (ARGPTR),Y
	PLA ;Pull sequence number
	INY
	STA (ARGPTR),Y
	LDA DRDISC
	INY
	STA (ARGPTR),Y
	INY
	LDA DRDISC + 1
	STA (ARGPTR),Y
	JMP DEXONI

.DEXOND
	JSR INTPRE;PREVEN := DIRSTA

.DEXLPA

	;FOR I=0 TO EXENTR DO
	;$( SET CURRENT := NEXT(PREV. ENTRY)
	;IF END OF DIR...EXIT WITH RC SET
	;PREVENTRY := CURRENT ENTRY
	;$)

	JSR SETCRN
	BEQ DEXONH;Zero => end of dir => exit

	LDA EXENTR
	DEC EXENTR
	TAX
	BEQ DEXONE;LOOP FINISHED

	JSR MOVCRN;PREVEN := CRNTEN
	JMP DEXLPA

.DEXONE;DEXONE

	;SET ROUTINE TO BE USED, DEPENDING
	;ON EXARG.
	;EXRTN := JMP <examine routine>

	LDA EXARG
	ASL A
	TAX
	LDA DEXTAB,X
	STA EXRTN + 1
	LDA DEXTAB + 1,X
	STA EXRTN + 2
	LDA #JMPINS
	STA EXRTN

	LDA #0;NO. OF ENTRIES

.DEXLPB

	;LOOP ROUND EXAMINE ROUTINE, DECREMENTING
	;EXENTS, AND CHAINING THROUGH DIR.

	PHA ;STORE NO. OF ENTRIES
	JSR EXRTN
	BEQ DEXONJ
	TAX
	PLA ;Restore stack
	TXA
	JSR UNLOCK
	BNE DEXRTS;Error -> exit [always jump]

.DEXONJ
	PLA
	CLC
	ADC #1;ADD NO. OF ENTS.
	PHA

	LDA CRNTEN
	STA PREVEN
	LDA CRNTEN + 1
	STA PREVEN + 1
	JSR SETCRN;CURRENT := NEXT(PREV)
	BEQ DEXONG;NOT OK, FINISH LOOP

	PLA
	CMP EXENTS
	BNE DEXLPB

	;FINALLY, SET END OF BLOCK INDICATOR.
.DEXONH
	PHA

.DEXONG
	LDA #EXTERM
	LDY #0
	STA (INFPTR),Y

	JSR INCIPT;INCREMENT POINTER TO END OF BLOCK (USED IN TXCB).

	LDY #ARGB
	LDA INFPTR
	STA (ARGPTR),Y
	INY
	LDA INFPTR + 1
	STA (ARGPTR),Y
	INY
	PLA ;GET NO. OF ENTRIES
	STA (ARGPTR),Y

	LDY #DRSQNO
	LDA (DPTRLD),Y;Get sequence no. of examined dir.
	LDY #ARGE
	STA (ARGPTR),Y;And return it

.DEXONI
	JSR UNLOCK

	LDA #0;OK EXIT
.DEXRTS
	JMP DREXIT



}

	;******** DRINFO ********

	;DRINFO: RETRIEVE DETAILS OF A GIVEN OBJECT IN
	;FORMATTED FORM.

	;ENTRY: ARGB = LS (PTR TO USER INFO)
	;ARGC = MS (PTR TO USER INFO)
	;ARGD = LS(PTR TO FILE TITLE)
	;ARGE = MS(PTR TO FILE TITLE)
	;ARGF = LS(ADDRESS OF RESULT AREA)
	;ARGG = MS(ADDRESS OF RESULT AREA)
	;ARGH = WILD CARD FLAG

	;EXIT:  ARGB = LS(ADDRESS OF BYTE AFTER RESULT AREA)
	;ARGG = MS(ADDRESS OF BYTE AFTER RESULT AREA)

	;BYTE AFTER RESULT AREA IS USED TO
	;SET UP BUFFER POINTERS IN TXCB AFTER
	;DETAILS CALL.



.DRINFO
{
	LDY #ARGH
	LDA (ARGPTR),Y
	STA DIRWC;get wild card flag
	JSR INITDV
	BNE DRINFR;EXIT IF ERROR

	JSR INFSPT;Set pointer to result area

	JSR TSTROT;IS ROOT ??
	BNE DINONA;NO

	;IF HERE, SUPPLY DETAILS OF ROOT.

	JSR DRSOBJ;SET OBJSIN FOR SIZE ROUTINE

	LDA #ROOT
	JSR OUTCH;Ouput dir. name
	LDX #&0A
	JSR OUTSPS;Pad dir. name

	JSR OUTZRO;Output 8 zeros
	JSR OUTSP
	JSR OUTZRO;8 more zeros (exec address)
	LDX #3
	JSR OUTSPS
	JSR OUTSZA
	BNE DRINFE
	LDA #(TYPDIR OR LOCKED)
	ASL A
	JSR OUTACA;Output access

	LDX #4
	JSR OUTSPS

	;LDX #2
	JSR OUTRTD
	
	LDA OBJSIN + 2
	JSR OUTBYT
	LDA OBJSIN + 1
	JSR OUTBYT
	LDA OBJSIN
	JSR OUTBYT
	JMP DINFIN;FINISHED .....


.DINONA;DINONA

	;HERE DOING NON-ROOT OBJECT

	JSR RETENT;RETRIEVE BOTTOM ENTRY
	BNE DRINFE

	JSR OUTENT;Put out entry details
	JSR UNLOCK;UNLOCK CURRENT DIR. (note does PHA/PLA)
.DRINFR
	BNE DRINFE;Unsuccessful MAPMAN call

.DINFIN

	;END OF ENTRY. PUT CR AT END TO FORCE
	;A NEW LINE IF OSASCII'ING AT THE
	;CLIENT END, AND EXTERM CHAR. TO
	;INDICATE END OF DATA.

	LDA #CR
	JSR OUTCH
	LDA #EXTERM
	JSR OUTCH

	LDY #ARGB;PUT INFPTR ON STACK AS RESULT
	LDA INFPTR
	STA (ARGPTR),Y
	INY
	LDA INFPTR + 1
	STA (ARGPTR),Y

	LDA #0

.DRINFE
	JMP DREXIT
}


.DRSOBJ
	LDA DIRSIN
	STA OBJSIN
	LDA DIRSIN + 1
	STA OBJSIN + 1
	LDA DIRSIN + 2
	STA OBJSIN + 2;OBJSIN := DIRSIN
	RTS


.DRMAKE
	LDA #LO(-1)
	JMP DREXIT;** 3/10/84 **
	

	;************* DRFTDN ****************

	;GIVEN FILE TITLE, ANALYSE TO GET DISC NUMBER
	;AND RETURN. USED BY SAVE IN C.PROC TO
	;RESOLVE ON WHAT DISC TO SAVE A FILE

	;ENTRY: ARGB - PTR TO USER INFO
	;ARGC -  "   "  "     " (HI)
	;ARGD - (LO) PTR TO FILE TITLE
	;ARGE - (HI)  "      "      "
	;ARGF = WILD CARD FLAG

	;EXIT: ARGB/C = DISC NUMBER

.DRFTDN
{
	LDY #ARGF
	LDA (ARGPTR),Y
	STA DIRWC;get wild card flag
	JSR INITDV
	BNE DRFTEX
	LDY #ARGB
	LDA DRDISC
	STA (ARGPTR),Y
	INY
	LDA DRDISC + 1
	STA (ARGPTR),Y
	LDA #0;=> success
.DRFTEX
	JMP DREXIT
}
;.LNK
;UADE0D
;
