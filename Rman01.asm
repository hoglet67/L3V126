;.OPT
;RMAN01; FILE > Rman01
;.TTL
;Fileserver file RMAN01

.RMAN01


	;*********************************
	;*          R N D M A N          *
	;*********************************



	;RNDMAN: THE RANDOM ACCESS MANAGER IS RESPONSIBLE
	;FOR MAINTAINING A LIST OF OPENED OBJECTS
	;(HANDTB) & FOR KEEPING VARIOUS DETAILS
	;ABOUT OPENED FILES (RANDTB).
	;RNDMAN PROVIDES THE FOLLOWING FUNCTIONS:-

	;1) OPEN OBJECT (GIVE HANDLE)
	;2) INFO (INDICATE WHETHER OPEN)
	;3) CLOSE OBJECT
	;4) RESTART
	;5) CREATE A HANDLE FOR AN OBJECT WITH SPECD HANDLE
	;6) DELETE ALL HANDLES FOR A GIVEN M/C
	;7) READ BYTE FROM FILE
	;8) WRITE BYTE TO FILE
	;9) GETBYTES
	;10) PUTBYTES
	;11) Read args of open file
	;12) Set args of open file
	;13) Close all files for machine
	;14) Set up for PUTBYTES/GETBYTES calls



	;THE HANDTB CONTAINS THE FOLLOWING
	;INFO:-
	;0) HANDLE (1 BYTE)
	;1) MC/NO (2 BYTES)
	;2) TYPE AND ACCESS (1 BYTE)
	;3) DISC NUMBER (2 BYTES)
	;4) SIN (3 BYTES)
	;5) MODE(1BYTE)-MULTIPLE READER/SINGLE WRITER
	;6) RANDTB OFFSET(1 BYTE)



	;********* MAIN ROUTINE ***********



.RNDMAN
{
	LDX #&F;RNDMAN HAS 15 ENTRY POINTS
	LDA #MODRND;A:=NAME OF THIS MODULE
	JSR ENTRY
	LDA RDRTNS,X
	STA RDJUMP + 1
	LDA RDRTNS + 1,X
	STA RDJUMP + 2

	LDA #&F
	JSR SETFS;SET FRAME SIZE
.RDJUMP
	JMP RDJUMP
.RDRTNS
	EQUW RDOPEN;1 => OPEN OBJECT (ISSUE A HANDLE)
	EQUW RDINFO;2 => INFO (INDICATE WHETHER OBJECT IS OPEN)
	EQUW RDCLOS;3 => CLOSE OBJECT (INVALIDATE HANDLE)
	EQUW RDREST;4 => RESTART
	EQUW RDCOPY;5 => GENERATE ANOTHER HANDLE FOR AN OBJECT
	EQUW RDCLAL;6 => DELETE ALL HANDLES FOR A USER
	EQUW RDRDCH;7 => READCH
	EQUW RDWRCH;8 => WRITECH
	EQUW RDGBTS;9 => GETBYTES FROM FILE
	EQUW RDPBTS;10 => PUTBYTES TO FILE
	EQUW RDRDAR;11 => Read args of file
	EQUW RDSTAR;12 => Set args of file
	EQUW RDCLAF;13 => Close all files for machine
	EQUW RDSUBO;14 => Set up for bytes operation
	EQUW RDEOF;15 => Read "end of file" status
}
.RDEXIT
	JMP EXIT



	;************ RDOPEN ************


	;RDOPEN: OPEN AN OBJECT & RETURN A HANDLE FOR IT.

	;ENTRY: ARGB = LS(PTR TO USERINFO)
	;ARGC = MS(PTR TO USERINFO)
	;ARGD = MODE(HOW OBJECT SHOULD BE OPENED)
	;ARGE = TYPE & ACCESS ALLOWED TO OBJECT
	;ARGF = LS(PTR TO OBJECT DETAILS)
	;ARGG = MS(PTR TO OBJECT DETAILS)

	;NOTE:- ARGD (MODE)
	;BIT 0 => READ ACCESS NEEDED
	;BIT 1 => WRITE ACCESS NEEDED
	;BIT 7 => FILE JUST CREATED
	;RNDMAN INFORCES MULTIPLE READER - SINGLE WRITER
	;INTERLOCKS.

	;EXIT : ARGA = RC
	;ARGB = HANDLE
	;ARGC =  (LS) Station Id on 'already open' error ** 14/9/84 **
	;ARGD =  (MS) Station Id on 'already open' error

	;FUNCTION: MAKE HANDTB ENTRY
	;IF TYPE OF OBJECT = TYPFIL
	;THEN MAKE NEW RANDTB ENTRY
	;FI


.RDOPEN
{
	JSR INITRD;INITIALISE MCNUMB,&GETPTR:=USERINFO,RNDPTR

	;SEE IF THIS MACHINE CAN OPEN ANOTHER FILE
	;AND SEE WHETHER THERE IS ANY ROOM IN THE HANDTB

	JSR GETHND;HNDPTR:=PTR TO A FREE HANDTB ENTRY
	BNE RDOPNY
	LDY #ARGE
	LDA (ARGPTR),Y;TYPE & ACCESS

	;ITS A FILE SO SEE IF THERE IS ROOM IN RANDTB


	AND #TYPDIR
	BNE RDOPNE;Branch if directory

	;The object is a file: must check that it can be opened
	;for the requested access. (A file may be held open by
	;a single writer, or by multiple readers).
	;If it may be opened, then find a slot in RANDTB and
	;fill it in.  A pointer to the entry in RANDTB is
	;put in HANDTB (stored in 2 bytes).

	JSR RDCKAC;Check access allowed (corrupts HNDPTR)
	BNE RDOPNY;not ok!
	
	JSR GETHND;HNDPTR := free HANDTB entry
	BNE RDOPNY;Didn't get one

	JSR GETRND;RTEPTR := free RANDTB entry
	BNE RDOPNY;Didn't get one

	LDA RTEPTR;Store RANDTB entry ptr in HANDTB entry
	LDY #HTRPTR
	STA (HNDPTR),Y
	INY
	LDA RTEPTR + 1
	STA (HNDPTR),Y

	;Fill in new RANDTB entry (currently all zero)

	LDA #&80;"In use" flag + seq num zero
	LDY #RTINUS
	STA (RTEPTR),Y;Mark entry "in use"

	;Current and old sequential file pointers
	;already set to zero.
	;High water mark and size both set from
	;file size in object details.

	LDA #RTFSZE
	JSR MOVRD3;Little block move routine

	;High water mark used only if the object is open for
	;update.  If the file is new, then leave zero, otherwise
	;set to file size.

	LDY #ARGD;Get mode byte
	LDA (ARGPTR),Y
	AND #FILEJC;Test file just created
	BNE RDOPNB;Jump if new file

	;File existed before: set HWM to size

	LDA #RTHWM
	JSR MOVRD3

.RDOPNB
	;Leave address of cache descriptor (hint) to
	;be filled in on first read/write operation
	;** END OF FILE CODE **


	;FIRST MARK HANDLE IN USE (IN USERTB ENTRY)

.RDOPNE
	JSR MHINUS;MARK HANDLE IN USE - IN USERTB ENTRY

	;NOW COPY DETAILS (HANDLE,DISC NO,SIN, ETC.)
	;INTO THE HANDTB (HNDPTR WAS SET BY GETHND)

	LDY #HTHAND
	LDA RNDTMP
	STA (HNDPTR),Y;HANDLE

	LDY #HTMCNO
	LDA MCNUMB
	STA (HNDPTR),Y
	INY ;Y := HTMCNO + 01
	LDA MCNUMB + 1
	STA (HNDPTR),Y
	INY ;Y := HTMCNO + 02
	LDA MCNUMB + 2
	STA (HNDPTR),Y;MACHINE NUMBER

	LDY #ARGE
	LDA (ARGPTR),Y
	LDY #HTACC
	STA (HNDPTR),Y;TYPE & ACCESS

	LDX #INFDIS
	LDY #HTDISC
	LDA #2
	JSR MOVRD2

	LDX #INFSIN
	LDY #HTSIN
	LDA #3
	JSR MOVRD2

	LDY #ARGD
	LDA (ARGPTR),Y
	LDY #HTMODE
	STA (HNDPTR),Y;MODE

	LDA #0;RC := 0

.RDOPNY
	PHA
	LDA RNDTMP;A:=HANDLE
	LDY #ARGB
	STA (ARGPTR),Y
	PLA
	JMP RDEXIT


.MOVRD2
	STX OFF1
	STY OFF2
	LDX #RNDPTR;Move stuff from RNDPTR
	LDY #HNDPTR;To HNDPTR
	JMP MOVBLK


.MOVRD3
	STA OFF2
	LDA #INFSZE;Move size from
	STA OFF1;RNDPTR to RTEPTR (offset already set)
	LDX #RNDPTR
	LDY #RTEPTR
	LDA #3
	JMP MOVBLK
}

	;************ RDINFO ************


	;RDINFO: SEARCH THE HANDTB TO DETERMINE WHETHER
	;A PARTICULAR OBJECT IS OPEN.

	;ENTRY: ARGB = LS(DISC NO)
	;ARGC = MS(DISC NO)
	;ARGD = LS(SIN)
	;ARGE = CS(SIN)
	;ARGF = MS(SIN)

	;EXIT : ARGA = RC (0 => OBJECT OPEN)
	;     : ARGB = MODE OF ACCESS (**28/4/83**)


.RDINFO
{
	JSR INITHD;HNDPTR:=HANDTB,X:=HTENTS
	CLC
	LDA ARGPTR
	ADC #ARGB
	STA MOVFRM
	LDA ARGPTR + 1
	ADC #0
	STA MOVFRM + 1;MOVFRM := ARGPTR + ARGB

.RDINOB
	LDY #HTHAND
	LDA (HNDPTR),Y
	BEQ RDINOL;ENTRY IN USE ??
	CLC
	LDA HNDPTR
	ADC #HTDISC
	STA MOVTO
	LDA HNDPTR + 1
	ADC #0
	STA MOVTO + 1;MOVTO := HNDPTR + HTDISC

	TXA
	PHA ;PUSH X
	LDX #5;COMPARE DISC & SIN
	JSR COMPAR
	TAY
	PLA
	TAX ;PULL X
	TYA
	BEQ RDINOY

.RDINOL
	JSR INCHND
	BNE RDINOB
	LDA #RDERRE;OBJECT NOT OPEN

.RDINOY
	PHA ;save A
	BNE RDINOZ

	LDY #HTMODE
	LDA (HNDPTR),Y;get mode from table
	LDY #ARGB
	STA (ARGPTR),Y;for return
	
	JSR STMCNO;USED BY EXTERR ON ERROR

.RDINOZ
	PLA
	JMP RDEXIT
}


	;************ RDCLOS ************


	;RDCLOS: CLOSE - INVALIDATE A HANDLE

	;ENTRY: ARGB = LS(PTR TO USER INFO)
	;ARGC = MS(PTR TO USER INFO)
	;ARGD = HANDLE

	;EXIT : ARGA = RC


.RDCLOS
{
	JSR INITRD;SETUP GENPTR & MCNUMB
	LDY #ARGD
	LDA (ARGPTR),Y;A := HANDLE
	BNE RDCON
	LDA #RDERRB;BAD HANDLE
	BNE RDCLSY

.RDCON

	STA RNDTMP;RNDTMP := HANDLE
	JSR FNDHND;SEARCH HANDTB FOR THE HANDLE
	BNE RDCLSY


	;NOW CLEAR HANDTB (RANDTB) ENTRY
	;and mark handle free in USERTB

	JSR CLRHTE

.RDCLSY
	JMP RDEXIT
}


	;************ RDREST ************


	;RDREST: RESTART
	;CREATE BOTH HANDTB & RANDTB.
	;THE VARIABLES HANDTB & RANDTB ARE INITIALISED
	;TO POINT TO THE FIRST ENTRY OF BOTH
	;TABLES.

	;NOTE - HANDLE TABLE HAS 6*USERS ENTRIES,
	;AND RAND TABLE 5*USERS ENTRIES.


.RDREST
{
	LDA USERS;First create handle table
	LDX #5
	CLC
.N30
	ADC USERS
	BCS N40
	DEX
	BNE N30
	BEQ N10
.N40
	LDA #&FF
.N10
	CMP #9
	BCS N20
	LDA #9
.N20
	PHA
	STA HTENTS
	TAX
	LDY #HTENSZ
	JSR SETTAB;SET HANDLE TABLE
	STY HANDTB
	STX HANDTB + 1

	PLA
	SEC
	SBC USERS
	STA RTNENT;Store no. of RT entries
	TAX
	LDY #RTENSZ
	JSR SETTAB
	STY RANDTB
	STX RANDTB + 1
	LDA #0
	JMP RDEXIT
}



	;************ RDCOPY ************


	;RDCOPY: CREATE ANOTHER HANDLE FOR AN OBJECT
	;(OOF TYPE DIR).  N.B. RNDMAN.RDCOPY IS
	;USED BY USRMAN WHEN SELECTING A USER'S UFD.

	;ENTRY: ARGB = LS(PTR TO USERINFO)
	;AFGC = MS(PTR TO USERINFO)
	;ARGD = HANDLE (FOR A DIR)

	;EXIT : ARGA = RC
	;ARGE = NEW HANDLE


.RDCOPY
{
	JSR INITRD;SETUP GENPTR & MCNUMB
	LDY #ARGD
	LDA (ARGPTR),Y
	JSR FNDHND
	BNE RDCPYY
	LDA HNDPTR
	STA MOVFRM
	LDA HNDPTR + 1
	STA MOVFRM + 1;MOVFRM := PTR TO HANDTB ENTRY
	LDY #HTACC
	LDA (HNDPTR),Y
	AND #TYPDIR;IS HANDLE FOR A DIR?
	BNE RDCPYC
	LDA #RDERRF;RDCOPY ONLY AVAILABLE FOR DIRECTORIES
	JSR INTERR
.RDCPYC
	JSR GETHND;HNDPTR:=PTR TO FREE HANDTB ENTRY
	BNE RDCPYY
	JSR MHINUS;MARK THE HANDLE IN USE IN USERTB
	LDA HNDPTR
	STA MOVTO
	LDA HNDPTR + 1
	STA MOVTO + 1
	LDX #HTENSZ
	JSR MOVE;COPY OBJECT DETAILS INTO NEW USERTB ENTRY
	LDY #ARGE
	LDA RNDTMP;A := HANDLE TO BE USED (SETBY GETHND)
	STA (ARGPTR),Y
	LDY #HTHAND
	STA (HNDPTR),Y;PUT NEW HANDLE IN HANDTB ENTRY
	LDA #0;RC:=0
.RDCPYY
	JMP RDEXIT
}



	;************ RDCLEAR ALL *************


	;RDCLAL: DELETE ALL HANDLES BELONGING
	;TO A MACHINE.

	;ENTRY: ARGB = LS(PTR TO USERINFO)
	;ARGC = MS(PTR TO USERINFO)

	;EXIT: ARGA = RETURN CODE


.RDCLAL
{
	JSR INITRD;SET GENPTR/MCNUMB/RDUPTR
	JSR INITHD;SET HNDPTR

.RDCALA
	LDY #HTMCNO;M/C NUMBER
	LDA (HNDPTR),Y
	CMP MCNUMB
	BNE RDCALB
	INY
	LDA (HNDPTR),Y
	CMP MCNUMB + 1
	BNE RDCALB
	INY
	LDA (HNDPTR),Y
	CMP MCNUMB + 2
	BNE RDCALB

	;FOUND, SO DELETE

	LDA RDUPTR
	STA GENPTR
	LDA RDUPTR + 1
	STA GENPTR + 1;Ensure GENPTR pointing to right place

	TXA ;SAVE X			;MM WHY?
	PHA
	JSR CLRHTE;CLEAR TABLE ENTRY

	TAX
	PLA ;tidy up stack
	TXA ;**** 17/3/83 ****
	BNE RDCAEX;exit here

.RDCALB
	JSR INCHND;INC. PTR
	BNE RDCALA;(X DEC'D IN INCHND)

	LDA #0
.RDCAEX
	JMP RDEXIT
}



	;GETHND: CHOOSE A HANDLE & A SLOT IN THE HANDTB
	;WHICH ARE FREE.
	;NOTE THAT EACH MACHINE CAN HAVE UPTO 8 HANDLES.
	;THE HANDLES CURRENTLY BEING USED BY A
	;PARTICULAR MACHINE ARE RECORDED IN THE USERTB.

	;ENTRY: GENPTR = PTR TO USER INFO

	;EXIT : A = RC
	;HNDPTR = POINTER TO A FREE HANDTB ENTRY
	;RNDTMP = HANDLE TO BE USED


.GETHND
{
	LDY #UTHNDB;HANDLE BYTE HELD IN USERTB
	LDA (GENPTR),Y

	;FIRST SEE IF THIS MACHINE HAS A FREE HANDLE

	CMP #&FF
	BNE GETHDC
	LDA #RDERRC;HANDLE QUOTA EXHAUSTED
	RTS
.GETHDC
	LDY #1
	STY RNDTMP
.GETHDD
	LSR A
	BCC GETHDF;FOUND A FREE HANDLE
	ASL RNDTMP
	JMP GETHDD

	;NOW SEE IF THERE IS A FREE SLOT IN HANDTB

.GETHDF
	JSR INITHD;HNDPTR := HANDTB
	LDY #HTHAND
.GETHDM
	LDA (HNDPTR),Y
	BEQ GETHDZ
	JSR INCHND
	BNE GETHDM
	LDA #RDERRD;HANDTB FULL

.GETHDZ
	RTS
}


.INITRD
	LDY #ARGB;INIT GENPTR,MCNUMB,RNDPTR
	LDA (ARGPTR),Y
	STA GENPTR
	STA RDUPTR;Store extra copy of user pointer INY
	INY
	LDA (ARGPTR),Y;(used by RDCLAL and RDCLAF)
	STA GENPTR + 1;GENPTR := PTR TO USERINFO
	STA RDUPTR + 1;Extra copy high byte

	LDY #UTMCNO
	LDA (GENPTR),Y
	STA MCNUMB
	INY
	LDA (GENPTR),Y
	STA MCNUMB + 1
	INY
	LDA (GENPTR),Y
	STA MCNUMB + 2;MCNUMB INITIALISED

	LDY #ARGF
	LDA (ARGPTR),Y
	STA RNDPTR
	INY
	LDA (ARGPTR),Y
	STA RNDPTR + 1;RNDPTR := PTR TO OBJECT INFO(SEE DIRMAN.RETR)
	RTS


.MHINUS
	LDY #UTHNDB;MARK A HANDLE IN USE IN USERTB
	LDA RNDTMP;A:=HANDLE (SEE GETHND)
	ORA (GENPTR),Y
	STA (GENPTR),Y
	RTS


	;Mark handle free in USERTB
	;GENPTR points at USERTB entry
	;A      contains handle

.MHFREE
	LDY #UTHNDB;Mark handle free in USERTB
	EOR #&FF;Invert handle in A
	AND (GENPTR),Y;Clear handle bit
	STA (GENPTR),Y;Put back in USERTB
	RTS



.CLRHTE;CLRHTE
{
	;CLEAR HANDLE TABLE ENTRY POINTED TO
	;BY HNDPTR. IF ENTRY IS FOR A FILE,
	;CLEAR CORRESPONDING RANDOM TABLE ENTRY.
	;The handle bit in the USERTB entry
	;(pointed to by GENPTR) is cleared.

	LDY #HTHAND;Get handle in A
	LDA (HNDPTR),Y
	JSR MHFREE;Mark handle free in USERTB

	LDY #HTACC
	LDA (HNDPTR),Y
	AND #TYPE
	CMP #TYPDIR
	BEQ CLRHTA
	JSR RDFLSH;Flush object from cache
	BNE CLRHTX;**** 17/3/83 ****
	JSR RDSFSZ;Set size from HWM
	JSR CLRRTE;Clear RANDTB entry

.CLRHTA
	LDY #HTENSZ -1;X := SIZE OF HANDTB ENTRY
	LDA #0
.RDCLSD
	STA (HNDPTR),Y
	DEY
	BPL RDCLSD
	TAY
.*CLRHTX
	RTS
}


	;*** RDSFSZ ***

	;If the file is open for update, then set
	;its size to the HWM recorded in RANDTB.

	;Entry: HNDPTR points to HANDTB entry for file

	;Exit:  RC in A

.RDSFSZ
{
	LDY #HTMODE;Get mode in which open
	LDA (HNDPTR),Y
	AND #WRITAC;Open for writing ?
	BEQ CLRHTX;No

	JSR SETRPT;Set RTEPTR
	LDY #RTHWM
	LDA (RTEPTR),Y;HWM LS
	STA NEWFSZ
	INY
	LDA (RTEPTR),Y;HWM CS
	STA NEWFSZ + 1
	INY
	LDA (RTEPTR),Y;HWM MS
	STA NEWFSZ + 2

	JMP RDCHSZ;Change size and exit
}

;.LNK
;RMAN02
;
