;.OPT
;UADE13;> Uade13
;.TTL
;Fileserver file UADE13

.UADE13

	;FNDMAP:
	;SEARCHES MAPTB LOOKING FOR DISC NUMBER
	;WHICH IS IN ARGB AND ARGC. WHEN
	;FOUND LEAVES A POINTER TO THE CORRECT ENTRY IN MAPPTR & MAPENT.
	;NOTE THAT MAPENT IS USED BY DSCMAN & SHOULD
	;NOT BE ALTERED BY MAPMAN.

.FNDMAP
{
	LDA #0
	STA MPDRVE
	STA DRIVNO
	LDA MAPTB;START OF MAP TABLE
	STA MAPPTR;LOOK AT FIRST ENTRY
	LDA MAPTB+1
	STA MAPPTR+1
	LDX #0;X HOLDS DRIVE NUMBER
.MPNXDR
	LDY #MPDCNO;OFFSET TO DISC NUMBER
	LDA (MAPPTR),Y
	LDY #ARGB
	CMP (ARGPTR),Y;SEE IF ITS CORRECT DISC NUMBER
	BNE MPTONX
	LDY #MPDCNO+1
	LDA (MAPPTR),Y
	LDY #ARGC
	CMP (ARGPTR),Y
	BEQ MPFND;BRANCH IF DISC NUMBER MATCHES
.MPTONX
	INC MPDRVE
	JSR MPADMP;GET NEXT ENTRY
	INC DRIVNO
	LDA DRIVNO
	CMP DRIVES;CHECK FOR END
	BNE MPNXDR;BRANCH IF NOT AT END
	;IF WE REACH HERE THE DISC WAS NOT FOUND
	LDA #MPERRA
	RTS
.MPFND
	LDY #MPNOCY
	LDA (MAPPTR),Y
	INY
	ORA (MAPPTR),Y
	BEQ MPTONX;IF NO. OF CYLINDERS == 0

	LDA MAPPTR
	STA MAPENT
	LDA MAPPTR+1
	STA MAPENT+1;MAPENT := PTR TO MAPTB ENTRY
	LDA #0;SUCESSFUL SO ZERO RC
	RTS
}

	;CHECK MAP SIZE
	;
	;CHECKS THAT NEW CYLINDER MAP SIZE IS NOT GREATER THAN OLD
	;
	;SECTOR TWO INFO POINTED TO BY MPSCPT,
	;MAP TABLE ENTRY BY MAPPTR
	;
.CHMPSZ
{
	LDY #MPNOCY+1
	LDA MAPTBF,Y
	PHA
	DEY
	LDA MAPTBF,Y
	PHA ;GET OLD NUMBER OF CYLINDERS
	LDY #MPNOCY;SECTOR TWO NO. CYLINDERS
	PLA
	CMP (MAPPTR),Y
	PLA
	INY
	SBC (MAPPTR),Y
	
	LDA #0
	BCS CHMPOK;OLD MAP >= NEW MAP

	LDA #MPERRI
.CHMPOK
	RTS
}

	;
	;
	;FIND SIZE OF NEW MAP AND SAVE IT
	;
	;
.MPMPSZ
{
	LDY #MPSECS;NO. OF SECTORS ON DISC
	LDA (MAPPTR),Y
	STA MPTMPC;SAVE IT
	INY
	LDA (MAPPTR),Y
	STA MPTMPC+1
	INY
	LDA (MAPPTR),Y
	STA MPTMPC+2
	LDA #0
	STA MPTMPA
	STA MPTMPA+1
	STA MPTMPA+2
	LDY #MPDSCS
	LDA (MAPPTR),Y
	TAX
.MPRECN
	CLC
	LDA MPTMPA
	ADC MPTMPC
	STA MPTMPA
	LDA MPTMPA+1
	ADC MPTMPC+1
	STA MPTMPA+1
	LDA MPTMPA+2
	ADC MPTMPC+2
	STA MPTMPA+2
	DEX
	BNE MPRECN
	LDY #MPSCTT
	LDA MPTMPA
	STA (MAPPTR),Y
	INY
	LDA MPTMPA+1
	STA (MAPPTR),Y
	INY
	LDA MPTMPA+2
	STA (MAPPTR),Y
	RTS
}
	;
	;DELETE THE RELEVANT OBJECT
	;
.MPDLTE
	LDY #ARGD;GET SIN
	LDA (ARGPTR),Y
	STA MPTMPA
	INY
	LDA (ARGPTR),Y
	STA MPTMPA+1
	INY
	LDA (ARGPTR),Y
	STA MPTMPA+2
	
	LDA #LO(MBENTS);GET OFFSET TO START
	STA MPSCPT
	LDA #HI(MBENTS)
	STA MPSCPT+1
	LDA #1
	STA MPTMPE
	STA SAVSC;STOP EXTRA WORK
	JMP CLRBLK;REMOVE ALL ENTRIES
	
	;
	;INCREMENT MAPPTR TO NEXT MAPTB ENTRY
	;
.MPADMP
{
	CLC
	LDA #MPTBSZ
	ADC MAPPTR
	STA MAPPTR
	BCC MPAPZ
	INC MAPPTR+1
.MPAPZ
	RTS
}

.DIVIDE
	JSR DVDE;CONVERT TO OLD DIVIDE
	SEC
	LDA DIVTMP
	SBC #1
	STA DIVPAR
	LDA DIVTMP+1
	SBC #0
	STA DIVPAR+1
	LDA DIVTMP+2
	SBC #0
	STA DIVPAR+2
	RTS

.INAMPT
{
	;ADD NAME TABLE ENTRY LENGTH TO
	;DNMPTR.

	CLC
	LDA #NTENSZ
	ADC DNMPTR
	STA DNMPTR
	BCC INAMPZ
	INC DNMPTR+1
.INAMPZ
.*DIVND
	RTS
}


	;DIVIDE SECTORS
	;
	;  CALCULATES A CYLINDER NUMBER FROM A SIN
	;
	;ON ENTRY
	;      MPTMPA HOLDS THE SIN
	;
	;ON EXIT
	;      MPTMPB HOLDS THE CYLINDER
	;
	;USES MPTMPA
	;
.DIVSEC
{
	LDA #0
	STA MPTMPB
	STA MPTMPB+1;CLEAR VARIABLE
.DIVNXS
	LDY #MPSPCY
	SEC
	LDA MPTMPA
	SBC (MAPPTR),Y;DIVIDE BY SECTORS PER CYLINDER
	STA MPTMPA
	INY
	LDA MPTMPA+1
	SBC (MAPPTR),Y
	STA MPTMPA+1
	LDA MPTMPA+2
	SBC #0
	STA MPTMPA+2
	BCC DIVND
	INC MPTMPB
	BNE DIVNXS
	INC MPTMPB+1
	JMP DIVNXS
}

.SDSCNM;SDSCNM
{
	;TAKE TEXT DISC NAME FROM DNMBUF
	;AND PUT IN NAME TABLE ENTRY AT
	;DNMPTR. ALSO PUT IN NEW DISC NUMBER
	;FROM NXTDNO, AND MARK ENTRY IN USE.
	;DISC NO. ALSO PLACED IN MAP TABLE ENTRY
	;POINTED TO BY MAPPTR.

	;ALSO INCREMENT NXTDNO !!

	LDY #NTNAME
	LDX #0

.SDSCLP
	LDA DNMBUF,X
	STA (DNMPTR),Y
	INY
	INX
	CPX #DNAMLN
	BNE SDSCLP

	LDY #NTDNO
	LDA NXTDNO
	PHA
	STA (DNMPTR),Y;SET DISC NO. LO
	INY
	LDA NXTDNO+1
	STA (DNMPTR),Y

	LDY #MPDCNO+1
	STA (MAPPTR),Y;DISC NO. IN MAP TABLE
	DEY
	PLA
	STA (MAPPTR),Y

	LDY #NTUSED
	LDA #USED
	STA (DNMPTR),Y

	INC NXTDNO
	BNE SDSCOK
	INC NXTDNO+1

.SDSCOK
	LDA #0
	RTS
}
	;
	;SET UP CYLINDER MAP FOR CURRENT DISC
	;
.MPSTCY
{
	LDA #1
	STA RSTFLG
	LDY #MPCYMP
	CLC
	LDA (MAPPTR),Y
	ADC #3;TO POINT AT ACTUAL ENTRIES
	STA MPCYPT
	INY
	LDA (MAPPTR),Y
	ADC #0
	STA MPCYPT+1
	LDA #0;ZERO A FEW VALUES
	STA DDRSZE+2
	STA MPTMPC
	STA MPTMPC+1
	STA MPTMPA+2;** 21/11/84 **
.MPSCSL
	LDY #MPSCYL
	LDA MPTMPC
	CMP (MAPPTR),Y
	INY
	LDA MPTMPC+1
	SBC (MAPPTR),Y
	BCS MPSCSF
	LDA #0
	TAY
	STA (MPCYPT),Y
	INY
	STA (MPCYPT),Y
	CLC
	LDA MPCYPT
	ADC #2
	STA MPCYPT
	BCC MPSCSJ
	INC MPCYPT+1
.MPSCSJ
	INC MPTMPC
	BNE MPSCSL
	INC MPTMPC+1
	JMP MPSCSL
.MPSCSF
	STA MPTMPB
	STA MPTMPB+1
	STA MPTMPB+2
.CYMPLP
	LDA #0;LOOP TO READ IN BIT MAPS
	STA MPTMPA
	STA MPTMPA+1

	LDA MPTMPA+2;check not skipping
	BEQ CYMPL1
	DEC MPTMPA+2;counter for maps to skip
	JMP CYMPL2

.CYMPL1
	JSR RDBTMP
	
	LDY #MPSZCY
	LDA (MAPPTR),Y
	BNE CYML1A;COMPRESSED MAP

	LDY #MPVAL;check that subsequent maps are valid
	LDA (MPSCPT),Y;** 21/11/84 **
	STA MPTMPA+2;save this flag [n<>0 => skip n maps]

.CYML1A
	LDY #MPSPCY
	LDA (MAPPTR),Y
	STA MAPTMP
	INY
	LDA (MAPPTR),Y
	STA MAPTMP+1;SECTORS PER CYCLINDER
.CRCLP1
	LDX #8;EIGHT BITS PER BYTE
	LDY #0
	LDA (MPSCPT),Y
.CRCYLP
	ROR A;CHECK IF SECTOR FREE
	BCC CRCYSK;CLEAR IF ALLOCATED
	INC MPTMPA;COUNT OF FREE SECTORS
	BNE CRCYSK
	INC MPTMPA+1
.CRCYSK
	PHA
	LDA MAPTMP
	BNE CRCYSJ
	DEC MAPTMP+1
.CRCYSJ
	DEC MAPTMP
	LDA MAPTMP+1
	ORA MAPTMP
	BEQ CRCFND;BRANCH IF END OF MAP
	PLA
	DEX ;FOR END OF BYTE
	BNE CRCYLP
	INC MPSCPT;INCREMENT POINTER TO BIT MAP
	BNE CRCLP1
	INC MPSCPT+1
	JMP CRCLP1;TO LOOK AT NEXT BIT
.CRCFND
	PLA ;REMOVE SAVED REG.
.CYMPL2
	LDA MPTMPA
	STA (MPCYPT),Y;SAVE COUNT OF FREE SECTORS
	CLC
	ADC MPTMPB;SAVE TOTAL
	STA MPTMPB
	INY
	LDA MPTMPA+1
	STA (MPCYPT),Y
	ADC MPTMPB+1
	STA MPTMPB+1
	BCC CYML2A
	INC MPTMPB+2
.CYML2A
	CLC ;MOVE POINTER TO NEXT ENTRY
	LDA MPCYPT
	ADC #2
	STA MPCYPT
	BCC CYML2B
	INC MPCYPT+1
.CYML2B
	INC MPTMPC
	BNE MPRES9
	INC MPTMPC+1
.MPRES9
	LDY #MPNOCY;CHECK FOR END OF DISC
	LDA MPTMPC
	CMP (MAPPTR),Y
	INY
	LDA MPTMPC+1
	SBC (MAPPTR),Y
	BCS MPRES3
	JMP CYMPLP
.MPRES3
	LDY #MPCYMP;END OF MAPS SO SAVE TOTAL COUNT
	LDA (MAPPTR),Y
	STA MPSCPT
	INY
	LDA (MAPPTR),Y
	STA MPSCPT+1
	LDY #0
	LDA MPTMPB
	STA (MPSCPT),Y
	INY
	LDA MPTMPB+1
	STA (MPSCPT),Y
	INY
	LDA MPTMPB+2
	STA (MPSCPT),Y
	LDA #0
	STA RSTFLG
	RTS
}

	;FIND SIZE OF OBJECT
	;
	;ON ENTRY
	;     MPMBPT POINTS TO MAP BLOCK
	;
	;ON EXIT
	;     MPTMPA HOLDS NUMBER OF BYTES
	;     MPTMPD HOLDS NUMBER OF BLOCKS
	;
	;
.MPGTSZ
{
	LDA #0
	STA MPTMPD
	STA MPTMPD+1
	STA MPTMPD+2;ZERO BLOCK COUNT
.MPGSMB
	LDA #LO(MBENTS)
	STA MPTMPB
	LDA #HI(MBENTS)
	STA MPTMPB+1;OFFSET
.MPGTLP;ADD UP NEXT ENTRY
	CLC
	LDA MPMBPT
	ADC MPTMPB
	STA MPSCPT
	LDA MPMBPT+1
	ADC MPTMPB+1
	STA MPSCPT+1
	LDY #0
	LDA (MPSCPT),Y
	INY
	ORA (MPSCPT),Y
	INY
	ORA (MPSCPT),Y
	BEQ MPGSGB
	LDA MPTMPB
	CMP #LO(LSTENT)
	LDA MPTMPB+1
	SBC #HI(LSTENT)
	BCS MPGSNX
	LDY #3
	CLC
	LDA MPTMPD
	ADC (MPSCPT),Y
	STA MPTMPD
	INY
	LDA MPTMPD+1
	ADC (MPSCPT),Y
	STA MPTMPD+1
	BCC MPGSSK
	INC MPTMPD+2
.MPGSSK
	CLC
	LDA MPTMPB
	ADC #ENSZ
	STA MPTMPB
	BCC MPGTLP
	INC MPTMPB+1
	BCS MPGTLP;ALWAYS
.MPGSNX;GET NEXT MAP BLOCK
	LDY #0
	LDA (MPSCPT),Y
	STA MPTMPA
	INY
	LDA (MPSCPT),Y
	STA MPTMPA+1
	INY
	LDA (MPSCPT),Y
	STA MPTMPA+2
	CLC
	JSR RDMPBK
	BEQ MPGSS2
.MPGSND
	LDA #MPERRC
	RTS
.MPGSS2
	LDA MAPTMP
	STA MPMBPT
	LDA MAPTMP+1
	STA MPMBPT+1
	JMP MPGSMB
.MPGSGB
	JSR RMPBK2
	BNE MPGSND
	LDA MAPTMP
	STA MPMBPT
	LDA MAPTMP+1
	STA MPMBPT+1
	;CALCULATE BYTES FROM BLOCKS
	LDA MPTMPD;NUMBER OF BLOCKS
	STA MPTMPB
	LDA MPTMPD+1
	STA MPTMPB+1
	LDA MPTMPD+2
	STA MPTMPB+2
	LDA #0
	STA MPTMPA;ZERO BYTE COUNT
	STA MPTMPA+1
	STA MPTMPA+2
	LDA MPTMPD
	ORA MPTMPD+1
	ORA MPTMPD+2
	BEQ MPGSSA
.MPGSL1
	LDA MPTMPB
	BNE MPGL1B
	LDA MPTMPB+1
	BNE MPGL1A
	DEC MPTMPB+2
.MPGL1A
	DEC MPTMPB+1
.MPGL1B
	DEC MPTMPB
	LDA MPTMPB+2
	ORA MPTMPB+1
	ORA MPTMPB
	BEQ MPGSFN
	JSR ADDBLK
	JMP MPGSL1

.MPGSFN;GET BYTES IN LAST BLOCK
	LDY #BILB
	LDA (MPMBPT),Y
	INY
	ORA (MPMBPT),Y
	BNE MPGSNZ
	JSR ADDBLK
	JMP MPGSSA
.MPGSNZ
	LDY #BILB
	CLC
	LDA MPTMPA
	ADC (MPMBPT),Y
	STA MPTMPA
	INY
	LDA MPTMPA+1
	ADC (MPMBPT),Y
	STA MPTMPA+1
	BCC MPGSSA
	INC MPTMPA+2
.MPGSSA
	LDA #0
	RTS

	;MPTMPA += BTINBK (BLOCK SIZE)
.ADDBLK
	CLC
	LDA MPTMPA
	ADC #LO(BTINBK)
	STA MPTMPA
	LDA MPTMPA+1
	ADC #HI(BTINBK)
	STA MPTMPA+1
	BCC ADDBLJ
	INC MPTMPA+2
.ADDBLJ
	RTS
}

.CHDNAM;CHDNAM
{
	;LOOK UP DISC NAME IN SECTOR ZERO INFO
	;POINTED TO BY MPSCPT.
	;IF FOUND, AND ENTRY IN USE -> ERROR
	;IF FOUND, ENTRY NOT IN USE, MARK IN USE
	;AND SET MAP TABLE ENTRY DISC NO. FROM TABLE
	;IF NOT FOUND, CHUCK OUT LRU DISC NO. NOT
	;CURRENTLY IN USE, INSERT NEW NAME AND GIVE IT
	;A NEW DISC NUMBER (FROM NXTDNO). MARK ENTRY IN USE.
	;SET DISC NO. IN MAP TABLE

	;ON ENTRY MAPPTR -> MAP TABLE ENTRY



	JSR FNDDSC;EXIT WITH DNMPTR POINTING TO ENTRY
	BNE CHDNAA;NOT FOUND, THROW AN ENTRY OUT

	;IF HERE, DISC FOUND. IF IN USE, THEN ERROR
	;COZ => TWO DISCS OF SAME NAME IN USE
	;ON SAME SYSTEM. IF NOT IN USE, RETURN
	;DISC NUMBER.

	LDY #NTUSED
	LDA (DNMPTR),Y
	BNE CHDNON;NOT IN USE, OK

	LDA #MPERRJ
	RTS;ERROR

.CHDNON
	LDY #NTDNO
	LDA (DNMPTR),Y
	PHA
	INY
	LDA (DNMPTR),Y

	;NOW SET MAP TABLE ENTRY

	LDY #MPDCNO+1
	STA (MAPPTR),Y
	DEY
	PLA
	STA (MAPPTR),Y

	;MARK NAME TABLE ENTRY IN USE

	LDY #NTUSED
	LDA #USED
	STA (DNMPTR),Y

	JMP CHDNOK;FOUND FINISH



.CHDNAA
	JSR LRUDSC

	;NOW DNMPTR => LRU NAME ENTRY

	JSR SDSCNM

.CHDNOK
	LDA #0
	RTS ;EXIT
}

.MOVDNM;MOVDNM
{
	;MOVE DISC NAME FROM SEC. ZERO
	;TO DNMBUF.

	LDX #0
	LDY #MPSZNM
.MDNLPA
	LDA (MPSCPT),Y
	STA DNMBUF,X
	INY
	INX
	CPX #DNAMLN
	BNE MDNLPA
	RTS
}

.FNDDSC;FNDDSC

	;ENTRY: MPSCPT -> SECTOR ZERO INFO, INCLUDING DISC NAME

	;EXIT:  DNMPTR -> NAME TABLE ENTRY IF FOUND
	;Z FLAG SET IF FOUND

	;SIDE EFFECT: DISC NAME MOVED TO DNMBUF

	JSR MOVDNM;MOVE DISC NAME TO DNMBUF

.FNDNAM
{
	LDA NAMETB
	STA DNMPTR
	LDA NAMETB+1
	STA DNMPTR+1;SET P.0 POINTER
	LDA #NTSIZE;NO. OF ENTRIES IN NAMTAB
	STA TEMPA

.FDLPB
	LDY #NTNAME;NAMTAB OFFSET
	LDX #0
.FDLPC
	LDA (DNMPTR),Y
	EOR DNMBUF,X;Compare
	AND #&DF;Force cases
	BNE FDONA
	INX
	INY
	CPX #DNAMLN
	BNE FDLPC

	;IF HERE, NAME FOUND, Z SET.
	RTS

.FDONA
	DEC TEMPA
	BEQ FDONB;SEARCH FINISHED, NOT FOUND
	JSR INAMPT;SET DNMPTR TO POINT TO NEXT ENTRY
	JMP FDLPB;DO NEXT ENTRY

.FDONB
	LDA #MPERRK;UNSET Z FLAG
	RTS ;FINISH
}


.LRUDSC;LRUDSC
{
	;SEARCH NAME TABLE FOR LRU ENTRY

	;ON EXIT DNMPTR -> LRU ENTRY

	LDA NAMETB
	STA GENPTR
	LDA NAMETB+1
	STA GENPTR+1

	LDA #&FF
	STA TEMPA;USED TO KEEP PARTIAL RESULT
	LDX #NTSIZE;NO. OF ENTRIES

.LRUDLP
	LDY #NTUSED;OFFSET OF USE FLAG
	LDA (GENPTR),Y
	BEQ LRUDON;IN USE -> NO GOOD

	CMP TEMPA
	BCS LRUDON;TABLE ENTRY>=TEMPA, CONTINUE

	STA TEMPA;NEW PARTIAL RESULT
	LDA GENPTR
	STA DNMPTR;SET POINTER TO PARTIAL RESULT ENTRY
	LDA GENPTR+1
	STA DNMPTR+1

.LRUDON
	DEX
	BEQ LRUEX;ALL ENTRIES DONE, FINISH

	CLC
	LDA #NTENSZ
	ADC GENPTR
	STA GENPTR
	BCC LRUDLP
	INC GENPTR+1
	BCS LRUDLP;ALWAYS

.LRUEX
	RTS
}


.FNDDNO
{
	;LOOK UP CURDNO IN NAMETABLE.
	;EXIT: NAMTAB -> ENTRY, Z SET IF FOUND

	JSR SDNMPT
	LDX #NTSIZE - 1

.FNDDLP
	LDY #NTDNO
	LDA CURDSC
	CMP (DNMPTR),Y
	BNE FDDON
	INY
	LDA CURDSC+1
	CMP (DNMPTR),Y
	BEQ FDDEX;FOUND, FINISH

.FDDON
	JSR INAMPT;MOVE DNMPTR
	DEX
	BPL FNDDLP

.FDDEX
	RTS
}


.AGENTB
{
	;AGE ALL ENTRIES NOT IN USED IN THE
	;DISC NAME TABLE

	JSR SDNMPT
	LDX #NTSIZE
	LDY #NTUSED
.AGENTL
	LDA (DNMPTR),Y
	BEQ AGENTM;IN USE, DON'T AGE
	SEC
	SBC #1;AGE
	STA (DNMPTR),Y
.AGENTM
	JSR INAMPT
	DEX
	BNE AGENTL
	RTS
}

.SDNMPT
	LDA NAMETB
	STA DNMPTR
	LDA NAMETB+1
	STA DNMPTR+1
	RTS



	;INCREMENT THE SEQUNCE NUMBER

.TAGTAB
	EQUB "AFS0"

.CHKDSC
{
	;CHECK SECTOR ZERO INFO (POINTED TO
	;BY MPSCPT) IS FOR A VALID FS DISC

	LDY #3
.CHKDLP
	LDA TAGTAB,Y
	CMP (MPSCPT),Y
	BNE CHKDER
	DEY
	BPL CHKDLP
	
	INY;Y:=0, DROP THROUGH AND EXIT, Z SET
	RTS
.CHKDER
	LDA #MPERRD
	RTS
}

.SMAPEN

	;MOVE SECTOR ZERO INFO. POINTED TO
	;BY MPSCPT INTO MAP TABLE ENTRY
	;POINTED TO BY MAPPTR

	CLC ;COPY AREA OF STORE
	LDA MAPPTR
	ADC #MPNOCY;MAKE MAPPTR POINT TO START OF AREA
	STA MOVTO
	LDA MAPPTR+1
	ADC #0
	STA MOVTO+1;STORE IN POINTER TO COPY
	CLC
	LDA MPSCPT
	ADC #MPSZNC;TO POINT TO DISC INFO
	STA MOVFRM
	LDA MPSCPT+1
	ADC #0
	STA MOVFRM+1;POINTER FOR MOVING TO
	LDX #MPSZLN
	JMP MOVE;MOVE AND EXIT
	
.ZERDSK
{
	;Zeroes an area of disck. Is a psuedo
	;map management routine.
	;
	;On entry
	;           OLDSZE = Old size in bytes
	;           MPTMPA = SIN of object
	;
	;On exit
	;           Z set if sucessful

	JSR FNDMAP
	BEQ ZDCT
.ZDSZ1
	RTS
.ZDCT
	CLC
	JSR RDMPBK;Requires SIN in MPTMPA
	BNE ZDSZ1
	LDA MAPTMP
	STA MPMBPT
	LDA MAPTMP+1
	STA MPMBPT+1
	LDA OLDSZE
	STA DIVPAR
	LDA OLDSZE+1
	STA DIVPAR+1
	LDA OLDSZE+2
	STA DIVPAR+2
	JSR DVDE
	BCC ZDZ1
	LDA #&F9
	JSR INTERR
.ZDZ1
	LDA #2
	LDY OLDSZE
	BNE ZBS2
	LDA #1
.ZBS2
	STA DIVPAR
	SEC
	LDA DIVTMP
	SBC DIVPAR;START FROM BLOCK ZERO
	STA BREGA
	LDA DIVTMP+1
	SBC #0
	STA BREGA+1
	LDA #&FF
	STA NBLKS
	STA NBLKS+1
	JSR DCENT2
	BEQ ZDZ2
	JMP ZBND
.ZDZ2
	;MAPTMP holds SIN of current disc block
	;MPTMPD holds count of number in this entry
	;Now zero out rest of current block
	LDA MAPTMP
	STA MPTMPA
	LDA MAPTMP+1
	STA MPTMPA+1
	LDA MAPTMP+2
	STA MPTMPA+2
	LDA OLDSZE
	ORA OLDSZE+1
	ORA OLDSZE+2
	BEQ ZCNT
	LDA OLDSZE
	BEQ ZNBK;If all of this block used continue
.ZCNT
	CLC
	JSR RDMPBK;Pretend its map block
	LDA MAPTMP;Ignore possible error
	STA MPCYPT
	LDA MAPTMP+1
	STA MPCYPT+1
	LDY OLDSZE
	LDA #0
.ZLP
	STA (MPCYPT),Y;Zero rest of block
	INY
	BNE ZLP
	JSR SETMB
	JSR CASTWB;Mark block written
	JSR ENSMB;Write it to disc
	JSR SETMB
	JSR FNDBLK;FIND BLOCK TO FLUSH
	LDA #0
	LDY #CAFLG
	STA (GNCBPT),Y

	LDA MPTMPD
	BNE ZLPJ
	DEC MPTMPD+1
.ZLPJ
	DEC MPTMPD
	
	INC MPTMPA
	BNE ZNBK
	INC MPTMPA+1
	BNE ZNBK
	INC MPTMPA+2
.ZNBK
	;Next bit writes 0's to MPTMPD entries until
	;none left.
	JSR SETBM;Use bit maps
	JSR GETFR
	LDY #CBSA
	LDA (GNCBPT),Y
	STA MPCYPT
	INY
	LDA (GNCBPT),Y
	STA MPCYPT+1
	LDY #0
	TYA
.ZSB
	STA (MPCYPT),Y
	INY
	BNE ZSB;Area of store zeroed
	LDA MPCYPT
	STA DCSTAD
	LDA MPCYPT+1
	STA DCSTAD+1
	LDA MPDRVE
	STA DRIVNO
.ZBLP
	LDA MPTMPD
	ORA MPTMPD+1
	BEQ ZBNE
	LDA MPTMPA
	STA RBDA
	LDA MPTMPA+1
	STA RBDA+1
	LDA MPTMPA+2
	STA RBDA+2
	LDA #&A
	STA SAVCOM
	JSR XFER

	LDA MPTMPD
	BNE ZBLPJ
	DEC MPTMPD+1
.ZBLPJ
	DEC MPTMPD
	
	INC MPTMPA
	BNE ZBLP
	INC MPTMPA+1
	BNE ZBLP
	INC MPTMPA+2
	JMP ZBLP
.ZBNE
	JSR NXTEN
	BNE ZBND
	LDA MAPTMP
	STA MPTMPA
	LDA MAPTMP+1
	STA MPTMPA+1
	LDA MAPTMP+2
	STA MPTMPA+2
	JMP ZBLP
.ZBND
	LDA #0
	RTS
}

;.LNK
;MBBMCM
;
