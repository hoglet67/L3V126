;.OPT
;UADE0A;FILE > Uade0A
;.TTL
;Fileserver file UADE0A

.UADE0A

	;**********************************
	;*         S T R M A N            *
	;**********************************





	;STRMAN: THE STORE MANAGER IS RESPONSIBLE
	;FOR MAINTAINING A CACHE OF
	;VARIABLE LENGTH (BUT AN INTEGRAL NUMBER
	;OF DISC BLOCKS) OBJECT WINDOWS.

	;THE CONTENTS OF THE CACHE IS DESCRIBED BY
	;A ONE WAY CHAIN OF DESCRIPTORS.
	;THESE DESCRIPTORS ARE KEPT IN AN ORDER WHICH
	;DESCRIBES THE POSITION OF THE WINDOWS IN MEMORY.
	;NOTE THAT EACH OBJECT IN THE CACHE
	;IS PRECEEDED BY A ONE BYTE DIRTY MARKER.





;********* MAIN ROUTINE *********


.STRMAN
{
	LDX #9;STRMAN HAS 9 ENTRY POINTS
	LDA #MODSTR;A:=NAME OF THIS MODULE
	JSR ENTRY
	LDA STRTNS,X
	STA STJUMP + 1
	LDA STRTNS + 1,X
	STA STJUMP + 2
	LDA #&F
	JSR SETFS;SET FRAME SIZE
.STJUMP
	JMP STJUMP
.STRTNS
	EQUW STDTSA;1 => DISC ADDRESS TO STORE ADDRESS
	EQUW STENWD;2 => ENSURE WINDOW
	EQUW STULWD;3 => UNLOCK CACHED WINDOW
	EQUW STFLWD;4 => FLUSH WINDOW
	EQUW STRALL;5 => REMOVE ALL BLOCKS OF AN OBJECT FROM CACHE
	EQUW STREST;6 => RESTART
	EQUW STGBB;7 => GET BIG BUFFER
	EQUW STEMPT;8 => EMPTY THE CACHE OF ALL OBJECTS FROM A DISC
	EQUW STRDRT;9 => REMOVE ALL DIRTY BLOCKS OF AN OBJECT
}
.STEXIT
	JMP EXIT




;************ STDTSA ************



	;STDTSA:   DISC ADDRESS TO STORE ADDRESS

	;ENTRY: ARGB = LS(DISC NUMBER)
	;ARGC = MS(DISC NUMBER)
	;ARGD = LS(SIN)
	;ARGE = CS(SIN)
	;ARGF = MS(SIN)
	;ARGG = LS(LOGICAL BLOCK NUMBER)
	;ARGH = MS(LOGICAL BLOCK NUMBER)
	;ARGI = LS(NO OF BLOCKS)
	;ARGJ = MS(NO OF BLOCKS)

	;EXIT:  ARGA = RC
	;ARGB = LS(STORE ADDRESS)
	;ARGC = MS(STORE ADDRESS)
	;ARGD = LS(STORE ADDR OF CACHE DESCR)
	;ARGE = MS(STORE ADDR OF CACHE DESCR)


	;FUNCTION: THE CACHE IS SEARCHED TO SEE IF
	;THE SPECIFIED WINDOW IS IN MEMORY.
	;IF IT IS NOT IN THE CACHE THEN IT
	;HAS TO BE READ FROM DISC.
	;WHEN THE WINDOW IS IN THE CACHE
	;THE ENTRY'S REFERNCE COUNT IS INCREMENTED
	;AND ITS AGE SET TO MRU.
	;NOTE IF THE WINDOW IS NOT FOUND
	;IN THE CACHE IT IS NECESSARY TO
	;FIND A STORE BUFFER INTO WHICH
	;IT MAY BE READ FROM DISC-THIS CAN
	;INVOLVE ONE, OR MORE, OLD WINDOWS
	;BEING WRITTEN OUT TO CREATE SPACE.

	;IF WINDOW IN CACHE
	;THEN AGE OF BLOCK := MRU;
	;REFERENCE COUNT OF WINDOW +:= 1
	;ELSE GET A FREE STORE BUFFER; #THIS IS A LITTLE INVOLVED#
	;READ OBJECT FROM DISC;
	;AGE OF OBJECT := MRU;
	;REFERENCE COUNT OF WINDOW := 1
	;FI



.STDTSA
{
	JSR TSTSIN
	BNE STDTAB
	JSR INSRCH;INIT PREV,CRNT,CMPPTR
.STDTAC
	LDX #9
	JSR COMP;COMPARE DISC NO,SIN,BLK NO,NO OF BLOCKS
	BNE STDTAG

	;ITS IN THE CACHE

	JSR INCCNT;REF COUNT +:= 1
	LDY #CEAGE
	LDA #MRU;MARK IT MRU
	STA (CRNT),Y
	JSR RETSTA;RETURN STORE ADDR & ADDR OF CRNT DESCR
	LDA #0
	
.STDTAB
	JMP STDTAY

.STDTAG
	JSR NXTCRN;CRNT:=NEXT OF CRNT
	BNE STDTAC

	;ITS NOT IN THE CACHE SO GET SOME FREE SPACE
	;AND HAVE THE OBJECT READIN.

	LDY #ARGI
	LDA (ARGPTR),Y
	STA BREGA
	INY
	LDA (ARGPTR),Y
	STA BREGA + 1
	LDA #0
	STA BREGA + 2
	JSR MULTBS;BREGA *:=BLKSZE
	LDA BREGA + 2
	BEQ STDTAH
	LDA #STERRE;SIZE TO BIG
	BNE STDTAY

.STDTAH
	LDA BREGA
	STA AMTNED
	LDA BREGA + 1
	STA AMTNED + 1;AMTNED := BREGA
	JSR FREEST;GET AMTNED WORTH OF FREE STORE
	BNE STDTAY

	;AT THIS POINT CRNT PTS TO A CACHE ENTRY
	;DESCRIPTOR. NOW COPY DISC NO, SIN,
	;BLKNO, NO OF BLOCKS INTO CRNT.

	CLC
	LDA ARGPTR
	ADC #ARGB
	STA MOVFRM
	LDA ARGPTR + 1
	ADC #0
	STA MOVFRM + 1;MOVFRM := ARGPTR + ARGB
	LDA CRNT
	STA MOVTO
	LDA CRNT + 1
	STA MOVTO + 1
	LDX #9
	JSR MOVE

	;READ OBJECT FROM DISC & INITIALISE REF COUNT & AGE

	JSR RETSTA;PUT STORE ADDR ON ARGPTR STACK
	JSR READ;READ OBJECT FROM DISC
	BEQ STDTAX
	PHA ;Store return code
	LDY #CERCNT
	LDA #0
	STA (CRNT),Y;Make sure ref. count = 0
	PLA ;return code stored over REMVIT
	JSR REMVIT
	BNE STDTAY
.STDTAX
	LDY #CERCNT
	LDA #1
	STA (CRNT),Y;REF COUNT := 1
	LDY #CEAGE
	LDA #MRU
	STA (CRNT),Y;AGE := MRU
	LDA #0;RC := 0
.STDTAY
	JMP STEXIT
}


	;************ STENWD ************


	;STENWD: ENSURE WINDOW. THIS ENSURES THAT A GIVEN
	;WINDOW IS UPTO DATE ON DISC.

	;ENTRY: ARGB = LS(WINDOW STORE ADDRESS)
	;ARGC = MS(WINDOW STORE ADDRESS)
	;ARGD = 0 => DON'T DECREMENT REF COUNT
	;<> 0 => DECREMENT REF COUNT

	;EXIT : ARGA = RC

	;FUNCTION: 1) SEARCH CACHTB FOR ENTRY
	;2) IF DIRTY WRITE TO DISC & MARK IT CLEAN
	;3) DECREMENT ITS REFERENCE COUNT IF NEED BE



.STENWD
{
	JSR FNDSTA
	BEQ STENWB
	JSR INTERR
.STENWB
	JSR ENSURE;ENSURE WINDOW UPTO DATE ON DISC
	PHA
	LDY #ARGD
	LDA (ARGPTR),Y;IS USE COUNT TO BE DECREMENTED
	BEQ STENDD
	JSR DECCNT
.STENDD
	PLA
	BEQ STENWY;skip if all ok
	JSR REMVIT;else remove the object from the cache
.STENWY
	JMP STEXIT;RC preserved
}



	;************ STULWD ************


	;STULWD: UNLOCK BUFFER. THIS FUNCTION DECREMENTS
	;A STORE BUFFER'S REFERENCE COUNT.

	;ENTRY: ARGB = LS(BUFFER STORE ADDRESS)
	;ARGC = MS(BUFFER STORE ADDRESS)

	;EXIT : ARGA = RC

	;FUNCTION: 1) SEARCH THE CACHE FOR SPECIFIED BUFFER.
	;2) DECREMENT THE BUFFER'S REFERENCE COUNT.

	;NOTE THIS OPERATION WILL NOT WRITE THE BLOCK
	;TO DISC EVEN IF IT IS MARKED DIRTY.


.STULWD
{
	JSR FNDSTA
	BEQ STULWX
	JSR INTERR
.STULWX
	JSR DECCNT
	LDA #0
	JMP STEXIT
}


	;************ STFLWD ************


	;STFLWD:FLUSH WINDOW. THIS FUNCTION INFORMS
	;STRMAN THAT A STORE BUFFER WILL PROBABLY NOT
	;BE NEEDED IN THE NEAR FUTURE.

	;ENTRY: ARGB = LS(BUFFER STORE ADDRESS)
	;ARGC = MS(BUFFER STORE ADDRESS)

	;EXIT : ARGA = RC

	;FUNCTION: 1) SEARCH CACHTB FOR THE BUFFER
	;AND THEN DECREMENT ITS REFERENCE COUNT
	;2) IF BUFFER MARKED 'DIRTY'
	;THEN WRITE IT TO DISC
	;3) AGE OF BUFFER := LRU (I.E. VERY OLD)
	;4) IF REFCOUNT=0 THEN REMOVE OBJ FROM CACHE


.STFLWD
{
	JSR FNDSTA
	BEQ STFLBD
	JSR INTERR
.STFLBD
	JSR ENSURE
	PHA
	JSR DECCNT
	LDY #CEAGE
	LDA #LRU
	STA (CRNT),Y
	JSR TSTCNT
	BNE STFLBX
	JSR REMVIT
.STFLBX
	PLA ;RC from ENSURE
	JMP STEXIT
}


	;************ STRALL ************


	;STRALL: REMOVES ALL THE BLOCKS, BELONGING TO
	;A SPECIFIED FILE, FROM THE CACHE.
	;NOTE IT IS ASSUMED THAT STEPS ARE TAKEN,
	;BEFORE STRALL IS CALLED, TO
	;AVOID BLOCKS OF THE FILE BEING LOADED.


	;ENTRY: ARGB = LS(DISC NUMBER)
	;ARGC = MS(DISC NUMBER)
	;ARGD = LS(SIN)
	;ARGE = CS(SIN)
	;ARGF = MS(SIN)

	;EXIT : ARGA = RC

	;FUNCTION: 1) SCAN THE CACHTB REMOVING ALL THE
	;WINDOWS BELONGING TO THIS FILE.
	;2) THE WINDOWS MARKED DIRTY ARE WRITTEN TO DISC.
	;3) THE WINDOWS ARE THEN REMOVED FROM
	;THE CACHE.


.STRALL
{
	JSR TSTSIN
	BNE STRALY

	LDX #5;COMPARE DISC NUMBER & SIN
	JSR EXPELL;REMOVE ALL OBJECTS WITH GIVEN DISC NO & SIN

.STRALY
	JMP STEXIT
}

	;************ STREST ************


	;STREST: RESTART
	;1)GETVEC SPACE FOR
	;a)THE BIG BUFFER
	;b)FIRST CACHE ENTRY DESCRIPTOR & MAKE
	;CACHTB PT TO IT.
	;c)NUMBCE+1 CACHE ENTRY DESCRIPTORS & PUT
	;THEM ON THE FREE CHAIN (FRECHN).
	;d)THE CACHE ITSELF (CACHSZ BYTES)




.STREST
{
	LDY #LO(LGBFSZ);Y:=LS(SIZE OF BIG BUFFER)
	LDX #HI(LGBFSZ );X:=MS(SIZE OF BIG BUFFER)
	JSR GETVEC;Get big buffer
	STY BIGBUF
	STX BIGBUF + 1;BIGBUF:=ADDR OF BIG BUFFER

	;CREATE THE FIRST CACHE DESCRIPTOR (CACHTB)

	JSR CRDESC
	LDA CRNT
	STA CACHTB
	LDA CRNT + 1
	STA CACHTB + 1;CACHTB := ADDR OF DESC. FOR 1ST ENTRY

	;NOW CALCULATE NO. OF CACHE DESCRIPTORS
	;AND CACHE SIZE.

	;CACHSZ := ENDPTR-FREPTR
	;CACHSZ -:= (DESC. SIZE) * 2
	;NO. OF OBJECTS := CACHSZ / (OBJECT SIZE+DESC. SIZE)
	;CACHSZ -:= DESC.SIZE*NO. OF OBJECTS


	LDA #CESIZE
	ROL A
	STA TEMPA;TEMPA := DESC. SIZE * 2
	SEC
	LDA ENDPTR
	SBC FREPTR
	SBC TEMPA
	STA DIVPAR
	STA CACHSZ
	LDA ENDPTR + 1
	SBC FREPTR + 1
	STA DIVPAR + 1
	STA CACHSZ + 1

	LDX #0
.STRSTF
	SEC
	LDA DIVPAR
	SBC #CESIZE;(Object size + desc. size) lo
	STA DIVPAR
	LDA DIVPAR + 1
	SBC #1;(Object size + desc. size) hi
	STA DIVPAR + 1
	BCC STRSTE
	INX
	ORA DIVPAR
	BEQ STRSTE
	BCS STRSTF
.STRSTE
	STX NUMBCE;No. of cache objects :
.STRLPX
	SEC ;NOW SUBTRACT C.D. SIZE, NUMBCE TIMES
	LDA CACHSZ
	SBC #CESIZE
	STA CACHSZ
	BCS STRSTG
	DEC CACHSZ + 1
.STRSTG
	DEX
	BNE STRLPX

	JSR VSTRIN
	EQUB CR,"Cache size - "
	NOP

	LDA CACHSZ + 1
	JSR WHEX
	LDA CACHSZ
	JSR WHEX

	JSR VSTRIN
	EQUB " objects - "
	NOP

	LDA NUMBCE
	JSR WHEX
	JSR OSCRLF


	;NOW CREATE (NUMBCE+1) DESCRIPTORS & PLACE THEM ON
	;THE FREE CHAIN.

	LDA #0
	STA FRECHN
	STA FRECHN + 1;FRECHN := 0
	LDX NUMBCE
	INX ;X:=NUMBCE+1
.STRSTD
	JSR CRDESC;CREATE A DESCRIPTOR
	JSR MKFREE;PLACE IT ON THE FREE CHAIN
	DEX
	BNE STRSTD

	;NOTE THAT THE FOLLOWING CODE IS ONLY TEMPORARY
	;EVENTUALLY WE WANT TO USE THE REMAINDER OF FREE STORE
	;FOR THE CACHE (N.B. CREATEING SUFFICIENT DESCRIPTORS).

	;NOW CREATE THE CACHE AREA ITSELF

	LDY CACHSZ;Y:=LS(SIZE OF CACHE AREA)
	LDX CACHSZ + 1;X:=MS(SIZE OF CACHE AREA)
	JSR GETVEC
	STY CLRPTR
	STX CLRPTR + 1

	;MAKE FIRST DESCRIPTOR PT TO FIRST FREE CACHE BYTE

	JSR STCRNT;PREV:=CACHTB
	LDY #CESTA
	LDA CLRPTR
	STA (PREV),Y
	LDA CLRPTR + 1
	INY
	STA (PREV),Y;STORE OF PREV := PTR TO FIRST FREE BYTE

	JSR FRDESC;GET A FREE DESCRIPTOR
	LDY #CENEXT
	LDA CRNT
	STA (PREV),Y
	LDA #0
	STA (CRNT),Y
	INY
	LDA CRNT + 1
	STA (PREV),Y;NEXT OF PREV := CRNT
	LDA #0
	STA (CRNT),Y;NEXT OF CRNT := 0

	;MAKE LAST DESCRIPTOR POINT TO LAST+1 FREE BYTE

	LDY #CESTA
	SEC ;BECAUSE WE WANT TO ADD 1
	LDA CLRPTR
	ADC CACHSZ
	STA (CRNT),Y
	LDA CLRPTR + 1
	ADC CACHSZ + 1
	INY ;Y := CESTA + 01
	STA (CRNT),Y

	;NOW CLEAR WHOLE OF THE CACHE TO ZERO

	LDY CACHSZ
	LDX CACHSZ + 1
	JSR CLRSTR

	LDA #0;RC := 0
	JMP STEXIT
}


	;************ STGBB *************


	;STGBB: GET BIG BUFFER
	;THIS FUNCTION SUPPLIES THE STORE ADDRES
	;AND SIZE OF A LARGE BUFFER.
	;THIS BUFFER SHOULD BE USED FOR LARGE
	;TRANSFERS TO AND FROM THE DISC.
	;ENTRY:
	;EXIT : ARGB = LS(BUFFER STORE ADDRESS)
	;ARGC = MS(BUFFER STORE ADDRESS)
	;ARGD = LS(SIZE OF BUFFER)
	;ARGE = MS(SIZE OF BUFFER)



.STGBB
	LDY #ARGB
	LDA BIGBUF
	STA (ARGPTR),Y;LS(BUFFER ADDRESS)
	INY ;Y:=ARGC
	LDA BIGBUF + 1
	STA (ARGPTR),Y;MS(BUFFER ADDRESS)
	INY ;Y:=ARGD
	LDA #LO(LGBFSZ)
	STA (ARGPTR),Y;LS(BUFFER SIZE)
	INY ;Y:= ARGE
	LDA #HI(LGBFSZ )
	STA (ARGPTR),Y;MS(BUFFER SIZE)
	LDA #0
	JMP STEXIT



	;************ STEMPT ************


	;STEMPT: EMPTY THE CACHE OF ALL THE OBJECTS WHICH
	;CAME FROM A SPECIFIED DISC.

	;ENTRY: ARGB = LS(DISC NUMBER)
	;ARGC = MS(DISC NUMBER)

	;EXIT : ARGA = RC


.STEMPT
	LDX #2;COMPARE DISC NUMBER

	JSR EXPELL;REMOVE ALL OBJECTS ON SPECIFIED DISC FROM CACHE

	JMP STEXIT

	;STRDRT: REMOVES ALL THE DIRTY  BLOCKS, BELONGING TO
	;A SPECIFIED FILE, FROM THE CACHE.
	;NOTE IT IS ASSUMED THAT STEPS ARE TAKEN,
	;BEFORE STRALL IS CALLED, TO
	;AVOID BLOCKS OF THE FILE BEING LOADED.


	;ENTRY: ARGB = LS(DISC NUMBER)
	;ARGC = MS(DISC NUMBER)
	;ARGD = LS(SIN)
	;ARGE = CS(SIN)
	;ARGF = MS(SIN)

	;EXIT : ARGA = RC

	;FUNCTION: 1) SCAN THE CACHTB REMOVING ALL THE DIRTY
	;WINDOWS BELONGING TO THIS FILE.
	;2) THE WINDOWS MARKED DIRTY ARE WRITTEN TO DISC.
	;3) THE WINDOWS ARE THEN REMOVED FROM
	;THE CACHE.


.STRDRT
{
	JSR TSTSIN
	BNE STRDRZ

	LDA #&FF;=> Only remove DIRTY windows
	LDX #5;COMPARE DISC NUMBER & SIN
	JSR EXPELA;REMOVE ALL DIRTY OBJECTS
				;WITH GIVEN DISC NO & SIN
.STRDRZ
	JMP STEXIT
}
;.LNK
;UADE0B
;
