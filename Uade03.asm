;.OPT
;UADE03;FILE > Uade03
;.TTL
;Fileserver file UADE03

.UADE03

	;**********************************
	;*        U T I L I T I E S       *
	;**********************************

.ENPT
	CMP #1
	BEQ START
	RTS
	NOP
	EQUB &60
	EQUB LO(COPYRIGHT)
	EQUB 0;SOFTWARE VERSION NUMBER
	EQUB "Winchester File Server"
.COPYRIGHT
	EQUB 0,"(C) 1987 Acorn",CR,0

.START
{
	JSR VSTRIN
	EQUB 22, 7;select mode 7
	EQUB CR,"Acorn File Server Level "
.*VERSN
	EQUB "3 Version 1.",VERLA,VERLB,CR
	EQUB 21,"Version string",6;software protection
	EQUB "   File server station "
	NOP
	
	;If there is a bridge on the network, get the network number
	JSR MKRXCB
	LDA #0
	STA RXCBN + 13
	STA QPTR
	LDA #&9C
	STA CBPORT
	JSR RWRXCB;Create RXCB
	
	LDX #11
.BRDGL2
	LDA BRBCST,X
	STA RXCBV,X
	DEX
	BPL BRDGL2
	
	LDA #LO(RXCBV)
	STA NETCB
	LDA #HI(RXCBV)
	STA NETCB + 1
	
	JSR XMIT			;Transmit 'BRIDGE' broadcast
	
	LDY #&02			;APPROX 1 SECOND
	JSR WAIT2			;Wait for reply, or timeout

	LDA RXCBN + 13		;Local network number
	STA CBSTID + 1
	
	;Print station number LH 21/10/85
	LDA #&08
	STA &0100
	LDA #&13
	LDX #&00
	LDY #&01
	JSR OSWORD
	
	LDA &0101
	STA CBSTID
	LDA #0
	STA CBFLG
	JSR PRTMC

	JSR VSTRIN
	EQUB 28, 0, 21, 39, 4;define a window
	NOP
	
	LDX #LO(WCMD)
	LDY #HI(WCMD)
	JSR OSCLI
	
	LDX #LO(WDCMD)
	LDY #HI(WDCMD)
	JSR OSCLI

	JMP STRTFS; .. here we go ..
	
.BRBCST
	EQUB &82, &9C, &FF, &FF, "BRIDGE", &9C
	BRK
.WCMD
	EQUB "FADFS",CR;SET WINCHESTER FILING SYSTEM
.WDCMD
	EQUB "DIR :0",CR;SELECT DRIVE
}

.PROT
	EQUB 5,MASK;SET PROTECTION except USER procedure

.DOBRK
{
	JSR CURSON
	JSR VSTRIN
	EQUB 28,0,23,39,0
	NOP

	;ammended BRK handling ** 30/9/84 **
	PLA ;get P
	PLA
	STA BRKPTR
	PLA ;get address from stack
	STA BRKPTR+1;standard places to put them

	LDY #0
.DOBRKA
	LDA (BRKPTR),Y
	BEQ DOBRKB
	JSR OSASCI;print the error message
	INY
	BNE DOBRKA

.DOBRKB
	JMP TSTART
}

.SETBRK;Store old value of BRKVEC
	;and set new value to X/Y
	;
	;Called from MAPMAN and CONVERT block read routine
{
	LDA BRKVEC
	STA OLDBRK
	LDA BRKVEC + 1
	STA OLDBRK + 1
.SETBK1
	SEI
	STX BRKVEC
	STY BRKVEC + 1
	CLI
	RTS
}

	;I N P U T - O U T P U T  R O U T I N E S

.ISDCHA
{
	;Returns CC if digit or char.

	PHA
	CMP #'0'
	BCC ISCHER;Fail
	CMP #'9' + 1
	BCC ISCHEX;Succeed
	PLA ;Now check if is char.

.*ISCHAR

	;Returns CC if is alpha (upper or lower)

	PHA
	AND #&DF
	CMP #'A'
	BCC ISCHER;=> char < A
	CMP #'Z' + 1
	BCC ISCHEX;=> char => Z
.ISCHER
	SEC
.ISCHEX
	PLA
	RTS
}


.OSECHO
{
	JSR OSRDCH
	BCC OSECH1
	LDA #&7E;escape found so ack and return bad char
	JMP OSBYTE
.OSECH1
	JMP OSASCI;read & echo a char
}

.VSTRIN
{
	PLA
	STA VSTPTR
	PLA
	STA VSTPTR + 1
	LDY #0
.VSTRLP
	INC VSTPTR
	BNE INCPX
	INC VSTPTR + 1
.INCPX
	LDA (VSTPTR),Y
	BMI VSTRNX
	JSR OSASCI
	JMP VSTRLP
.VSTRNX
	JMP (VSTPTR);continue execution
}

.PRTSPC
	LDA #SPACE
	JMP OSWRCH

.WHEX
	PHP ;WRITE A AS TWO HEX DIGITS
	PHA
	LSR A
	LSR A
	LSR A
	LSR A
	JSR WHEXD
	PLA
	PHA
	AND #&F
	JSR WHEXD
	PLA
	PLP
	RTS


.WHEXD
{
	CMP #10
	BMI WHEXLA
	CLC
	ADC #7
.WHEXLA
	ADC #'0'
	JMP OSWRCH
}

	;THE FOLLOWING ROUTINES READ A LINE OF TEXT
	;TYPED AT A KEYBOARD INTO THE COMMAND LINE BUFFER (DOS=256)
	;THE PAGE ZERO REGISTER COMPTR IS USED TO POINT
	;INTO THE INPUT BUFFER.
	;THE INDEX REGISTER Y IS USED TO REFER TO
	;CHARACTERS IN THE INPUT BUFFER.
	;THE ROUTINE GETINT READS CHARS FROM INPUT BUFFER
	;AND CONVERTS THEM INTO INTEGERS (PLACED IN INTEGR).


.SETCOM
	LDA #0;COMPTR := ADDR OF INPUT BUFFER
	STA COMPTR
	LDA #1
	STA COMPTR + 1
	RTS


.INCCOM
{
	INC COMPTR;COMPTR +:= 1
	BNE INCCMZ
	INC COMPTR + 1
.INCCMZ
	RTS
}


.RDLINE
{
	JSR SETCOM
	LDA #&86
	JSR OSBYTE
	STX OFF1
	JSR CURSON
	LDX #LO(RDLNBK)
	LDY #HI(RDLNBK)
	LDA #0
	JSR OSWORD
	BCC RDLINZ
	LDA #&7C
	JSR OSBYTE
	LDA #&86
	JSR OSBYTE
	SEC
	TXA
	SBC OFF1
	TAY
.RDLNLP
	CPY #0
	BEQ RDLINE
	STY OFF1
	JSR VSTRIN
	EQUB 8,32,8
	NOP
	LDY OFF1
	DEY
	JMP RDLNLP
.RDLINZ
	JMP CURSOF

.RDLNBK
	EQUB 0,1,40,32,&80
}

	;Turn Cursor On
	;
.CURSON
	JSR VSTRIN
	EQUB 23,1,1,0,0,0,0,0,0,0
	NOP
	RTS

	;Turn Cursor off
	;
.CURSOF
	JSR VSTRIN
	EQUB 23,1,0,0,0,0,0,0,0,0
	NOP
	RTS


	;GETINT: READ A DECIMAL INTEGER INTO INTEGR.
	;NOTE COMPTR IS LEFT POINTING TO THE CHARACTER
	;FOLLOWING THE INTEGER.
	;EXIT: A = RC (<>0 => NOT A DECIMAL INTEGER)
	;MM, NOW ONLY SINGLE BYTE VALUE, RETURNED IN X

.GETINT
{
	LDY #0
	STY TEMPB;TEMPB := CHAR COUNT
	STY INTEGR;INTEGR := 0

.GETITA
	LDA (COMPTR),Y
	CMP #'0'
	BCC GETITC
	CMP #':';(':='9+1)
	BCC GETITF
	
.GETITC
	LDA TEMPB;FIRST CHAR ?
	BNE GETITK
	
.GETITX
	LDA #IERRAH
	RTS
	
.GETITF
	SEC
	SBC #'0'
	STA TEMPA + 1;SAVE DIGIT
	INC TEMPB;TEMPB +:= 1
	LDA INTEGR
	ASL A
	STA TEMPA
	BCS GETITX;OVERFLOW
	
	LDX #3
.GETITH
	ASL INTEGR
	BCS GETITX;OVERFLOW
	DEX
	BNE GETITH;INTEGR * 8
	
	CLC
	LDA INTEGR
	ADC TEMPA
	BCS GETITX;OVERFLOW
	STA INTEGR
	
	CLC
	LDA TEMPA + 1;LOAD DIGIT
	ADC INTEGR
	BCS GETITX;OVERFLOW
	STA INTEGR
	
	JSR INCCOM;COMPTR +:= 1
	JMP GETITA

.GETITK
	LDX INTEGR
	LDA #0;RC:= 0
	RTS
}


.USRERR;USRERR
{
	PHA
	JSR OSCRLF
	PLA
	JSR LOOKER;Get error msg. in MIDTX
	LDX #0
.USRERL
	LDA MIDTX,X
	JSR OSASCI
	INX
	CMP #CR
	BNE USRERL
	RTS
}




	;E R R O R  H A N D L I N G



	;STOP: THIS ROUTINE BRINGS THE FILE
	;SERVER TO A GRACEFULL HALT.
	;IT PUSHES, ONTO THE HARDWARE
	;STACK, P,A,X,Y AND REMEMBERS
	;THE VALUE OF THE STACK PTR IN
	;STKPTR (SEE HEADER FILE).


.STOP
	PHP ;PUSH P,A,X,Y REMEMBER STK PTR
	PHA
	TXA
	PHA
	TYA
	PHA
	TSX
	STX STKPTR

	JSR OSCRLF
	JMP TSTART;cant use BRK cos it's intercepted ** 28/9/84 **

.INTERR
	PHP
	PHA
	TXA
	PHA
	TYA
	PHA
	JSR VSTRIN
	EQUB CR,"FS internal error #"
	NOP
	PLA
	TAY
	PLA
	TAX
	PLA
	PLP
	JSR WHEX
	JSR VSTRIN
	EQUB CR,"AT ADDRESS "
	NOP
	PLA
	TAX
	PLA
	JSR WHEX
	TXA
	JSR WHEX
	JMP STOP




	;COMPAR: COMPARE TWO AREAS OF STORE,
	;BYTE-BY-BYTE.

	;ENTRY: MOVFRM = PTR TO 1ST AREA
	;MOVTO  = PTR TO 2ND AREA
	;X      = NO. OF BYTES TO BE COMPARED

	;EXIT: A = 0 IF IDENTICAL
	;<>0 IF NOT IDENTICAL
	;N.B. STATE BITS (Z ETC) ARE ALSO SET.
	;NOTE X,Y,A ARE DESTROYED.


.COMPAR
{
	TXA
	TAY
.COMPRA
	DEY
	LDA (MOVFRM),Y
	CMP (MOVTO),Y
	BNE COMPRZ
	DEX
	BNE COMPRA
.COMPRZ
	TXA
	RTS
}



	;F R E E  S P A C E  M A N A G E M E N T


	;SPACE IS ALLOCATED FROM A
	;CONTIGUOUS AREA OF MEMORY. N.B.
	;THAT SPACE CANNOT BE RETURNED TO
	;THE FREE POOL.


	;GETVEC: RETURNS A POINTER TO A FREE
	;AREA OF MEMORY.
	;THE PAGE ZERO POINTER,
	;FREPTR POINTS TO THE BEGINNING
	;OF FREE SPACE.


	;ENTRY: Y,X = SIZE (Y=LS)
	;EXIT: Y,X = PTR TO VECTOR

	;FUNCTION:-

	;IF FREPTR+SIZE > ENDPTR
	;THEN ERROR(INSUFFICENT SPACE)
	;ELSE FREPTR +:=:= SIZE
	;FI

.GETVEC
{
	TXA ;FIRST CHECK THAT SIZE REQUESTED <> 0
	BNE GVEC1
	TYA
	BNE GVEC1
	LDA #IERRAF;SIZE = 0
.GVECER
	JSR INTERR
.GVEC1
	CLC
	TYA
	ADC FREPTR
	STA GVWRKA;GETVEC WORK VARIABLE A
	TXA
	ADC FREPTR + 1
	STA GVWRKA + 1
	BCC CHECKS
	LDA #IERRAD;X,Y TOO BIG!
	BNE GVECER
.CHECKS
	LDA ENDPTR;IS GVWRKA > ENDPTR
	CMP GVWRKA
	LDA ENDPTR + 1
	SBC GVWRKA + 1
	BCS OK
	LDA #IERRAE;INSUFFICIENT SPACE
	BNE GVECER
.OK
	LDY FREPTR
	LDX FREPTR + 1
	LDA GVWRKA
	STA FREPTR
	LDA GVWRKA + 1
	STA FREPTR + 1
	RTS
}


	;CLRSTR: CLEARS A SPECIFIED STORE AREA TO ZERO.

	;ENTRY:- CLRPTR (PAGE ZERO) = START ADDRESS
	;X,Y = NUMBER OF BYTES (Y=LS)
	;NOTE A & TEMPA ARE DESTROYED BY THIS RTN

.CLRSTR
{
	LDA #0
	STA TEMPA + 1
	STY TEMPA
	TYA
	BEQ CLC
	LDA #0
.CLB
	DEY
	STA (CLRPTR),Y
	BNE CLB
.CLC
	TXA
	BEQ CLD
	CLC
	LDA CLRPTR
	ADC TEMPA
	STA CLRPTR
	LDA CLRPTR + 1
	ADC TEMPA + 1
	STA CLRPTR + 1
	LDY #1
	STY TEMPA + 1
	DEY
	TYA
	STY TEMPA
	DEX
	JMP CLB
.CLD
	RTS
}


	;MOVBLK: MOVE DATA FROM PTR AT X OFFSET BY OFF1, TO
	;        PTR AT Y OFFSET BY OFF2. A CONTAINS THE AMOUNT
	;        TO MOVE. USEFUL FOR MOVING TO AND FROM THE STACK
	;        TO TABLES IN DYNAMIC AREA.
	;

.MOVBLK

	PHA ;Push amount to move
	CLC
	LDA 0,X
	ADC OFF1
	STA MOVFRM;Set "from" pointer
	LDA 0001,X
	ADC #0
	STA MOVFRM + 1

	CLC
	LDA 0,Y
	ADC OFF2;Set "to" pointer
	STA MOVTO
	LDA 0001,Y
	ADC #0
	STA MOVTO + 1

	PLA
	TAX ;Set length for MOVE

	;And drop into MOVE

	;MOVE: MOVE DATA FROM ONE AREA OF MEMORY TO A NEW AREA
	;N.B. DATA AREAS SHOULD NOT OVERLAPP!!!!!

	;ENTRY: MOVFRM - PAGE ZERO FROM ADDRESS
	;MOVTO  - PAGE ZERO TO ADDRESS
	;X       - AMOUNT TO BE MOVED

	;NOTE THAT A,X,Y ARE DESTROYED BY THIS ROUTINE


.MOVE
{
	LDY #0
	TXA
	BEQ MOVEXX;If zero to move, exit

.MOVEA
	LDA (MOVFRM),Y
	STA (MOVTO),Y
	INY
	DEX
	BNE MOVEA
.MOVEXX
	RTS
}


	;MRKDRT: MARK A STORE BUFFER DIRTY

	;ENTRY: GENPTR => STORE ADDRESS OF BUFFER

	;SAVED: A,X,Y
	;DESTROYED: GENPTR


.MRKDRT
{
	PHA ;PUSH A
	TYA
	PHA ;PUSH Y
	JSR DCGEN;INITITIALISE GENPTR & Y
	LDA #DIRTY
	STA (GENPTR),Y
	PLA
	TAY ;PULL Y
	PLA ;PULL A
	RTS

.DCGEN
	LDA GENPTR
	BNE DCGENJ
	DEC GENPTR+1
.DCGENJ
	DEC GENPTR
	LDY #0
	RTS
}




	;I N T E R  M O D U L E  C O M M U N I C A T I O N


	;ARGUMENTS ARE PASSED AROUND ON
	;A SOFTWARE STACK. WHEN IN A
	;MODULE ARGUMENTS SETUP BY THE
	;CALLER (AND THOSE TO BE PASSED
	;BACK) ARE POINTED TO BY THE
	;PAGE ZERO REGISTER, ARGPTR.
	;PARAMETERS FOR THE NEXT MODULE
	;TO BE CALLED ARE POINTED TO BY
	;THE PAGE ZERO REGISTER, NEWARG.
	;THE POSN OF NEWARG RELATIVE TO
	;ARGPTR IS SET BY THE SETFS ROUTINE.
	;SETFS MUST BE CALLED
	;BEFORE A MODULE IS CALLED.



	;SETFS: SET FRAME SIZE. THIS RTN
	;SETS UP THE CORRECT VALUE
	;OF THE PAGE ZERO POINTER,
	;NEWARG.
	;ON ENTRY A = NUMBER OF ARGUMENT
	;STACK POSNS TO BE SET ASIDE.
	;IT ALSO PLACES ZERO IN THE REMEMBER ENTRY REASON SLOT.


	;FUNCTION:-

	;NEWARG  := ARGPTR+A+FINFO
	;[NEWARG] := A+FINFO
	;[NEWARG+ENTRES] := 0



.SETFS
{
	CLC
	ADC #FINFO;A:=FINFO+A
	BCC SETFSA
	LDA #IERRAA;FRAME SIZE TOO BIG
	JSR INTERR;INTERNAL ERROR
.SETFSA
	PHA ;PUSH A
	ADC ARGPTR;A:=A+LS(ARGPTR)
	STA NEWARG;LS(NEWARG) := A
	LDA ARGPTR + 1;A:=MS(ARGPTR)
	ADC #0
	STA NEWARG + 1;MS(NEWARG):=A
	PLA ;PULL ACCUMULATOR
	LDY #FRAMSZ;Y:=POSN OF FRAME SIZE INFO
	STA (NEWARG),Y;[NEWARG] :=A
	LDY #ENTRES;Y:= POSN OF ENTRY REASON TO BE REMEMBERED
	LDA #0
	STA (NEWARG),Y;ENTRY REASON := 0 AT THE MOMENT
	RTS
}


	;ENTRY: THIS RTN MUST BE CALLED ON
	;EVERY ENTRY TO A MODULE. IT
	;CHECKS THAT THE ENTRY CODE
	;0 < (ARG0) >= A.  IT ALSO PLACES
	;THE NAME OF THE CALLED MODULE
	;AND THE VALUE OF ARGA (THE ENTRY REASON)
	;ON THE ARGUMENT STACK (THIS IS USEFUL WHEN DEBUGGING).

	;ON ENTRY:-

	;X = NUMB OF MODULE ENTRY POINTS
	;A= NUMBER OF MODULE

	;FUNCTION:-

	;ARGPTR := NEWARG
	;X := JUMP TABLE OFFSET
	;NEWARG := $FFFF (SHOULD BE SET BY SETFS RTN)



.ENTRY
{
	LDY #MODNME
	STA (NEWARG),Y;PUSH NAME OF CALLED MODULE ON ARG STACK
	TXA ;A:= NUMBER OF EXPECTED ENTRY POINTS
	LDY #ARGA;Y:=ARGA
	CMP (NEWARG),Y
	BPL ENTRYA
	LDA #IERRAC;UNKNOWN ENTRY REASON
.ENTRYE
	JSR INTERR
.ENTRYA
	LDA (NEWARG),Y;A:=[NEWARG+ARGA]
	BNE ENTRYB
	LDA #IERRAB;FUNCTION CODE = 0
	BNE ENTRYE

	;NOW MAKE ARGPTR := NEWARG

.ENTRYB
	LDA NEWARG;A:= LS(NEWARG)
	STA ARGPTR;LS(ARGPTR):=A
	LDA NEWARG + 1;A:=MS(NEWARG)
	STA ARGPTR + 1;MS(ARGPTR):=A
	
	;NOW WORKOUT JUMP TABLE OFFSET
	LDA (ARGPTR),Y
	LDY #ENTRES
	STA (ARGPTR),Y;COPY OF ARGA (THE ENTRY REASON)
	STA ENWRKA;ENWRKA:=[ARGPTR+ARGA]
	DEC ENWRKA;ENWRKA -:= 1
	ASL ENWRKA;ENWRKA *:= 2
	LDX ENWRKA;X := JUMP TABLE OFFSET
	LDA #&FF
	STA NEWARG
	STA NEWARG + 1;NEWARG := $FFFF
	RTS
}


	;EXIT: THIS RTN SHOULD BE
	;CALLED BY EVERY MODULE, JUST
	;BEFORE IT RETURNS TO ITS CALLER.

	;FUNCTION:-

	;NEWARG := ARGPTR
	;ARGPTR := ARGPTR-[ARGPTR]
	;A := [NEWARG+ARGA]
	;Y := ARGA

.EXIT
	LDY #ARGA
	STA (ARGPTR),Y;RETURN CODE
	
	LDY #FRAMSZ;Y:=POSN OF FRAME SIZE INFO
	LDA ARGPTR;A:=LS(ARGPTR)
	STA NEWARG;LS(NEWARG):=A
	LDA ARGPTR + 1
	STA NEWARG + 1;NOW NEWARG=ARGPTR
	
	SEC
	LDA ARGPTR;A:=LS(ARGPTR)
	SBC (ARGPTR),Y;A:=A-SIZE OF PREVIOUS STACK FRAME
	STA ARGPTR;LS(ARGPTR):=A
	BCS PREXIT
	DEC ARGPTR + 1;MS(ARGPTR)


.PREXIT
	LDY #ARGA
	LDA (NEWARG),Y
	RTS




	;A R I T H M E T I C  R O U T I N E S


.MULTBS
{
	LDX #8;BREGA *:= BLKSZE
.MBSA
	ASL BREGA
	ROL BREGA + 1
	ROL BREGA + 2
	DEX
	BNE MBSA
	RTS
}



.SETTAB;SETTAB
{
	;ENTRY: X - NO. OF ENTRIES IN TABLE
	;Y - SIZE OF EACH ENTRY

	;EXIT:  Y -> TABLE (LO)
	;X -> TABLE (HI)

	;TABLE IS CLEARED TO ZERO AFTER
	;GETTING SPACE FROM GETVEC.

	LDA #0
	STA TEMPA
	STA TEMPA + 1
.SETTBL
	CLC
	TYA
	ADC TEMPA
	STA TEMPA
	BCC SETTBJ
	INC TEMPA + 1
.SETTBJ
	DEX
	BNE SETTBL

	LDY TEMPA
	LDX TEMPA + 1
	JSR GETVEC;*** GET SPACE **
	TYA
	PHA ;DONT' TRUST CLRSTR WITH X/Y
	TXA
	PHA
	STY CLRPTR
	STX CLRPTR + 1
	LDY TEMPA
	LDX TEMPA + 1
	JSR CLRSTR
	PLA
	TAX
	PLA
	TAY
	RTS
}


.GETBB
{
	LDA #7
	JSR SETRTN
	JSR STRMAN;Do get big buffer
	BNE GETBBX

	LDX #3
	LDY #ARGE
.GETBBL
	LDA (NEWARG),Y
	STA BBUF,X;Set address and size
	DEY
	DEX
	BPL GETBBL
	
	CLC
	LDA BBUF
	ADC BBSIZE
	STA BBEND;Set end address
	LDA BBUF + 1
	ADC BBSIZE + 1
	STA BBEND + 1

	;declare a new I/O side buffer for file transfers
	;Nb 2nd processor FS only
	INX ;X:=0
	STX IOBUF;even page boundary
	LDY #&FF
	STY ODSCMN;illegal value for big buffer cache
	STY ODSCMN + 1	
	
	LDA #180 ;X=0, Y=FF
	JSR OSBYTE;read I/O OSHWM
	STX IOBUF + 1;base of buffer
	
	LDA #135
	JSR OSBYTE;read a char, get screen mode in Y
	TYA
	TAX ;read the bottom of display
	LDA #133
	JSR OSBYTE;result in X,Y
	
	STX IOEND
	STY IOEND + 1

	SEC
	STX IOBSIZ
	TYA
	SBC IOBUF + 1
	STA IOBSIZ + 1;two bytes

.GETBBX
	RTS
}

.INCGPT
{
	INC GENPTR
	BNE INCGPX
	INC GENPTR + 1
.INCGPX
	RTS
}

.MEMTST;MEMTST
{
	;First find end of memory. Then test memory
	;several times with random numbers and once each
	;with %0 and $FF.

	JSR VSTRIN
	EQUB CR,"Testing Memory",CR
	NOP

	LDA #LO(FRESTR)
	STA GENPTR;NOTE ASSUMES FRESTR ON PAGE BOUNDARY
	LDA #HI(FRESTR)
	STA GENPTR + 1
	LDY #0
.MEMTLA
	LDA #&55
	STA (GENPTR),Y
	LDA #&FF
	INY
	STA (GENPTR),Y;Clear address lines
	INY
	STA (GENPTR),Y
	DEY
	DEY
	LDA (GENPTR),Y
	CMP #&55
	BNE MEMTLB;NE if found
	LDX GENPTR + 1
	INX
	STX GENPTR + 1;use page sized jumps
	CPX #&F8;look for start of NET code
	BNE MEMTLA

.MEMTLB
	DEY
	CLC
	TYA
	STA NEWARG
	LDA GENPTR + 1
	SEC
	SBC #1
	STA NEWARG + 1
	JSR VSTRIN
	EQUB CR,"Last free location = "
	NOP
	LDA NEWARG + 1
	JSR WHEX
	LDA NEWARG
	JSR WHEX
	JSR OSCRLF

	;NOW TEST MEMORY

	LDA #&44;Set "random number"
	STA COZERO
	LDA #&55
	STA COZERO + 1
	STA COZERO + 2
	LDA #0
	STA ARGPTR;Use ARGPTR as an error flag
	LDX #3
.MEMTLC
	JSR RMTSTA;Rajdom number test
	DEX
	BNE MEMTLC
	LDA #0
	JSR RMTSTB
	LDA #&FF
	JSR RMTSTB

	LDA NEWARG
	STA MEMEND
	LDA NEWARG + 1
	STA MEMEND + 1
	LDA ARGPTR;Error flag
	RTS


.RMTSTA;RMTSTA

	;Test from FREPTR to NEWARG using pseudo rand. nos.
	;in COZERO +00/01/02

	LDA #LO(FRESTR)
	STA GENPTR
	LDA #HI(FRESTR)
	STA GENPTR + 1

.RMTALD
	LDA COZERO
	STA COZERO + 3;Store for checking pass
	LDA COZERO + 1
	STA COZERO + 4
	LDA COZERO + 2
	STA COZERO + 5
	LDY #0
.RMTALA
	LDA COZERO
	STA (GENPTR),Y
	JSR RANDUM
	INY
	BNE RMTALA

	;Reset rand. no. and check page.

	LDA COZERO + 3
	STA COZERO
	LDA COZERO + 4
	STA COZERO + 1
	LDA COZERO + 5
	STA COZERO + 2
.RMTALB
	LDA COZERO
	CMP (GENPTR),Y
	BEQ RMTALC;OK, continue
	JSR MEMERR
.RMTALC
	JSR RANDUM
	INY
	BNE RMTALB

	;Finished testing one page, do next one.

	INC GENPTR + 1
	LDA NEWARG + 1
	CMP GENPTR + 1
	BCS RMTALD;G/ptr >= NEWARG, continue.
	RTS


.RMTSTB;RMTSTB

	;Test memory using value in A.

	STA COZERO
	LDA #LO(FRESTR)
	STA GENPTR
	LDA #HI(FRESTR)
	STA GENPTR + 1
.RMTBLD
	LDY #0
	LDA COZERO
.RMTBLA
	STA (GENPTR),Y
	INY
	BNE RMTBLA;Fill a page
.RMTBLB
	LDA (GENPTR),Y
	CMP COZERO
	BEQ RMTBLC;OK, continue
	JSR MEMERR
.RMTBLC
	INY
	BNE RMTBLB

	INC GENPTR + 1
	LDA NEWARG + 1
	CMP GENPTR + 1
	BCS RMTBLD
	RTS


.RANDUM;RANDUM

	;Generate next random number

	LDA COZERO
	EOR #2
	LSR A
	LSR A
	ROR COZERO
	ROR COZERO + 1
	ROR COZERO + 2
	RTS



.MEMERR;MEMERR

	;Print error location and set flag


	PHA
	LDA #&FF
	STA ARGPTR;Set error flag
	TYA
	PHA
	JSR VSTRIN
	EQUB "Fails at: "
	NOP

	LDA GENPTR + 1
	JSR WHEX
	CLC
	PLA
	TAY
	ADC GENPTR
	JSR WHEX
	JSR OSCRLF

	PLA
	RTS
}


.JUSINF;pass userinfo pointer to CHANGESIZE

	LDY #ARGB
	LDA (ARGPTR),Y
	TAX
	INY
	LDA (ARGPTR),Y

	LDY #ARGK
	STA (NEWARG),Y
	DEY
	TXA
	STA (NEWARG),Y
	RTS ;** 3/10/84 **

;.LNK
;UADE04
