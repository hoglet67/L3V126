;.OPT
;UADE05;> Uade05
;.TTL
;Fileserver file UADE05

.UADE05

	;*********************************
	;*         G L O R T N           *
	;*     AND  DOS  CONVERSION      *
	;*********************************


	;***** R N D M A N  R O U T I N E S *****


	;FNDHND: SEARCHES THE HANDLE TABLE (HANDTB)
	;FOR A SPECIFIED HANDLE.

	;ENTRY: A = HANDLE
	;MCNUMB = MACHINE NUMBER

	;EXIT : A = RC
	;HNDPTR - LEFT POINTING TO PARTICULAR ENTRY
	;CONTAINING SPECIFIED (HANDLE,MC/NO).
	;NOTE A,X,Y,RNDTMP ARE DESTROYED.


.FNDHND
{
	STA RNDTMP;RNDTMP := HANDLE
	TAY
	BEQ FNDHDE
	JSR INITHD;HNDPTR:=HANDTB;X:=HTENTS

	;FIRST SEE IF MACHINE NUMBER MATCHES

.FNDHDC
	LDY #HTMCNO;LSIG BYTE FIRST
	LDA (HNDPTR),Y
	CMP MCNUMB
	BNE FNDHDM
	INY
	LDA (HNDPTR),Y
	CMP MCNUMB + 1
	BNE FNDHDM
	INY
	LDA (HNDPTR),Y
	CMP MCNUMB + 2
	BNE FNDHDM

	;NOW SEE IF HANDLE MATCHES

	LDY #HTHAND
	LDA RNDTMP
	CMP (HNDPTR),Y
	BNE FNDHDM

	;FOUND

	LDA #0;RC := 0
	RTS

.FNDHDM
	JSR INCHND;MOVE HNDPTR TO NEXT ENTRY,DEX
	BNE FNDHDC
	
.FNDHDE
	LDA #RDERRB
	RTS
}

.INITHD
	LDA HANDTB;HNDPTR := HANDTB
	STA HNDPTR
	LDA HANDTB + 1
	STA HNDPTR + 1
	LDX HTENTS;X := HTENTS
	RTS


.INCHND
{
	CLC ;HNDPTR +:= HTENSZ
	LDA HNDPTR
	ADC #HTENSZ
	STA HNDPTR
	BCC INCHNK
	INC HNDPTR + 1
.INCHNK
	DEX ;X -:= 1
	RTS
}


	;USRMAN ROUTINES

	;FINDMC: FIND A USERTB ENTRY - SEARCH
	;USERTB FOR AN ENTRY CONTAINING A
	;GIVEN MACHINE NUMBER.
	;NOTE THAT FINDMC MAY BE CALLED
	;BY ANY MODULE.
	;(THIS FUNCTION WILL PROBABLY
	;NEED SPEEDING UP - POSSIBLY USING
	;A HASH TABLE FOR USERTB)

	;ENTRY: THE VARIABLE, MCNUMB,
	;SHOULD CONTAIN THE
	;NUMBER OF THE MACHINE
	;TO BE LOOKED UP IN USERTB.

	;EXIT:  A = RC
	;IF A = 0
	;THEN USTPTR (PAGE ZERO) IS
	;LEFT POINTING TO THE USERTB ENTRY
	;FI



.FINDMC
{
	JSR INITUS;USTPTR:=USERTB,X:=UTENTS
.FINDCA
	LDA MCNUMB;LS(MC/NO)
	LDY #UTMCNO
	CMP (USTPTR),Y
	BNE FINDCD
	INY
	LDA MCNUMB + 1
	CMP (USTPTR),Y
	BNE FINDCD
	INY
	LDA MCNUMB + 2
	CMP (USTPTR),Y
	BNE FINDCD
	
	LDY #UTPRIV
	LDA (USTPTR),Y
	AND #INUSE
	BEQ FINDCD

	LDA #0;RETURN CODE
	RTS	;BEQ FINDCZ

.FINDCD
	JSR INCUST;USTPTR+:=UTENSZ,X-:=1
	BNE FINDCA
	LDA #URERRA;RC:=MACHINE NOT LOGGED ON
	RTS
}

.INITUS
	LDA USERTB;USTPTR:=USERTB,X:=USERS
	STA USTPTR
	LDA USERTB + 1
	STA USTPTR + 1
	LDX USERS
	RTS


.INCUST
{
	CLC ;USTPTR+:=UTENSZ,X-:=1
	LDA USTPTR
	ADC #UTENSZ
	STA USTPTR
	BCC INCUSK
	INC USTPTR + 1
.INCUSK
	DEX
	RTS
}


.DRVINF
	LDY #ARGB;A := DRIVE NUMBER
	STA (NEWARG),Y
	DEY ;Y := ARGA
	LDA #8;MAPMAN.DRIVEINFO
	STA (NEWARG),Y
	JMP MAPMAN



.FLUDRV;FLUDRV
{
	;Flushes store and ensures map for drive
	;passed in A.

	JSR DRVINF;GET DISC NO.
	BNE FLUDAB;ABORT IF ERROR

	LDA #8
	JSR SETRTN
	JSR STRMAN;*** FLUSH STORE **
	BNE FLUDAB

	LDA #6
	JSR SETRTN
	JSR MAPMAN;*** ENSURE DISC **
.FLUDAB
	RTS
}

.FLUSYS;FLUSYS
{
	;Flushes all drives in system, so it is
	;safe to start from scratch !!

	LDA DRIVES
.FLUSLP
	SEC
	SBC #1
	BMI FLUSEX
	PHA
	JSR FLUDRV
	BNE FLUSAB
.FLUSYJ
	PLA
	JMP FLUSLP

.FLUSEX
	LDA #16;WRITE MAP TO DISC
	JSR SETRTN
	JMP MAPMAN
	
.FLUSAB
	CMP #MPERRF;ILLEGAL DRIVE NUMBER?
	BEQ FLUSYJ
	JSR USRERR
	PLA
	RTS
}

;.LNK
;UADE06
