;.OPT
;MBBMCM;> Mbbmcm
;.TTL
;Fileserver file MBBMCM

.MBBMCM

	;
	; MAP BLOCK AND BIT MAP MANAGEMENT
	;
	;
	; INITIALISE THE MAP BLOCKS
	;
	; ALLOCATES CONTROL BLOCKS FOR THE BIT MAP CACHE
	; AND THE MAP BLOCK CACHE
	;
	; USES
	;    MPTMPE,MPTMPD
	;
.INBKMN
	LDY #LO(SZMBCB)
	LDX #HI(SZMBCB)
	JSR GETVEC;GET SPACE FOR MAP BLOCK CHACHE DESCRIPTORS
	STY MBCBPT;SAVE POINTER TO AREA
	STX MBCBPT + 1
	LDY #LO(SZBMCB)
	LDX #HI(SZBMCB)
	JSR GETVEC;GET SPACE FOR BIT MAP CACHE DESCRIPTORS
	STY BMCBPT
	STX BMCBPT + 1;SAVE THIS POINTER
	LDA #LO(SZBMAR);SIZE OF MEMORY AREA FOR THESE BLOCKS
	STA MPTMPE
	LDA #HI(SZBMAR)
	STA MPTMPE + 1
	JSR SETBM
	JSR SETCBS;INITIALISE CONTROL BLOCKS
	LDA #LO(SZMBAR);SIZE OF MAP BLOCK AREA
	STA MPTMPE
	LDA #HI(SZMBAR)
	STA MPTMPE + 1
	JSR SETMB
	JSR SETCBS
.SCBND
	RTS
	;
	; SETUP MAP BLOCK OR BIT MAP CONTROL BLOCKS
	;
	; ON ENTRY
	;     GNCBPT POINTS TO CONTROL BLOCK
	;     MPTMPE HOLDS SIZE OF DISC BLOCK CACHE
	;     NCBDB HOLDS NUMBER OF DISC BLOCK ENTRIES
	;
.SETCBS
{
	LDY MPTMPE
	LDX MPTMPE + 1;GET SIZE OF CACHE
	JSR GETVEC;GET THE SPACE
	STY MPTMPE
	STX MPTMPE + 1; SAVE THE AREA
	LDX NCBDB;GET NUMBER OF ENTRIES
.SCBLP
	LDY #CAFLG
	LDA #0
	STA (GNCBPT),Y;ZERO ALL FLAGS
	LDY #CBSA
	LDA MPTMPE
	STA (GNCBPT),Y;SAVE ADDRESS OF STORE
	INY
	LDA MPTMPE + 1
	STA (GNCBPT),Y
	DEX
	BEQ SCBND; FINISH
	CLC
	LDA MPTMPE;INCREMENT TO NET BLOCK OF STORE
	ADC #LO(BTINBK)
	STA MPTMPE
	LDA MPTMPE + 1
	ADC #HI(BTINBK)
	STA MPTMPE + 1
	JSR ADGNCB
	JMP SCBLP;TRY NEXT
}
	;
	; GET BLOCK TO STORE
	;
	; ON ENTRY
	;      CBSIN HOLDS THE DISC ADDRESS
	;      GNCBPT POINTS TO RELEVANT CACHE DESCRIPTORS
	;      NCBDB HOLDS NUMBER OF CONTROL BLOCK ENTRIES
	;      MPDRVE HOLDS DRIVE NUMBER
	;
	; ON EXIT
	;      CBSTA HOLDS STORE ADDRESS OF BLOCK
	;
.GTBTS
{
	LDA GNCBPT;SAVE POINTER TO CONTROL BLOCKS
	PHA
	LDA GNCBPT + 1
	PHA
	JSR FNDBLK
	BCC GTSRI
.GTBGT
	LDY #CBSA;IN STORE SO JUST GET ADDRES
	LDA (GNCBPT),Y
	STA CBSTA
	INY
	LDA (GNCBPT),Y
	STA CBSTA + 1
	LDY #CBAGE
	LDA #0
	STA (GNCBPT),Y
	PLA ;RESTORE POINTER
	STA GNCBPT + 1
	PLA
	STA GNCBPT
	JSR CAAGE;AGE ALL ENTRIES
	LDA #0
	RTS
.GTSRI
	PLA ;NEED TO START AT BEGINNING AGAIN
	TAX
	PLA
	STA GNCBPT
	PHA
	STX GNCBPT + 1
	TXA
	PHA ;KEEP POINTER IN CORRECT ORDER ON STACK
	JSR GETFR;GET A FREE POSITION
	BNE GTBND1;IF FAILED restore stack and exit LH 17/1/86 **
	LDY #CBDA
	LDA CBSIN
	STA (GNCBPT),Y
	INY
	LDA CBSIN + 1
	STA (GNCBPT),Y
	INY
	LDA CBSIN + 2
	STA (GNCBPT),Y
	LDY #CBDR
	LDA MPDRVE
	STA (GNCBPT),Y
	JSR RDBLK;READ IN THE NEW BLOCK
	BEQ GTSR1
	LDA #2;READ ERROR
	ORA ERRTYP
	STA ERRTYP
.GTSR1
	LDY #CAFLG
	LDA (GNCBPT),Y
	ORA #1;FLAG IN STORE
	STA (GNCBPT),Y
	BNE GTBGT
.GTBND1
	TAX ; preserve error
	PLA ; restore stack LH 17/1/86 ***
	STA GNCBPT + 1
	PLA
	STA GNCBPT
	TXA
	RTS
}
	;
	; FIND A SPECIFIED DISC BLOCK IN STORE
	;
	; CBSIN HOLDS DISC ADDRESS
	; MPDRVE HOLDS DRIVE NUMBER
	;
	; C SET IF FOUND
.FNDBLK
{
	LDA GNCBPT
	PHA
	LDA GNCBPT + 1
	PHA
	LDX NCBDB;CHECK IF ALREADY IN STORE
.FBLP
	LDY #CBDA
	LDA (GNCBPT),Y
	CMP CBSIN
	BNE FBNX
	INY
	LDA (GNCBPT),Y
	CMP CBSIN + 1
	BNE FBNX
	INY
	LDA (GNCBPT),Y
	CMP CBSIN + 2
	BNE FBNX
	LDY #CBDR
	LDA (GNCBPT),Y
	CMP MPDRVE
	BEQ FBGT
.FBNX
	DEX
	BEQ FBRI
	JSR ADGNCB
	JMP FBLP
.FBGT
	LDY #CAFLG;CHECK IF IN STORE
	LDA (GNCBPT),Y
	AND #1
	BEQ FBNX
	PLA
	PLA
	SEC
	RTS
.FBRI
	PLA
	STA GNCBPT + 1
	PLA
	STA GNCBPT
	CLC
	RTS
}
	;
	; READ/WRITE A BLOCK INTO STORE
	;
	; ON ENTRY
	;      GNCBPT POINTS TO ENTRY IN CACHE DESCRIPTOR
	;
.RDBLK
	LDA #&08
	BNE TRBLK

.WRBLK
	LDA #&0A
.TRBLK
{
	STA SAVCOM
	LDY #CBDR
	LDA (GNCBPT),Y
	STA DRIVNO
	LDY #CBDA
	LDA (GNCBPT),Y
	STA RBDA; SAVE DISC ADDRESS
	INY
	LDA (GNCBPT),Y
	STA RBDA + 1
	INY
	LDA (GNCBPT),Y
	STA RBDA + 2
.TRCLLP
	LDY #MPSECS
	LDA RBDA
	CMP (MAPPTR),Y
	INY
	LDA RBDA + 1
	SBC (MAPPTR),Y
	INY
	LDA RBDA + 2
	SBC (MAPPTR),Y
	BCC TRBKLP
	LDY #MPADFT
	CLC
	LDA DRIVNO
	ADC (MAPPTR),Y
	STA DRIVNO
	SEC
	LDY #MPSECS
	LDA RBDA
	SBC (MAPPTR),Y
	STA RBDA
	INY
	LDA RBDA + 1
	SBC (MAPPTR),Y
	STA RBDA + 1
	INY
	LDA RBDA + 2
	SBC (MAPPTR),Y
	STA RBDA + 2
	JMP TRCLLP
.TRBKLP
	LDY #CBSA
	LDA (GNCBPT),Y
	STA DCSTAD
	INY
	LDA (GNCBPT),Y
	STA DCSTAD + 1
	LDA DSCCB+TRADD+2
	PHA
	LDA #0
	STA DSCCB+TRADD+ 2
	STA DSCCB+TRADD+ 3
	LDY #CAFLG;MARK NOT WRITTEN
	LDA (GNCBPT),Y
	AND #3
	STA (GNCBPT),Y
	LDA RBDA
	ORA RBDA +1
	ORA RBDA +2;IF SECTOR ZERO CALCULATE CHECKSUM
	BNE TRXFR
	LDA GNCBPT
	PHA
	LDA GNCBPT +1
	PHA
	LDA DCSTAD
	STA GNCBPT
	LDA DCSTAD +1
	STA GNCBPT +1
	LDY #&FF
	TYA
	STA (GNCBPT),Y
	LDA #0
	CLC
.TRCRCL
	ADC (GNCBPT),Y
	DEY
	BNE TRCRCL
	ADC (GNCBPT),Y
	DEY
	STA (GNCBPT),Y
	PLA
	STA GNCBPT +1
	PLA
	STA GNCBPT
.TRXFR
	JSR XFER;TRANSFER THE BLOCK
	TAX
	PLA
	STA DSCCB+TRADD+2
	STA DSCCB+TRADD+3
	TXA
	RTS
}
	;
	; AGE ALL CHAIN ENTRIES
	;
	; ON ENTRY
	;      GNCBPT POINTS TO RELEVANT CACHE DESCRIPTOR
	;      NCBDB HOLDS NUMBER OF ENTRIES
	;
.CAAGE
{
	LDA GNCBPT
	PHA ; SAVE THE POINTER
	LDA GNCBPT + 1
	PHA
	LDX NCBDB
.CBALP
	LDY #CBAGE; GET CURRENT AGE
	LDA (GNCBPT),Y
	ADC #1;INCREMENT
	STA (GNCBPT),Y
	DEX
	BEQ CBAND;CHECK FOR END
	JSR ADGNCB
	JMP CBALP;LOOK AT NEXT ENTRY
.CBAND
	PLA ;GET POINTER BACK
	STA GNCBPT + 1
	PLA
	STA GNCBPT
	RTS
}
	;
	; GET A FREE SPACE FOR A BLOCK
	;
	; ON ENTRY
	;      GNCBPT POINTS TO START OF CONTROL BLOCK
	;      NCBDB HOLDS NUMBER OF CONTROL BLOCK ENTRIES
	;
	; ON EXIT
	;      GNCBPT POINTS TO VACANT ENTRY
	;
	; USES
	;      CBSTA,CBTPPT
	;
.GETFR
{
	LDA GNCBPT
	PHA
	LDA GNCBPT + 1
	PHA
	LDX NCBDB
	LDA #&FF
	STA CBSTA;CURRENT YOUNGEST
	LDA #0
	STA CBTPPT;CURRENT POINTER TO YOUNGEST
	STA CBTPPT + 1
.GTYLP
	LDY #CAFLG
	LDA (GNCBPT),Y
	AND #4;CHECK IF WRITTEN
	BEQ GTYNX
	LDA (GNCBPT),Y
	AND #2;CHECK IF LOCKED
	BNE GTYNX
	LDY #CBAGE
	LDA (GNCBPT),Y
	CMP CBSTA
	BCS GTYNX
	STA CBSTA
	LDA GNCBPT
	STA CBTPPT
	LDA GNCBPT + 1
	STA CBTPPT + 1
.GTYNX
	JSR ADGNCB
	DEX
	BNE GTYLP
	LDA CBTPPT
	STA GNCBPT
	ORA CBTPPT + 1
	BEQ GTYND
	LDA CBTPPT + 1
	STA GNCBPT + 1
	JSR WRBLK
	BEQ GTYND
	LDA #1
	ORA ERRTYP
	STA ERRTYP
.GTYND
	PLA
	STA GNCBPT + 1
	PLA
	STA GNCBPT
	LDX NCBDB;NUMBER OF ENTRIES
	LDA #0
	STA CBSTA;CURRENT OLDEST
	STA CBTPPT;CURRENT POINTER TO OLDEST
	STA CBTPPT + 1
.GTFLP
	LDY #CAFLG
	LDA (GNCBPT),Y
	ROR A
	BCS GTFCH
	LDX #1;FREE AREA SO FOOL INTO THINKING ITS END
	BNE GTFSP
.GTFCH
	ROR A
	BCS GTFNX
	LDY #CBAGE
	LDA (GNCBPT),Y
	CMP CBSTA
	BCC GTFNX
	STA CBSTA
.GTFSP
	LDA GNCBPT
	STA CBTPPT
	LDA GNCBPT + 1
	STA CBTPPT + 1
.GTFNX
	DEX
	BEQ GTFND
	JSR ADGNCB
	JMP GTFLP;LOOK AT NEXT ENTRY
.GTFND
	LDA CBTPPT;CHECK IF ANYTHING FOUND
	ORA CBTPPT + 1
	BEQ GTFNG
	LDA CBTPPT;SAVE ADDRESS
	STA GNCBPT
	LDA CBTPPT + 1
	STA GNCBPT + 1
	LDY #CAFLG;CHECK IF ALLOCATED
	LDA (GNCBPT),Y
	ROR A
	BCC GTFEND
	ROR A
	ROR A;CHECK IF IT HAS BEEN WRITTEN TO
	BCC GTFEND
	JSR WRBLK
	BEQ GTFEND
	LDA #1
	ORA ERRTYP
	STA ERRTYP
.GTFEND
	LDA #0
	LDY #CAFLG
	STA (GNCBPT),Y
	RTS
.GTFNG
	LDA #MPERRM;FLAG ERROR
	RTS
}
	;
	; SET THE WRITTEN BIT IN THE GIVEN CACHE DESCRIPTOR
	; THE STORE ADDRESS IS GIVEN
	;
	; ON ENTRY
	;     GNCBPT POINTS TO RELEVANT CACHE DESCRIPTORS
	;     NCBDB  HOLDS NUMBER OF DESCRIPTORS
	;     CBSTA  HOLDS STORE ADDRESS OF BLOCK
	;
	; ON EXIT
	;     Z NON-ZERO IF FAILED
	;
	;
.CASTWB
{
	LDX NCBDB;GET NUMBER OF DESCRIPTORS
.CSWCN
	LDY #CBSA;CHECK ADDRESS
	LDA (GNCBPT),Y
	CMP CBSTA
	BNE CSWSK;GO TO CHECK NEXT
	INY
	LDA (GNCBPT),Y
	CMP CBSTA + 1
	BEQ CSWF
.CSWSK
	DEX ;CHECK FOR END
	BEQ CSWNF
	JSR ADGNCB
	JMP CSWCN
.CSWF
	LDY #CAFLG
	LDA (GNCBPT),Y;SET WRITTEN BIT
	ORA #4;WRITTEN BIT
	STA (GNCBPT),Y
	LDY #CBAGE
	LDA #0;SUCCESS
	STA (GNCBPT),Y
	RTS
.CSWNF
	LDA #1
	RTS ;NOT FOUND
}
	;
	; ENSURE ALL CACHED BLOCKS
	;
	; ON ENTRY
	;     GNCBPT POINTS TO CACHE DESCRIPTORS
	;     NCBDB  HOLDS NUMBER OF DECRIPTORS
	;
.ENSBKS
{
	LDX NCBDB;NUMBER
.EBLP
	LDY #CAFLG
	LDA (GNCBPT),Y
	AND #4;WRITTEN FLAG
	BEQ EBSK;DON'T WRITE OUT IF NOT WRITTEN
	TXA
	PHA
	LDY #CBSA
	LDA (GNCBPT),Y
	STA GENPTR
	INY
	LDA (GNCBPT),Y
	STA GENPTR +1
	LDY #16
.EBCHLP
	LDA (GENPTR),Y;SAVE SOME OF BLOCK
	STA DATARA,Y
	DEY
	BPL EBCHLP
	JSR WRBLK
	BEQ EBR1
.EBJ1
	LDA #1
	ORA ERRTYP
	STA ERRTYP
	BNE EBJ2
.EBR1
	JSR CHECKB
.EBJ2
	PLA
	TAX
.EBSK
	JSR ADGNCB
	DEX
	BNE EBLP
	RTS
}
	;
	; CHECK BLOCK JUST WRITTEN FOR VALIDITY
	;
.CHECKB
{
	JSR RDBLK
	BNE CBRDER
	LDY #CBSA
	LDA (GNCBPT),Y
	STA GENPTR
	INY
	LDA (GNCBPT),Y
	STA GENPTR +1
	LDY #16
.CBCHLP
	LDA (GENPTR),Y
	CMP DATARA,Y
	BNE CBCMER
	DEY
	BPL CBCHLP
	RTS
.CBCMER
	LDA #&F8
	JSR INTERR
.CBRDER
	CLC
	RTS
}
	;
	; MAKE GNCBPT POINT TO NEXT ENTRY
	;
.ADGNCB
{
	CLC
	LDA GNCBPT
	ADC #CBSZ
	STA GNCBPT
	BCC ADGJ
	INC GNCBPT + 1
.ADGJ
	RTS
}
	
	;
	; MARK WRITTEN BIT IN SPECIFIED CACHE DESCRIPTOR
	;
	; ON ENTRY
	;     MPBLOK POINTS TO ADDRESS IN MEMORY
	;
.MBMWT
{
	LDA MPBLOK
	STA CBSTA
	LDA MPBLOK + 1
	STA CBSTA + 1

	LDA BMCBPT;GET POINTERS TO BIT MAP
	STA GNCBPT
	LDA BMCBPT + 1
	STA GNCBPT + 1
	LDA #NOBTMP
	STA NCBDB
	JSR CASTWB
	BEQ MBMWND
	LDA #&F5
	JSR INTERR
.MBMWND
	RTS
}
	;
	; MARK WRITTEN BIT IN SPECIFIED MAP BLOCK
	;
	; ON ENTRY
	;      CBSTA POINTS TO MAP BLOCK
	;
	;
.MMBWT
	LDA CBSTA
	STA GNCBPT
	LDA CBSTA + 1
	STA GNCBPT + 1
	LDY #MBSQNO
	CLC
	LDA (GNCBPT),Y
	ADC #1
	STA (GNCBPT),Y
	CLC
	LDA GNCBPT
	ADC #LO(LSTSQ)
	STA GNCBPT
	LDA GNCBPT + 1
	ADC #HI(LSTSQ)
	STA GNCBPT + 1
	LDY #0
	CLC
	LDA (GNCBPT),Y
	ADC #1
	STA (GNCBPT),Y
	JSR SETMB
	JMP CASTWB
	;
	; ENSURE BIT MAPS
	;
.ENSBM
	LDA BMCBPT
	STA GNCBPT
	LDA BMCBPT + 1
	STA GNCBPT + 1
	LDA #NOBTMP
	STA NCBDB
	JMP ENSBKS
	;
	; ENSURE MAP BLOCKS
	;
.ENSMB
	JSR SETMB
	JMP ENSBKS
	;
	; FIND THE SPECIFIED MAP BLOCK
	;
	; CBSIN HOLDS THE SIN
	;
	; C SET IF FOUND
	;
.FNDMB
	LDA MBCBPT
	STA GNCBPT
	LDA MBCBPT + 1
	STA GNCBPT + 1
	LDA #NOMPBK
	STA NCBDB
	JMP FNDBLK
	;
	; LOCK IN STORE
	;
	; BLOCK WHOSE STORE ADDRESS IS IN CBSTA
	; GNCBPT POINTS TO CACHE BLOCKS
	; NCBDB NUMBER OF DESCRIPTORS
	;
	; NON-ZERO IF NOT FOUND
	;
.LOCKIS
{
	LDX NCBDB
.LCLP
	LDY #CBSA
	LDA (GNCBPT),Y
	CMP CBSTA
	BNE LCNX
	INY
	LDA (GNCBPT),Y
	CMP CBSTA + 1
	BEQ LCFND
.LCNX
	JSR ADGNCB
	DEX
	BNE LCLP
	LDA #1
	RTS
.LCFND
	LDY #CAFLG
	LDA (GNCBPT),Y
	ORA #2;LOCK IN STORE
	STA (GNCBPT),Y
	LDA #0
	RTS
}
	;
	; UNLOCK ALL BLOCKS
	;
	; NCBDB HOLDS NUMBER OF BLOCKS
	; GNCBPT POINTS TO LIST
	;
.UNLKBS
{
	LDX NCBDB
	LDY #CAFLG
.ULLP
	LDA (GNCBPT),Y
	AND #&FD;UNLOCK BLOCK
	STA (GNCBPT),Y
	JSR ADGNCB
	DEX
	BNE ULLP
	RTS
}
	;
	;
	; MARK MAP BLOCK LOCKED
	;
	; MPMBPT HOLDS STORE ADDRESS OF MAP BLOCK
	; NON-ZERO IF FAILED
	;
.MMBLKD
	JSR SETMB
	LDA MPMBPT
	STA CBSTA
	LDA MPMBPT + 1
	STA CBSTA + 1
	JMP LOCKIS
	;
	; MARK BIT MAP LOCKED
	;
	; MPBLOK POINTS TO BIT MAP
	;
	;
.MBMLKD
	JSR SETBM
	LDA MPBLOK
	STA CBSTA
	LDA MPBLOK + 1
	STA CBSTA + 1
	JMP LOCKIS
	;
	; UNLOCK ALL MAP BLOCKS
	;
.ULMB
	JSR SETMB
	JMP UNLKBS
	;
	; UNLOCK ALL BIT MAPS
	;
.ULBM
	JSR SETBM
	JMP UNLKBS
	;
	; SET VALUES FOR BIT MAP
	;
.SETBM
	LDA BMCBPT
	STA GNCBPT
	LDA BMCBPT + 1
	STA GNCBPT + 1
	LDA #NOBTMP
	STA NCBDB
	RTS
	;
	; SET VALUES FOR MAP BLOCKS
	;
.SETMB
	LDA MBCBPT
	STA GNCBPT
	LDA MBCBPT + 1
	STA GNCBPT + 1
	LDA #NOMPBK
	STA NCBDB
	RTS


;.LNK
;UADE14
;
