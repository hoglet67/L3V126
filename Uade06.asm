;.OPT
;UADE06;FILE > Uade06
;.TTL
;Fileserver file UADE06

.UADE06

	;**********************************
	;*           U S R M A N          *
	;**********************************

	;USRMAN: USRMAN (THE USER TABLE MANAGER)
	;KEEPS INFORMATION ABOUT LOGGED ON USERS.
	;USRMAN MAINTAINS A DATA STRUCTURE
	;KNOWN AS THE USERTB. THIS TABLE
	;CONTAINS INFORMATION ABOUT WHICH
	;USERS ARE LOGGED ON, THE
	;NUMBER OF THE MACHINE, HANDLES
	;FOR UFD & CURRENTLY SELECTED DIRECTORY,
	;AND OTHER USER STATE INFORMATION.

	;THE USERTB CONTAINS THE FOLLOWING INFO:-
	;0) MACHINE NUMBER (2 BYTES)
	;1) USERID (4 BYTES)
	;2) CURRENT SELECTED DISC NUMBER (2 BYTES)
	;3) SYSTEM PRIVILEGE FLAG
	;4) HANDLE FOR UFD (USER FILE DIR) (1 BYTE)
	;5) HANDLE FOR SELECTED DIR
	;6) HANDLE BYTE (A RECORD OF WHICH HANDLES ARE INUSE)


	;************ MAIN ROUTINE ************


.USRMAN
{
	LDX #10;USRMAN HAS 10 ENTRY POINTS
	LDA #MODUSR;A:=NAME OF THIS MODULE
	JSR ENTRY
	LDA USRTNS,X
	STA USJUMP + 1
	LDA USRTNS + 1,X
	STA USJUMP + 2
	LDA #15
	JSR SETFS
.USJUMP
	JMP USJUMP
.*USEXIT
	JMP EXIT	;MM WAS PREXIT
.USRTNS
	EQUW USNWMC;1 => REGISTER A MACHINE(LOGON)
	EQUW USDLMC;2 => DELETE MACHINE FROM USERTB(LOGOFF)
	EQUW USSDSC;3 => SELECT DISC
	EQUW USREST;4 => RESTART
	EQUW USSDIR;5 => SELECT DIRECTORY
	EQUW USUSER;6 => USER INFO (PRIV & MC/NO OF GIVEN USERID)
	EQUW USUSRS;7 => LOGGED ON USERS
	EQUW USQUIT;8 => update all users free space ** 3/10/84 **
	EQUW USFREE;9 => update single user allocation
	EQUW USLOFF;10 => LOG OFF ALL USERS
}

	;************ USNWMC ************

	;USNWMC: USRMAN.NEW MACHINE (LOGON)
	;ENTRY: ARGB,C,D = (MC/NO)
	;ARGE,F = (PTR TO USERID FOLLOWED BY PASSWORD)

	;EXIT : ARGA = RC
	;ARGB,C = (PTR TO USERINFO)
	;ARGD = UFD HANDLE
	;ARGE = CSD HADLE
	;ARGF = LIB HANDLE
	;ARGG = Option bits (bottom two)
	;ARGH = Privilege ** 27/9/84 **

	;FUNCTION: -

	;IF machine already in USERTB (I.E. LOGGED ON)
	;THEN close all open files,
	;close all open dirs;
	;remove USERTB entry
	;FI;

	;check validity of password;read option bits

	;FOR each drive WHILE NOT found
	;DO IF $.USERID exists
	;THEN get handles for ufd, library and selected dir;
	;found := TRUE
	;FI
	;OD;

	;IF NOT found
	;THEN use root dir for ufd, library & selected dir
	;FI

.USNWMC
{
	JSR CHKMC;LOGGED ON ?
	BEQ USNLGO

	;FIND A FREE USERTB ENTRY

	LDA MCTEMP;MCTEMP SET BY CHKMC
	ORA MCTEMP + 1
	ORA MCTEMP + 2
	BNE USNWC
	
	LDA #URERRF;RC:=M/C NUMBER = ZERO
	BNE USNWY1
	
.USNLGO
	JSR LOGOFF

	;CHECK PASSWORD

.USNWC
	LDA #2;AUTMAN.CHECKPW
	JSR SETRTN

	LDY #ARGF
	LDA (ARGPTR),Y
	DEY	;Y:= ARGE
	STA (NEWARG),Y;LS(PTR TO USERID FOLLOWED BY PW)

	LDA (ARGPTR),Y
	DEY ;Y:= ARGD
	STA (NEWARG),Y;MS(PTR TO USERID)
	
	JSR AUTMAN
	BNE USNWY1

	JSR INITUS;USTPTR:=USERTB,X:=USERS
	LDY #UTPRIV
.USNWB
	LDA (USTPTR),Y;HOLDS THE INUSE FLAG
	BEQ USNWCA
	JSR INCUST
	BNE USNWB
.USSYSX
	LDA #URERRB;RC:=USERTB FULL
.USNWY1
	JMP USNWY

	;SETUP USERTB ENTRY

.USNWCA
	LDY #ARGF
	LDA (NEWARG),Y;Read PW Flag byte
	STA USTEMP;Store so can return option bits
	ORA #INUSE;and mark in use.
	LDY #UTPRIV
	STA (USTPTR),Y;:= INUSE + SYSTEM PRIV FLAG
	
	LDA MCTEMP;(MCTEMP SET BY CHKMC)
	LDY #UTMCNO
	STA (USTPTR),Y
	LDA MCTEMP + 1
	INY
	STA (USTPTR),Y;MACHINE NUMBER
	LDA MCTEMP + 2
	INY
	STA (USTPTR),Y
	
	LDA #ARGB;copy disc space into table
	STA OFF1
	LDA #UTFREE
	STA OFF2
	LDX #NEWARG
	LDY #USTPTR
	LDA #UTFRLN
	JSR MOVBLK;** 2/10/84 **

	LDY #ARGE
	LDA (ARGPTR),Y
	STA MOVFRM
	INY ;Y:= ARGF
	LDA (ARGPTR),Y
	STA MOVFRM + 1
	CLC
	LDA USTPTR
	ADC #UTUSID
	STA MOVTO
	LDA USTPTR + 1
	ADC #0
	STA MOVTO + 1
	LDX #UTDISC-UTUSID
	JSR MOVE;COPY USERID INTO USERTB

	LDA #0
	LDY #UTHNDB
	STA (USTPTR),Y

	;NOW TRY TO FIND A UFD FOR THIS USER
	;SO TRY TO RETRIEVE $.USERID BY SEARCHING ALL THE DRIVES

	LDA #&FF
	STA USWORK + 1;USWORK := O := DEVICE NO
	STA USWORK

	LDY #ARGG
	LDA (NEWARG),Y
.USNWF
	JSR DRVINF;MAPMAN.DRIVEINFO
	BNE USNWMD ;///** 18/9/84 **
	
	BIT USWORK + 1
	BPL USNWK
	LDA USWORK
	STA USWORK + 1

.USNWK
	JSR SUSRDI;Set users disc no.
	JSR GETUFD;GET HANDLES FOR UFD
	BEQ USNWY

	;havn't matched full name here, so see about partial match
	;** 18/9/84 **

	LDY #MAXID+UTUSID+1;look for a "."
.USNWMA
	LDA (USTPTR),Y
	CMP #SEPART
	BEQ USNWMB
	DEY
	CPY #UTUSID
	BNE USNWMA;look right through the string
	BEQ USNWMD

.USNWMB
	LDA #TERMIN;abbreviate the name string
	STA (USTPTR),Y
	TYA
	PHA ;save pointer across call

	LDA USWORK
	JSR DRVINF;get drive info
	JSR SUSRDI;set up the info
	JSR GETUFD
	TAX ;save RC

	PLA
	TAY
	LDA #SEPART
	STA (USTPTR),Y;restore the string to its former glory

	TXA ;restore RC
	BEQ USNWY;all ok here

.USNWMD
	INC USWORK;USWORK +:=1

	;try next logical drive
	LDA USWORK
	CMP DRIVES
	BCC USNWF
	LDA USWORK + 1
	


	;IF A UFD DOES NOT EXIST ON ANY DISC THEN
	;MAKE UFD := SELECTED DIR := ROOT DIR ON THE
	;DISC ON DRIVE ZERO

	JSR DRVINF
	JSR SUSRDI;Set user disc no.
	JSR GTROOT
	BEQ USNWY
	JSR LOGOFF;CLEAN UP if no dirs available

.USNWY
	LDY #ARGB
	PHA ;Store return code
	LDA USTPTR
	STA (ARGPTR),Y
	INY
	LDA USTPTR + 1
	STA (ARGPTR),Y
	INY
	JSR MOVHND
	LDA USTEMP;Read PW flag byte
	PHA
	AND #OPTMSK;Mask off option bits
	LDY #ARGG
	STA (ARGPTR),Y
	PLA
	INY
	AND #SYSTPV;** 27/9/84 **
	STA (ARGPTR),Y;return user's privilege
	PLA ;Restore return code
	JMP USEXIT
}

.SUSRDI
	LDY #ARGB
	LDA (NEWARG),Y
	LDY #UTDISC
	STA (USTPTR),Y
	LDY #ARGC
	LDA (NEWARG),Y
	LDY #UTDISC + 1
	STA (USTPTR),Y;DISC NUMBER
	RTS


	;************ USDLMC ************


	;USDLMC: DELETE USERTB ENTRY FOR GIVEN MACHINE NUMBER

	;ENTRY: ARGB = LS(PTR TO USERINFO)
	;ARGC = MS(PTR TO USERINFO)

	;EXIT:  ARGA = RC

	;FUNCTION: FIND USERTB ENTRY AND MARK IT NOT IN USE.


.USDLMC
	JSR SETUTP
	JSR LOGOFF
	LDA #0
.USDLMX
	JMP USEXIT



	;************ USSDSC ************


	;USSDSC: USRMAN.SELECT DISC

	;ENTRY: ARGB = LS(PTR TO USERINFO)
	;ARGC = MS(PTR TO USERINFO)
	;ARGD = LS(DISC NO)
	;ARGE = MS(DISC NO)
	;ARGF = CURRENT UFD HANDLE
	;ARGG = CURRENT CSD HANDLE
	;ARGH = CURRENT LIB HANDLE

	;EXIT : ARGA = RC
	;ARGB = NEW UFD
	;ARGC = NEW CSD
	;ARGD = NEW LIB

	;FUNCTION:-
	;IF specified disc loaded
	;THEN close ufd, library & selected dir;
	;IF $.USERID exists on selected dir;
	;THEN get handles for ufd, library & selected dir
	;ELSE ufd:=selected dir:=library:=root dir
	;FI


.USSDSC
{
	JSR SETUTP;SETUP USTPTR TO POINT INTO USERTB

	;FIRST, SEE WHETHER SPECIFIED DISC IS LOADED

	LDY #ARGD
	LDA (ARGPTR),Y
	STA USDISC
	INY
	LDA (ARGPTR),Y
	STA USDISC + 1;USDISC:=SELECTED DISC NUMBER

	LDY #ARGC
	STA (NEWARG),Y
	DEY ;Y:=ARGB
	LDA USDISC
	STA (NEWARG),Y
	DEY ;Y:= ARGA
	LDA #4;MAPMAN.SINOFROOT
	STA (NEWARG),Y
	JSR MAPMAN
	BNE USSDCY

	;NOW CLOSE THREE HANDLES FOR
	;OLD DISC

	LDY #ARGF
	LDA (ARGPTR),Y
	JSR CLOSE
	BNE USSDCY
	LDY #ARGG
	LDA (ARGPTR),Y
	JSR CLOSE
	BNE USSDCY
	LDY #ARGH
	LDA (ARGPTR),Y
	JSR CLOSE
	BNE USSDCY
	;PUT SELECTED DISC NUMBER INTO THE USERTB

	LDY #UTDISC
	LDA USDISC
	STA (USTPTR),Y
	INY
	LDA USDISC + 1
	STA (USTPTR),Y

	;SEE IF A UFD EXISTS IN THE ROOT DIR FOR THIS USER

	JSR GETUFD
	BEQ USSDCY

	;OTHERWISE MAKE THE ROOT DIR THE UFD, LIB  & SELECTED DIR

	JSR GTROOT

.USSDCY
	LDY #ARGB
	JSR MOVHND;PUT HANDLES ON STACK
	JMP USEXIT
}


	;************ USREST ************


	;USREST: RESTART
	;1) CALL GETVEC TO GRAB AN AREA
	;OF STORE FOR THE USERTB.
	;2) SETUP THE VARAIBLE (USERTB)
	;TO POINT TO THIS AREA.
	;3) CALL CLRSTR TO INITIALISE THE
	;WHOLE TABLE TO ZERO.


.USREST
	LDX USERS
	LDY #UTENSZ
	JSR SETTAB
	STY USERTB
	STX USERTB + 1
	LDA #0
	STA USSYS;priv'd user logged-on flag
	JMP USEXIT



	;************ USSDIR ************


	;USSDIR: USRMAN.SELECT DIRECTORY

	;ENTRY: ARGB = LS(PTR TO USERINFO)
	;ARGC = MS(PTR TO USERINFO)
	;ARGD = LS(PTR TO DIR TITLE)
	;ARGE = MS(PTR TO DIR TITLE)
	;ARGF = UFD HANDLE
	;ARGG = CURRENT SEL. DIR. HND

	;EXIT : ARGA = RC
	;ARGB = HANDLE FOR NEW CSD

	;FUNCTION:-

	;IF dir title = null string
	;THEN make the current selected dir=ufd
	;ELIF directory exists
	;THEN open selected dir;
	;close old selected dir
	;ELSE return error
	;FI


.USSDIR
{
	JSR SETUTP;SETUP USTPTR

	LDY #ARGF
	LDA (ARGPTR),Y
	STA UMHUFD
	INY
	LDA (ARGPTR),Y
	STA UMHCSD
	;FIRST, RETRIEVE THE DIRECTORY

	LDY #ARGD
	LDA (ARGPTR),Y
	STA TITPTR
	STA GENPTR
	INY
	LDA (ARGPTR),Y
	STA TITPTR + 1;TITPTR := ADDR OF DIR NAME
	STA GENPTR + 1;GENPTR := PTR TO DIR TITLE

	LDY #0
	LDA (GENPTR),Y
	CMP #TERMIN
	BNE USSDRK

	;NOW CALL RNDMAN TO CREATE A COPY OF THE HANDLE
	;FOR THE UFD.

	LDA UMHCSD
	JSR CLOSE;CLOSE OLD SELECTED DIR.
	BNE USSDRY

	LDA #5;RNDMAN.COPY
	JSR SETUSB
	INY;Y:=ARGD

	LDA UMHUFD;SET USER ROOT TO COPY
	STA (NEWARG),Y;= HANDLE OF UFD
	JSR RNDMAN;RNDMAN.COPY
	BNE USSDRY

	LDY #ARGE
	LDA (NEWARG),Y;HANDLE FROM RNDMAN
	JMP USSDRW

.USSDRK
	LDA #&C1;accept all wild cards
	JSR RETRV;CALL DIRMAN.RETRV & CHECK THAT ITS A DIR
	BNE USSDRY

	;NOW GET A HANDLE FOR IT

	JSR OPEN;USRHND:=HANDLE FOR NEW SELECTED DIR
	BNE USSDRY
	PHA

	;NOW CLOSE THE OLD SELECTED DIR

	LDA UMHCSD
	JSR CLOSE
	BNE USSDRZ;If this close fails, close new one too
	PLA

.USSDRW
	LDY #ARGB
	STA (ARGPTR),Y;Set new handle
	LDA #0

.USSDRY
	JMP USEXIT
.USSDRZ
	STA TEMPA;Store rcode
	PLA ;Pull new csd
	JSR CLOSE;Close it
	LDA TEMPA;Restore rcode
	BNE USSDRY;End
}


	;************ USUSER ************


	;USUSER: USER INFO

	;ENTRY: ARGB=LS(PTR TO USERINFO)
	;ARGC = MS(PTR TO USERINFO)
	;ARGD = LS(PTR TO USERID)
	;ARGE = MS(PTR TO USERID)

	;EXIT : ARGA = RC
	;       ARGB = USER PRIVILEDGE
	;       ARGC,D,E = MACHINE NUMBER
	;       ARGF,G = pointer to userid information ** 5/10/84 **


.USUSER
{
	JSR INITUS
	LDY #ARGD
	LDA (ARGPTR),Y
	STA URMPPT;Pointer to User Id to check
	INY
	LDA (ARGPTR),Y
	STA URMPPT + 1

.USUSRB
	LDY #UTPRIV;Check if entry in use
	LDA (USTPTR),Y
	BPL USUSRF;Nope -> continue

	;NOW SEE IF USERIDS MATCH

	LDA #UTUSID
	STA OFF2;Offset in user-table
	LDY #0;Offset of argument name

.USUSRC
	LDA (URMPPT),Y
	STY OFF1
	CPY #21;Max user length
	BNE USUSRE;Not at end yet -> go on

	CMP #TERMIN;At end, check user name given is terminated
	BEQ USUSRQ;Yes -> found
	BNE USUSRF;No -> continue search

.USUSRE
	LDY OFF2
	EOR (USTPTR),Y
	INC OFF2;Increment USTPTR offset for next time
	AND #&DF;Complete comparison
	BNE USUSRF;Not the same -> go on to next one

	LDY OFF1;Point to char. offset from USTPTR
	LDA (URMPPT),Y;The same => check if end of string
	INY ;Increment for next time

	CMP #TERMIN
	BNE USUSRC;Not terminators => continue search

	;FOUND IT - SO COPY PRIV & MC/NO INTO STACK

.USUSRQ
	LDY #UTPRIV
	LDA (USTPTR),Y
	AND #(SYSTPV OR TYPE)
	LDY #ARGB
	STA (ARGPTR),Y;SYSTEM PRIV FLAG

	LDY #UTMCNO
	LDA (USTPTR),Y
	LDY #ARGC
	STA (ARGPTR),Y
	LDY #UTMCNO + 1
	LDA (USTPTR),Y
	LDY #ARGD
	STA (ARGPTR),Y;MC/NO
	LDY #UTMCNO + 2
	LDA (USTPTR),Y
	LDY #ARGE
	STA (ARGPTR),Y
		
	INY;Y:=ARGF
	LDA USTPTR
	STA (ARGPTR),Y
	INY;Y:=ARGG
	LDA USTPTR+1
	STA (ARGPTR),Y;** 5/10/84 **

	LDA #0
	BEQ USUSRY

.USUSRF
	JSR INCUST
	BNE USUSRB
	LDA #URERRE
.USUSRY
	JMP USEXIT
}

	;**************** USUSRS ************

	;ENTRY: ARGB = Start entry
	;ARGC = No. of entries
	;ARGD/E = Result buffer
	;ARGF = PRIV of caller

	;EXIT : ARGB = No. of entries found
	;ARGC/D = Result end ptr.

	;V. similar to examine and discs. Given entry point
	;to list of users and number of entries required,
	;supplies info. on as many as possible, returning
	;the number found and a pointer to the byte after
	;the info. for use in transmitting the data
	;out to client.


.USUSRS
{
	JSR INITUS;Set USTPTR and X
	LDY #ARGB
	LDA (ARGPTR),Y
	STA TEMPA;Start entry
	INY
	LDA (ARGPTR),Y
	STA TEMPA + 1;No. of entries wanted
	INY
	LDA (ARGPTR),Y
	STA GENPTR;Result ptr.
	INY
	LDA (ARGPTR),Y
	STA GENPTR + 1

	LDA #&FF
	STA TEMPB;Entry pt. counter
	LDA #0
	STA TEMPB + 1;No. of entries found

.USURLA
	LDY #UTPRIV

	;First loop round finding entries in use until
	;ENTRY = TEMPA = START ENTRY

	LDA (USTPTR),Y; ** LABLE REMOVE 14/1/86 **
	BPL USURLB;Not in use, don't count

	;** skip privileged users (27/9/84)
	;** Report PRIV users only to a PRIV request **
	;*** LH 14/1/86 ***
	AND #SYSTPV; They are loged on so should appear LH 21/10/85
	BEQ USRLHA; Not priv so exist
	LDY #ARGF; PRIV entry so test priv of caller
	LDA (ARGPTR),Y

	BEQ USURLB; Skip to next entry

.USRLHA
	INC TEMPB;Inc. current entry
	LDA TEMPB
	CMP TEMPA;Current >= start entry ?
	BCS USURLC;Yes => start copying to result

.USURLB
	JSR INCUST;Jump to next entry
	BNE USURLA;If not off end of table, do again
	BEQ USURLX;Otherwise, finish

.USURLC
	TXA
	PHA
	LDX #0
	LDY #UTMCNO
	LDA (USTPTR),Y
	STA (GENPTR,X)
	INY
	JSR INCGPT
	LDA (USTPTR),Y
	STA (GENPTR,X);Set m/c number
	INY
	JSR INCGPT
	LDA (USTPTR),Y
	LSR A
	LSR A
	LSR A
	STA (GENPTR,X)
	
	LDY #ARGG
	LDA (ARGPTR),Y
	BNE USURLJ

	JSR INCGPT

.USURLJ
	LDY #UTUSID;User id. offset
.USURLD
	LDA (USTPTR),Y
	STA (GENPTR,X)
	JSR INCGPT
	CMP #CR;Is terminated ??
	BEQ USURLF

	INY
	CPY #UTUSID+MAXUNM;Finished ?
	BNE USURLD;** 23/4/85 **

	LDA #CR;If 10 chars long, terminate with zero
	STA (GENPTR,X)
	JSR INCGPT;** 23/4/85 **

.USURLF
	LDY #UTPRIV;Get priviledge byte
	LDA (USTPTR),Y
	AND #SYSTPV
	STA (GENPTR,X)
	JSR INCGPT;Point to next entry
	PLA
	TAX ;Restore table entry count

	INC TEMPB + 1;Inc. no. found
	LDA TEMPA + 1
	CMP TEMPB + 1;No. found = no. requested ?
	BEQ USURLX;Yes => stop

	JSR INCUST;Step through table
	BNE USURLA;Do again


.USURLX
	LDY #ARGB
	LDA TEMPB + 1
	STA (ARGPTR),Y
	INY
	LDA GENPTR
	STA (ARGPTR),Y
	INY
	LDA GENPTR + 1
	STA (ARGPTR),Y
	LDA #0
	JMP USEXIT
}


	;*******************

.USQUIT
{
	JSR INITUS;setup USTPTR
.USQULA
	LDY #UTPRIV;scan for inuse entries
	LDA (USTPTR),Y
	BEQ USQULB
	TXA ;preserve X over LOGOFF call
	PHA
	JSR USENS;ensure all free space entries up to date
	PLA
	TAX
.USQULB
	JSR INCUST
	BNE USQULA
	JMP USEXIT;end of routine
}

.USFREE
	;ROUT;** 6/2/85 **
{
	LDA USTPTR
	PHA
	LDA USTPTR+1
	PHA ;save this value over call

	JSR INITUS;update all incarnations of a user free space
	STX USTEMP;save counter

.N10
	LDY #ARGB
	LDA (ARGPTR),Y
	STA GENPTR
	INY
	LDA (ARGPTR),Y
	STA GENPTR+1;pointer to supplied name

	LDY #UTPRIV
	LDA (USTPTR),Y
	BPL N50;not in use so skip

	LDX #0
	LDY #UTUSID
.N20
	LDA (USTPTR),Y
	EOR (GENPTR,X)
	AND #&DF
	BNE N50
	LDA (USTPTR),Y
	CMP #TERMIN
	BEQ N40;end of name

	INC GENPTR
	BNE N30
	INC GENPTR+1

.N30
	INY
	CPY #MAXID+UTUSID+1
	BNE N20;continue

.N40
	LDA #ARGD;update the free space
	STA OFF1
	LDX #ARGPTR
	LDA #UTFREE
	STA OFF2
	LDY #USTPTR
	LDA #4;arguments supplied on stack
	JSR MOVBLK

.N50
	JSR INCUST
	DEC USTEMP
	BNE N10;not end of table

	PLA
	STA USTPTR+1
	PLA
	STA USTPTR

	LDA #0
	JMP USEXIT
}

	;LOG OFF ALL USERS
.USLOFF
{
	JSR INITUS
	LDA #0
	PHA
	
.USLOLP
	LDY #UTPRIV
	LDA (USTPTR),Y
	BPL USLOSK;NOT IN USE
	
	PLA
	TAY
	TXA
	PHA
	TYA
	JSR LOGOFF
	TAY
	PLA
	TAX
	TYA
	PHA

.USLOSK
	JSR INCUST
	BNE USLOLP
	
	PLA
	JMP USEXIT
}


.SETUTP
	LDY #ARGB;SETUP USTPTR
	LDA (ARGPTR),Y
	STA USTPTR
	INY
	LDA (ARGPTR),Y
	STA USTPTR + 1
	RTS


.CHKMC
	LDY #ARGB;SEE IF MACHINE LOGGED ON
	LDA (ARGPTR),Y
	STA MCNUMB;N.B. USE MCTEMP BECAUSE MCNUMB IS USED GLOBALLY
	STA MCTEMP;=LS(MC/NO)
	INY;Y:=ARGC
	LDA (ARGPTR),Y
	STA MCNUMB + 1
	STA MCTEMP + 1;=MS(MC/NO)
	INY;Y:=ARGD
	LDA (ARGPTR),Y
	STA MCNUMB + 2
	STA MCTEMP + 2	
	
	JMP FINDMC


.RETRV
{
	LDY #ARGH;A passed in call
	STA (NEWARG),Y;wild card flag

	;RETRIEVE DIR FOR USRMAN
	LDA #2;DIRMAN.RETRIEVE
	JSR SETUSB;MOVE USTPTR ONTO NEWARG STACK
	INY;Y:=ARGD
	LDA TITPTR
	STA (NEWARG),Y
	INY
	LDA TITPTR + 1
	STA (NEWARG),Y;PTR TO DIR NAME
	INY
	LDA #LO(USRINF)
	STA (NEWARG),Y
	INY
	LDA #HI(USRINF);ADDRESS OF DETAILS AREA
	STA (NEWARG),Y
	JSR DIRMAN
	BNE RETRVZ
	LDY #ARGB
	LDA (NEWARG),Y
	STA USRACC;USRACC:=ACCESS TO OBJECT
	AND #TYPDIR
	BNE RETRVX
	LDA #URERRD;RC:=OBJECT NOT A DIR
	RTS
.RETRVX
	LDA #0;RC := 0
.RETRVZ
	RTS
}

.SETUID
{
	LDY #UTUSID;Copy userid from USERTB to USRUFD
.SETUIL
	LDA (USTPTR),Y;Copies all chars regardless of termination
	STA USRUFD -UTUSID,Y
	INY
	CPY #UTUSID +MAXUNM
	BNE SETUIL
	RTS
}

.MAKHDS
{
	JSR OPEN;MAKE HANDLES FOR UFD & SELECTED DIR
	BNE MAKHSZ

	;MAKE THIS THE HANDLE FOR THE UFD

	STA UMHUFD
	LDY #UTHUFD
	STA (USTPTR),Y

	;NOW GET A HANDLE FOR SELECTED DIR

	JSR OPEN
	BEQ MAKHSG
	PHA
	JSR CLUFDR;CLOSE UFD
	PLA
	RTS
.MAKHSG
	STA UMHCSD
	LDA #0

.MAKHSZ
	RTS
}


.OPEN
{
	;CALL RNDMAN.OPEN FOR DIR IN USRINF
	LDA #1;RNDMAN.OPEN
	JSR SETUSB;COPY USTPTR ONTO NEWARG STACK
	INY ;Y:=ARGD
	LDA #0;MODE := 0
	STA (NEWARG),Y
	INY ;Y:=E
	LDA USRACC
	STA (NEWARG),Y
	INY ;Y:=ARGF
	LDA #LO(USRINF)
	STA (NEWARG),Y
	INY
	LDA #HI(USRINF)
	STA (NEWARG),Y;PTR TO OBJECT DETAILS
	JSR RNDMAN
	BNE OPENZ
	LDY #ARGB
	LDA (NEWARG),Y
	LDY #0
.OPENZ
	RTS
}


.SETUSB
	JSR SETRTN
.SETUSR
	LDY #ARGB;MOVE USTPTR ONTO NEWARG STACK
.SETUSA
	LDA USTPTR
	STA (NEWARG),Y
	INY;Y:=ARGC
	LDA USTPTR + 1
	STA (NEWARG),Y
	RTS


	;LOGOFF: CLOSE ALL HANDLES OPENED BY M/C & FREE USERTB ENTRY

.LOGOFF
{
	PHA
	LDA #6
	JSR SETUSB
	JSR RNDMAN;*** CLOSE ALL ENTRIES **
	BEQ OFFONA

.LOGFFC
	TAY
	PLA ;Restore stack
	TYA
	RTS

	;NOW CLEAR USERTB ENTRY TO ZERO

.OFFONA
	JSR USENS;update all free space entries
	BNE LOGFFC
	LDY #UTPRIV;check for priv'd user
	LDA (USTPTR),Y;** 27/9/84 **
	AND #SYSTPV
	BEQ OFFONB;not priv'd
	DEC USSYS;decrement counter
.OFFONB
	LDA #0
	TAY
	LDX #UTENSZ;X := UTENSZ
.LOGFFG
	STA (USTPTR),Y
	INY
	DEX
	BNE LOGFFG
	PLA
.LOGFFX
	RTS
}


.USENS
	CLC ;** 2/10/84 **
	LDY #ARGD
	LDA USTPTR
	ADC #LO(UTUSID)
	STA (NEWARG),Y;nb ARGB,C unused here

	INY
	LDA USTPTR+1
	ADC #HI(UTUSID)
	STA (NEWARG),Y

	LDA #UTFREE
	STA OFF1
	LDA #ARGF
	STA OFF2
	LDX #USTPTR
	LDY #NEWARG
	LDA #UTFRLN
	JSR MOVBLK

	LDA #8;ensure free store in PW file
	JSR SETRTN
	JMP AUTMAN


.CLOSE

	PHA
	LDA #3;RNDMAN.CLOSE
	JSR SETUSB;PLACE PTR TO USERINFO ON NEWARG STACK
	INY;Y:=ARGD
	PLA
	STA (NEWARG),Y
	JMP RNDMAN


.CLUFDR
{
	LDA UMHUFD;CLOSE UFD
	BEQ CLUFDZ
	JSR CLOSE
	PHA
	LDA #0
	STA UMHUFD
	PLA
.CLUFDZ
	RTS
}


.CLSLDR
{
	LDA UMHCSD
	BEQ CLSLDZ
	JSR CLOSE
	PHA
	LDA #0
	STA UMHCSD
	PLA
.CLSLDZ
	RTS
}


	;GETUFD: SEE IF THERE IS A UFD IN THE ROOT DIR ON
	;CURRENTLY SELECTED DISC.
	;IF THERE IS A UFD THEN MAKE HANDLES FOR
	;THE UFD & THE CURRENTLY SELCECTED DIRECTORY.
	;ALSO SEARCH FOR LIB. IF FOUND, GET HANDLE
	;FOR IT, IF NOT LIB:=CSD/UFD

	;EXIT: A := RC


.GETUFD
{
	LDA #ROOT
	STA USRROT
	LDA #SEPART
	STA USRSEP
	JSR SETUID;COPY USERID INTO USRUFD
	LDA #TERMIN
	STA USRTER
	LDA #LO(USRROT)
	STA TITPTR
	LDA #HI(USRROT)
	STA TITPTR + 1
	LDA #0;no wild cards here
	JSR RETRV;RETRIEVE OBJECT
	BNE GTROTZ	;GETUFZ
	
	LDA #OWNER
	ORA USRACC;ACCESS TO DIR
	STA USRACC;OWNER ACCESS TO UFD
	BNE GTROTA 

.*GTROOT

	JSR RTROOT
	BNE GTROTZ
	
.GTROTA
	JSR MAKHDS;MAKE HANDLES
	BNE GTROTZ
	JSR GETLBH;LOOK FOR LIB FILE
.GTROTZ
	RTS
}

.RTROOT
	LDA #ROOT
	STA USRROT
	LDA #TERMIN
	STA USRSEP
	LDA #LO(USRROT)
	STA TITPTR
	LDA #HI(USRROT)
	STA TITPTR + 1
	LDA #0;no wild cards here
	JMP RETRV;RETRIEVE ROOT DIR



.GETLBH
{
	;TRY TO RETRIEVE FILE "LIBRARY".
	;IF FOUND, OPEN AND PUT HANDLE
	;IN LIB. LOCATION. IF NOT, OPEN
	;ROOT, WHICH WILL BE LIBRARY

	;** 15/9/83 **

	LDY #UTDISC
	LDA (USTPTR),Y
	PHA
	INY
	LDA (USTPTR),Y
	PHA ;save users disc number
	LDA USTEMP
	PHA ;save

	LDA #0
	STA USTEMP;spare counter
.USJL1
	LDA USTEMP
	JSR DRVINF;drive exists ?
	BNE GTLBON;no
	JSR SUSRDI

	LDA #LO(DEFLIB);PTR. TO LIB. TITLE
	STA TITPTR
	LDA #HI(DEFLIB)
	STA TITPTR + 1

	LDA #0;no wild cards here
	JSR RETRV

	BEQ GTLBOA;OK, FOUND SO OPEN
	CMP #DRERRC
	BNE GTLBAB;IF ERROR NOT "NOT FOUND", ABORT

.GTLBON

	INC USTEMP
	LDA USTEMP
	CMP DRIVES
	BCC USJL1

	;NOW CHECK IF ROOT ALREADY RETRIEVED
	;(IF USING ROOT AS CSD FOR EXAMPLE),
	;AND IF NOT, RETRIEVE. THEN OPEN AND RETURN
	;HANDLE FOR LIB.

	LDY #INFNAM
	LDA USRINF,Y
	CMP #ROOT
	BEQ GTLBOA;Root retrieved, go on

	JSR RTROOT;Otherwise, retrieve
	BNE GTLBAB

.GTLBOA
	JSR OPEN
	BNE GTLBAB;ABORT IF ERROR

	STA UMHLIB;STORE HANDLE
	LDA #0;GIVE Z SET

.GTLBEX
	TAX
	PLA
	STA USTEMP
	LDY #UTDISC + 1;restore the old values
	PLA
	STA (USTPTR),Y
	DEY
	PLA
	STA (USTPTR),Y
	TXA ;restore return code
	RTS

.GTLBAB
	PHA
	JSR CLUFDR
	JSR CLSLDR
	PLA
	BNE GTLBEX

.DEFLIB
	EQUB "$.library",CR
}

.MOVHND
{
	PHA
	INY
	INY
	LDX #2
.MHLOP
	LDA UMHUFD,X
	STA (ARGPTR),Y
	DEY
	DEX
	BPL MHLOP
	PLA
	RTS
}

;.LNK
;RMAN01
