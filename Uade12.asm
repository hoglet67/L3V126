;.OPT
;UADE12;> Uade12
;.TTL
;Fileserver file UADE12

.UADE12

	;** MAPMAP UTILS II(2) **

.SMPPTR;SMPPTR
{
	;SET POINTER TO ENTRY IN MAP TABLE
	;CORRESPONDING TO DRIVE IN CURDRV.
	;POINTER IS IN BOTH MAPPTR AND
	;MAPENT.

	LDX CURDRV
	LDA MAPTB
	STA MAPPTR
	LDA MAPTB + 1
	STA MAPPTR + 1

.SMPPTL
	DEX
	BMI SMPPTX

	JSR MPADMP
	JMP SMPPTL

.SMPPTX
	LDA MAPPTR
	STA MAPENT
	LDA MAPPTR + 1
	STA MAPENT + 1
	RTS
}

	;RDDATA: READ DISC INFO FROM SECTOR 0 INTO
	;STORE STARTING AT ADDRESS IN FREPTR.

	;ENTRY: A = DRIVE NUMBER

	;EXIT:  A = RC

	;FUNCTION: -
	;0) SET FDRIVE, OLDFDR & SELECT & START DRIVE
	;1) SEEK TRACK ZERO
	;2) READ SECTOR 0

	;RDSZRO ENTRY POINT FOR USE WHEN
	;DDRSTA POINTER ALREADY SET UP.

.RDDATA
	LDY FREPTR
	STY DSCCB+TRADD
	LDY FREPTR + 1
	STY DSCCB+TRADD + 1;DDRSTA:=STORE ADDR FOR SECTOR
	LDY #0
	STY DSCCB
	STY DSCCB+TRADD+ 2
	STY DSCCB+TRADD+ 3

.RDSTWO
{
	STA DRIVNO
	
	LDX #9
	LDA #0
	STA RBDA;SECTOR ZERO
.RDDLP2
	STA DSCCB+CMD,X
	DEX
	BPL RDDLP2

	JSR GTDRNO
	STA DSCCB+CMD+ 1
	LDA #&08
	STA DSCCB+CMD

	LDA DSCCB+TRADD
	STA MPCYPT
	LDA DSCCB+TRADD+1
	STA MPCYPT+1

	INC DSCCB+LENGTH+ 1
.RDDLP
	JSR DSCCMD
	BNE RDSEC1
	LDY #SZOFF
	LDA (MPCYPT),Y
	STA DSCCB+CMD+3
	INY
	LDA (MPCYPT),Y
	STA DSCCB+CMD+2
	INY
	JSR GTDRNO
	ORA (MPCYPT),Y
	STA DSCCB+CMD+1
	JSR DSCCMD
	BEQ RDDND
.RDSEC1
	LDY DSCCB;RETURN CODE
	CPY #&65;BAD DRIVE
	BEQ RDDND
	
	LDY RBDA
	BNE RDDND
	INC RBDA
	INC DSCCB+CMD+3
	BNE RDDLP

.RDDND
	TAX
	RTS
}

	;
	; MAKE AN ENTRY IN THE MAP BLOCK
	;
	; ON ENTRY
	;     MKENVA HOLD THE NUMBER OF BLOCKS TO ALLOCATE
	;     MAPTMP POINT TO THE MAP BLOCK
	;
	; ON EXIT
	;     C SET IF FAILED
	;
	; USES
	;     MAPGEN
	;     MPTMPE
	;
.MKEN
{
	LDY #MPSPCY
	LDA (MAPPTR),Y
	STA TMPSPC
	INY
	LDA (MAPPTR),Y
	STA TMPSPC + 1
	LDA MAPGEN
	PHA
	LDA MAPGEN + 1
	PHA
	LDA MAPTMP;GET POINTER TO MAP BLOCK
	STA MAPGEN
	LDA MAPTMP+ 1
	STA MAPGEN+ 1
	JSR GETPOS;GET NEXT FREE POSITION IN MAP BLOCK
	BCS MES1;BRANCH IF ROOM
	JMP MECNT
.MES1
	LDY #MPCYMP;GET ADDRESS OF CYLINDER MAP
	LDA (MAPPTR),Y
	STA MAPGEN
	INY
	LDA (MAPPTR),Y
	STA MAPGEN+ 1
	SEC
	LDY #0;CHECK IF ROOM FOR ANOTHER BLOCK
	LDA (MAPGEN),Y
	SBC #1
	STA (MAPGEN),Y
	INY
	LDA (MAPGEN),Y
	SBC #0
	STA (MAPGEN),Y
	INY
	LDA (MAPGEN),Y
	SBC #0
	STA (MAPGEN),Y
	BCC MKR3

	LDA MAPTMP
	STA MPMBPT
	STA CBSTA
	LDA MAPTMP + 1
	STA MPMBPT + 1
	STA CBSTA + 1
	JSR MMBLKD
	JSR GTCYPS;GET CLOSET CYCLINDER BLOCK
	LDA MAPGEN
	STA MPTMPB
	LDA MAPGEN + 1
	STA MPTMPB + 1
	LDA MPTMPE
	STA MPTMPC;NEW CYLINDER COUNT
	LDA MPTMPE+ 1
	STA MPTMPC+ 1
	JSR RDBTMP
	BNE MKR2
	JSR ALBLK;GET NEW MAP BLOCK
	SEC
	JSR RDMPBK;GET AREA OF STORE FOR IT
	LDA ERRTYP
	BEQ MKR1
.MKR2
	JSR ULMB
.MKR3
	JMP NOSPC
.MKR1
	CLC
	LDA MPMBPT;GET POINTER TO OLD MAP BLOCK
	STA CBSTA
	ADC #LO(LSTENT);POINT TO LAST ENTRY
	STA MPMBPT
	LDA MPMBPT+ 1
	STA CBSTA + 1
	ADC #HI(LSTENT)
	STA MPMBPT+ 1
	LDY #0;SAVE SIN OF NEW MAP BLOCK
	LDA MPTMPA
	STA (MPMBPT),Y
	INY
	LDA MPTMPA+ 1
	STA (MPMBPT),Y
	INY
	LDA MPTMPA+ 2
	STA (MPMBPT),Y
	INY ;NOW SAVE LENGTH
	LDA #1
	STA (MPMBPT),Y
	INY
	LDA #0
	STA (MPMBPT),Y
	JSR MMBWT
	JSR ULMB
	CLC
	LDY #MPCYMP;GET ADDRESS OF CYLINDER MAP
	LDA (MAPPTR),Y
	STA MAPGEN
	ADC #3;POINT TO START OF ENTRIES
	STA MPTMPB
	INY
	LDA (MAPPTR),Y
	STA MAPGEN + 1
	ADC #0
	STA MPTMPB+ 1
	JSR GTCYPS
	LDA MAPGEN
	STA MPCYPT
	LDA MAPGEN + 1
	STA MPCYPT + 1
	LDA MPTMPE
	STA MPTMPC
	LDA MPTMPE + 1
	STA MPTMPC + 1
	JSR RDBTMP
	BNE MKR2
	LDA MAPTMP
	STA MAPGEN;SAVE ADDRESS OF NEW MAP BLOCK
	LDA MAPTMP+ 1
	STA MAPGEN+ 1
	; TEST 27/10/83
	JSR SIZE
	LDA MPTMPD
	CMP MKENVA
	LDA MPTMPD + 1
	SBC MKENVA + 1
	BCS MKOK1
	LDA MPTMPD
	STA MKENVA
	LDA MPTMPD + 1
	STA MKENVA + 1
	; END OF TEST 27/10/83
.MKOK1
	JSR GETPOS;GET FREE POSITION IN MAP BLOCK
.MECNT
	LDA #0
	STA MPTMPE
	STA MPTMPE+ 1;ZERO VARIABLES
	STA MPTMPE+ 2
	TAY
.MELP3
	LDA (MPSCPT),Y;LOOK FOR BLOCKS TO ALLOCATE
	BEQ MEADD;NOT FOUND
	LDX #8
.MELP9
	ROR A
	BCS MECNT2
	DEX
	INC MPTMPE;STILL NOT FOUND
	BNE MELP9
	INC MPTMPE+ 1
	JMP MELP9;CHECK NEXT ONE	;;MM C=0 SO BCC MELP9?
.MEADD
	CLC ;NEXT BYTE SO ADD 8
	LDA MPTMPE
	ADC #8
	STA MPTMPE
	INY
	BCC MELP3
	INC MPTMPE+ 1
	BCS MELP3;ALWAYS
.MECNT2
	PHA
	LDA MPTMPE
	ORA MPTMPE + 1
	STA MPTMPB + 2;FLAG
	
	LDA MKENVA
	STA MPTMPB
	LDA MKENVA + 1
	STA MPTMPB + 1
	PLA
.MELP8
	CLC
	ROR A
	PHP
	PHA

	LDA MPTMPB
	BNE MELP8A
	DEC MPTMPB + 1
.MELP8A
	DEC MPTMPB
	LDA MPTMPB + 1
	ORA MPTMPB
	BEQ MESK3
	
	PLA
	PLP
	DEX
	BNE MELP8
	STA (MPSCPT),Y
	INY
	LDA (MPSCPT),Y
	ROR A
	LDX #8
	BNE MELP8;ALWAYS
.MESK3
	PLA
	PLP
	DEX
.MELP7
	ROR A
	DEX
	BNE MELP7
	STA (MPSCPT),Y
	LDA MPTMPC
	PHA
	LDA MPTMPC+ 1
	PHA ;SAVE POSITION
.MELP4
	LDA MPTMPC;NOW GET DISC ADDRESS
	ORA MPTMPC+ 1;IF ZERO THS IS IT!
	BEQ MESK2
	CLC
	LDA MPTMPE
	ADC TMPSPC
	STA MPTMPE
	LDA MPTMPE+ 1
	ADC TMPSPC + 1
	STA MPTMPE+ 1
	BCC MELP4A
	INC MPTMPE+ 2
.MELP4A
	LDA MPTMPC
	BNE MELP4B
	DEC MPTMPC + 1
.MELP4B
	DEC MPTMPC
	JMP MELP4
.MESK2
	PLA
	STA MPTMPC + 1
	PLA
	STA MPTMPC
	
	LDA MPTMPB + 2;FLAG
	BEQ MESK2C
	
	SEC
	LDA MAPGEN
	SBC MAPTMP
	TAY
	LDA MAPGEN + 1
	SBC MAPTMP + 1
	BNE MESK2A
	CPY #MBENTS
	BEQ MESK2C
	
.MESK2A
	SEC
	LDA MAPGEN
	PHA
	SBC #ENSZ
	STA MAPGEN
	LDA MAPGEN + 1
	PHA
	SBC #0
	STA MAPGEN + 1
	
	SEC
	LDY #BLKSN
	LDA MPTMPE
	SBC (MAPGEN),Y
	STA CBSTA
	INY
	LDA MPTMPE + 1
	SBC (MAPGEN),Y
	STA CBSTA + 1
	INY
	LDA MPTMPE + 2
	SBC (MAPGEN),Y
	BNE MESK2B
	
	INY ;Y:=BLKNO
	LDA CBSTA
	CMP (MAPGEN),Y
	BNE MESK2B
	INY
	LDA CBSTA + 1
	CMP (MAPGEN),Y
	BNE MESK2B
	
	DEY
	CLC
	LDA MKENVA
	ADC (MAPGEN),Y
	STA (MAPGEN),Y
	INY
	LDA MKENVA + 1
	ADC (MAPGEN),Y
	STA (MAPGEN),Y
	PLA
	PLA
	JMP MESK2D	

.MESK2B
	PLA
	STA MAPGEN + 1
	PLA
	STA MAPGEN

.MESK2C
	LDY #0;SAVE THE DISC ADDRESS
	LDA MPTMPE
	STA (MAPGEN),Y
	INY
	LDA MPTMPE+ 1
	STA (MAPGEN),Y
	INY
	LDA MPTMPE+ 2
	STA (MAPGEN),Y
	INY
	LDA MKENVA;SAVE SIZE
	STA (MAPGEN),Y
	LDA MKENVA+ 1
	INY
	STA (MAPGEN),Y
.MESK2D
	JSR MBMWT;MARK BIT MAP WRITTEN
	LDA MAPTMP
	STA CBSTA
	LDA MAPTMP + 1
	STA CBSTA + 1
	JSR MMBWT;MARK MAP BLOCK WRITTEN
	SEC
	LDA DIVTMP
	SBC MKENVA
	STA DIVTMP
	LDA DIVTMP + 1
	SBC MKENVA + 1
	STA DIVTMP + 1
	CLC ;FLAG EVERYTHING OK
.MEND
	PLA
	STA MAPGEN + 1
	PLA
	STA MAPGEN
	RTS
.NOSPC
	CLC
	LDY #0
	LDA (MAPGEN),Y
	ADC #1
	STA (MAPGEN),Y
	INY
	LDA (MAPGEN),Y
	ADC #0
	STA (MAPGEN),Y
	INY
	LDA (MAPGEN),Y
	ADC #0
	STA (MAPGEN),Y
	SEC ;NO GOOD
	BCS MEND
}

	;ALLOCATE ONE BLOCK
	;
	; LOOKS IN CURRENT BIT MAP AND RETURNS THE SIN
	; OF THE FIRST FREE BLOCK
	;
	; ON ENTRY
	;      MPTMPC HOLDS THE CYLINDER NUMBER
	;      MPSCPT POINTS TO THE CURRENT BIT MAP
	;
	; ON EXIT
	;      MPTMPA HOLDS THE SIN OF THE ALLOCATED BLOCK
	;
	; USES
	;      MPCYPT
	;
.ALBLK
{
	LDA #0;ZERO VARIABLES
	STA MPTMPA
	STA MPTMPA+ 1
	STA MPTMPA+ 2
	LDA MPSCPT;COPY POINTER TO USE
	STA MPCYPT
	LDA MPSCPT + 1
	STA MPCYPT + 1
.ALNX
	LDY #0
	LDA (MPCYPT),Y;FIND FREE BLOCK
	BEQ ALS8
.ALLP
	ROR A;NOW FIND THE SECTOR
	BCS ALGT;FOUND WHEN C SET
	INC MPTMPA;KEEP LOOKING
	BNE ALLP
	INC MPTMPA + 1
	JMP ALLP
.ALS8
	CLC
	LDA MPTMPA;MOVE TO NEXT BYTE
	ADC #8
	STA MPTMPA
	BCC ALS8A
	INC MPTMPA+ 1
.ALS8A
	INC MPCYPT
	BNE ALNX
	INC MPCYPT+ 1;*** M OAKLEY 27/1/86 ***
.ALSK1
	JMP ALNX
.ALGT
	PHA ;SAVE TO MARK AS ALLOCATED
	LDA MPTMPA
	AND #7
	TAX
	INX
	PLA
	CLC
.ALLP2
	ROL A
	DEX
	BNE ALLP2
	STA (MPCYPT),Y;BLOCK MARKED ALLOCATED
	LDA MPTMPC
	STA MAPTMP
	LDA MPTMPC+ 1
	STA MAPTMP+ 1
.ALLP3
	LDA MAPTMP
	ORA MAPTMP+ 1
	BEQ ALND;GET DISC ADDRESS
	LDY #MPSPCY
	CLC
	LDA MPTMPA
	ADC (MAPPTR),Y
	STA MPTMPA
	INY
	LDA MPTMPA+ 1
	ADC (MAPPTR),Y
	STA MPTMPA+ 1
	BCC ALLP3A
	INC MPTMPA+ 2
.ALLP3A
	LDA MAPTMP
	BNE ALLP3B
	DEC MAPTMP+ 1
.ALLP3B
	DEC MAPTMP
	JMP ALLP3
.ALND
	LDA MPTMPB;GET POINTER TO CYLINDER MAP
	STA MPCYPT
	LDA MPTMPB+ 1
	STA MPCYPT+ 1
	LDY #0;DECREMENT FREE COUNT
	SEC
	LDA (MPCYPT),Y
	SBC #1
	STA (MPCYPT),Y
	INY
	LDA (MPCYPT),Y
	SBC #0
	STA (MPCYPT),Y
	LDY #MPCYMP
	LDA (MAPPTR),Y
	STA MPCYPT
	INY
	LDA (MAPPTR),Y
	STA MPCYPT + 1
	JSR MBMWT;MARK BIT MAP WRITTEN
	LDA MPTMPA
	ORA MPTMPA + 1
	ORA MPTMPA + 2
	BNE AND
	LDA #&FC
	JSR INTERR
.AND
	RTS
}
	; ALLOCATE A SERIES OF BLOCKS
	;
	; ON ENTRY
	;      MPCYPT POINTS TO POSITION IN CYLINDER MAP
	;      DIVTMP HOLDS NUMBER OF SECTORS REQUIRED
	;      MPSCPT POINTS TO BIT MAP
	;      MAPPTR POINTS TO MAP TABLE
	;      MAPTMP POINTS TO MAP BLOCK
	;      MPTMPC HOLDS CYLINDER NUMBER
	;
	; ON EXIT
	;      DIVTMP HOLDS NUMBER OF BLOCKS LEFT
	;      C SET IF FAILED
	;
	; USES
	;      MAPGEN
	;
.ABLKS
{
	LDY #MPCYMP
	LDA (MAPPTR),Y;GET POINTER TO START OF CYLINDER MAP
	STA MAPGEN
	INY
	LDA (MAPPTR),Y
	STA MAPGEN+ 1
	JSR SIZE;GET SIZE OF THIS BLOCK
	LDA MPTMPD;MPTMPD HAS SIZE
	CMP DIVTMP;SEE IF WE NEED THEM ALL
	LDA MPTMPD+ 1
	SBC DIVTMP+ 1
	BCC ABSALL
	LDA DIVTMP+ 2
	BNE ABSALL;ABSALL ALLOCATES ALL BLOCKS
	LDA DIVTMP
	STA MKENVA;MAKE ENTRY IN MAP BLOCK
	LDA DIVTMP+ 1
	STA MKENVA+ 1
.ABSMKE
	JSR MKEN
	BCS ABSFLD;ALL DONE SO FINISH
	LDA ERRTYP
	BNE ABSFLD
	LDY #0
	SEC
	LDA (MPCYPT),Y
	SBC MKENVA
	STA (MPCYPT),Y
	INY
	LDA (MPCYPT),Y
	SBC MKENVA + 1
	STA (MPCYPT),Y
	CMP #&FF
	BNE ABSNM1
	DEY
	LDA (MPCYPT),Y
	CMP #&FF
	BNE ABSNM1
	LDA #&FA
	JSR INTERR
.ABSNM1
	CLC
	RTS
.ABSFLD
	JSR DAGRP;NOT ABLE TO MAKE ENTRY
	LDY #0
	CLC
	LDA (MAPGEN),Y;INCREASE FREE COUNT
	ADC MKENVA
	STA (MAPGEN),Y
	INY
	LDA (MAPGEN),Y
	ADC MKENVA+ 1
	STA (MAPGEN),Y
	INY
	LDA (MAPGEN),Y
	ADC #0
	STA (MAPGEN),Y
	SEC ;TO INDICATE FAILURE
	RTS
.ABSALL
	LDA MPTMPD
	STA MKENVA;PREPARE TO MAKE ENTRY IN MAP BLOCK
	LDA MPTMPD+ 1
	STA MKENVA+ 1
	JMP ABSMKE
}

	; DEALLOCATE MAP BLOCK
	;
	;   DEALLOCATES THE SPECIFIED MAP BLOCK. OVERWRITES THE SEQUENCE NUBERS
	;   SO THAT IT WILL NO LONGER APPEAR AS A MAP BLOCK
	;
	; ON ENTRY
	;     MPTMPA HOLDS THE SIN OF THE MAP BLOCK
	;     MPCYPT POINTS TO THE CYLINDER MAP
	;
	; USES
	;     MPTMPA,MPTMPD,MPTMPC,MPSCPT
	;
.DAMPBK
{
	LDY #MPSPCY
	LDA (MAPPTR),Y
	STA TMPSPC
	INY
	LDA (MAPPTR),Y
	STA TMPSPC + 1
	LDA MPTMPA;DEALLOCATE MAP BLOCK
	STA CBSIN
	LDA MPTMPA + 1
	STA CBSIN + 1
	LDA MPTMPA + 2
	STA CBSIN + 2
	JSR FNDMB; GNCBPT POINTS TO CURRENT ENTRY
	LDY #CBSA
	LDA (GNCBPT),Y
	STA MPSCPT;SAVE POINTER TO MAP BLOCK
	STA CBSTA
	INY
	LDA (GNCBPT),Y
	STA MPSCPT + 1
	STA CBSTA + 1
	LDY #MBSQNO
	LDA #&FF
	STA (MPSCPT),Y;SAVE INVALID SQ.NO.
	CLC
	LDA MPSCPT
	ADC #LO(LSTSQ)
	STA MPSCPT
	LDA MPSCPT + 1
	ADC #HI(LSTSQ)
	STA MPSCPT + 1
	LDA #0
	TAY
	STA (MPSCPT),Y
	JSR MMBWT
	LDA #0
	STA MPTMPC; ZERO VARIABLES
	STA MPTMPC + 1
.DMBLP1
	SEC
	LDA MPTMPA
	SBC TMPSPC; FIND CYLINDER NUMBER
	STA MPTMPA
	LDA MPTMPA + 1
	SBC TMPSPC + 1
	STA MPTMPA + 1
	LDA MPTMPA + 2
	SBC #0
	STA MPTMPA + 2
	BCC DMBCNT; CYLINDER FOUND
	INC MPTMPC;INCREMENT CYLINDER COUNT
	BNE DMBLP1
	INC MPTMPC + 1
	JMP DMBLP1
.DMBCNT
	JSR RDBTMP; GET THE RELEVCANT BIT MAP TO STORE
	CLC
	LDA MPTMPA; GET WHICH BLOCK OF THIS CYLINDER
	ADC TMPSPC
	STA MPTMPA
	LDA MPTMPA + 1
	ADC TMPSPC + 1
	STA MPTMPA + 1
	BCC DMBJ1
	INC MPTMPA + 2
.DMBJ1
	LDY #0
.DMBLP2
	SEC ;GET POSITION IN BIT MAP
	LDA MPTMPA
	SBC #8
	STA MPTMPA
	LDA MPTMPA + 1
	SBC #0
	STA MPTMPA + 1
	BCC DMBSK1; POSITION FOUND IF BRANCH
	INY
	JMP DMBLP2
.DMBSK1
	CLC
	LDA MPTMPA; GET OLD POSITION BACK
	ADC #8
	STA MPTMPA
	BCC DMBJ2
	INC MPTMPA + 1
.DMBJ2
	LDX MPTMPA
	INX
	LDA (MPSCPT),Y; X HOLDS POSITION IN BYTE A HOLDS THE BYTE
.DMBLP3
	ROR A;MOVE TO CORRECT POSITION
	DEX
	BNE DMBLP3
	SEC
	LDX MPTMPA;BLOCK IS FLAGGED FREE AND X HOLDS NUMBER OF SHIFTS
	INX
.DMBLP4
	ROL A; UNTIL BACK TO CORRECT POSITION
	DEX
	BNE DMBLP4
	STA (MPSCPT),Y; SAVE FLAGS
	CLC
	LDA MPCYPT;NOW MAKE COUNTS CORRECT
	ADC #3
	STA MAPGEN
	LDA MPCYPT + 1
	ADC #0
	STA MAPGEN + 1
	LDA MPTMPC
	STA MPTMPE
	LDA MPTMPC + 1
	STA MPTMPE + 1
.DMBLP5
	LDA MPTMPE
	ORA MPTMPE + 1
	BEQ DMBSK2
	CLC
	LDA MAPGEN
	ADC #2
	STA MAPGEN
	BCC DMBJ3
	INC MAPGEN + 1
.DMBJ3
	LDA MPTMPE
	BNE DMBJ4
	DEC MPTMPE + 1
.DMBJ4
	DEC MPTMPE
	JMP DMBLP5
.DMBSK2
	LDY #0
	CLC
	LDA (MAPGEN),Y;INCREMENT FREE BLOCK COUNT
	ADC #1
	STA (MAPGEN),Y
	INY
	LDA (MAPGEN),Y
	ADC #0
	STA (MAPGEN),Y
	LDY #0
	CLC
	LDA (MPCYPT),Y
	ADC #1
	STA (MPCYPT),Y
	INY
	LDA (MPCYPT),Y
	ADC #0
	STA (MPCYPT),Y
	INY
	LDA (MPCYPT),Y
	ADC #0
	STA (MPCYPT),Y
	JMP MBMWT;NOW FINISHED
}

	;
	; DALLOCATE A GROUP OF BLOCKS
	;    MARKS THE ENTRIES IN THE SPECIFIED BIT MAP FREE ASND INCREASES THE FREE BLOCK COUNT
	;
	; ON ENTRY
	;     MPSCPT POINTS TO RELEVANT ENTRY IN MAP BLOCK
	;     MPCYPT POINTS TO CYLINDER MAP
	;     MAPTMP POINTS TO MAP BLOCK
	;
	; USES
	;     MPTMPC,MAPGEN,MPTMPD,MAPTMP
	;
.DAGRP
{
	LDA MAPTMP
	PHA
	LDA MAPTMP + 1
	PHA
	
	LDY #0
	STY MPTMPC; ZERO VALUES
	STY MPTMPC + 1
	
	LDA (MPSCPT),Y; GET SIN
	STA MPTMPD
	INY
	LDA (MPSCPT),Y
	STA MPTMPD + 1
	INY
	LDA (MPSCPT),Y
	STA MPTMPD + 2
	LDA MPSCPT; SAVE MAP BLOCK POINTER
	STA MAPGEN
	LDA MPSCPT + 1
	STA MAPGEN + 1

.DAGLP1
	LDY #MPSPCY
	SEC ; NOW FIND CYLINDER
	LDA MPTMPD
	SBC (MAPPTR),Y
	STA MPTMPD
	INY
	LDA MPTMPD + 1
	SBC (MAPPTR),Y
	STA MPTMPD + 1
	LDA MPTMPD + 2
	SBC #0
	STA MPTMPD + 2
	BCC DAGGT; END FOUND
	INC MPTMPC; COUNT TO NEXT CYLINDER
	BNE DAGLP1
	INC MPTMPC + 1
	JMP DAGLP1
.DAGGT
	LDY #MPSPCY
	CLC
	LDA MPTMPD; RESTORE BLOCK COUNT
	ADC (MAPPTR),Y
	STA MPTMPD
	INY
	LDA MPTMPD + 1
	ADC (MAPPTR),Y
	STA MPTMPD + 1
	BCC DAGGT1
	INC MPTMPD + 2
.DAGGT1
	LDA MPTMPC; SAVE CYLINDER NUMBER
	STA MAPTMP
	LDA MPTMPC + 1
	STA MAPTMP + 1
	JSR RDBTMP
	LDY #0
.DAGLP2
	SEC ; GET POSITION IN BIT MAP
	LDA MPTMPD
	SBC #8
	STA MPTMPD
	LDA MPTMPD + 1
	SBC #0
	STA MPTMPD + 1
	LDA MPTMPD + 2
	SBC #0
	STA MPTMPD + 2
	BCC DAGFD; WHEN POSITION FOUND
	INY
	JMP DAGLP2
.DAGFD
	CLC ; GET BIT POSITION BACK
	LDA MPTMPD
	ADC #8
	STA MPTMPD
	BCC DAGFD1
	INC MPTMPD + 1
	BNE DAGFD1
	INC MPTMPD + 2
.DAGFD1
	LDA MPTMPD
	STA MPTMPC; SAVE BIT COUNT
	INC MPTMPC
	LDA (MPSCPT),Y; GET CORRECT BYTE
	LDX #9
.DAGLP3
	ROR A; ROTATE TO GET CORRECT POSITION
	DEX
	DEC MPTMPC
	BNE DAGLP3
	PHA ;SAVE VALUE
	TYA
	PHA ; SAVE POSITION
	LDY #3
	LDA (MAPGEN),Y; GET NUMBER OF BLOCKS TO BE DEALLOCATED
	STA MPTMPC
	INY
	LDA (MAPGEN),Y
	STA MPTMPC + 1
	PLA ; GET POSITION BACK
	TAY
	PLA
.DAGNX
	SEC ;MARK BLOCK FREE
	ROR A
	DEX
	BEQ DAGEOB
	PHP
	PHA ; SAVE VALUE
.DAGNX1
	LDA MPTMPC
	BNE DAGNX2
	DEC MPTMPC + 1
.DAGNX2
	DEC MPTMPC; DECREMENT COUNT
	LDA MPTMPC + 1
	ORA MPTMPC; CHECK FOR END
	BEQ DAGSK1
	PLA ; GET VALUE BACK
	PLP
	JMP DAGNX; DEALLOCATE NEXT BLOCK
.DAGEOB
	STA (MPSCPT),Y; SAVE NEW VALUE
	INY
	LDA (MPSCPT),Y; GET NEXT VALUE
	ROR A; POSITION CORRECTLY
	PHP
	PHA
	LDX #8;GIVE X CORRECT VALUE
	BNE DAGNX1
.DAGSK1
	CPX #0
	BEQ DAGSK2; BRANCH IF POSITION CORRECT
	PLA ;BLOCKS HAVE BEEN DEALLOCATED SO CORRECT POSITION
	PLP
.DAGLP4
	ROR A
	DEX
	BNE DAGLP4; KEEP GOING UNTIL BACK RIGHT
	BEQ DAGSK4
.DAGSK2
	PLA
	PLP
.DAGSK4
	STA (MPSCPT),Y;SAVE VALUE
	JSR MBMWT;MARK BIT MAP WRITTEN
	LDY #3; NOW CORRECT FREE BLOCK COUNT
	LDA (MAPGEN),Y
	STA MPTMPC
	INY
	LDA (MAPGEN),Y
	STA MPTMPC + 1
	LDY #0
	CLC ; NOW ADD TO FREE BLOCK COUNT
	LDA MPTMPC
	ADC (MPCYPT),Y
	STA (MPCYPT),Y
	INY
	LDA MPTMPC + 1
	ADC (MPCYPT),Y
	STA (MPCYPT),Y
	INY
	LDA #0
	ADC (MPCYPT),Y
	STA (MPCYPT),Y
	CLC ; NOW GET POSITION IN CYCLINDER MAP
	LDA #3
	ADC MPCYPT
	STA MPSCPT
	LDA #0
	ADC MPCYPT + 1
	STA MPSCPT + 1
.DAGLP5
	LDA MAPTMP
	ORA MAPTMP + 1; HAVE WE GOT THERE ?
	BEQ DAGSK3
	CLC ; MOVE TO NEXT ENTRY
	LDA MPSCPT
	ADC #2
	STA MPSCPT
	BCC DAGL5A
	INC MPSCPT + 1
.DAGL5A
	LDA MAPTMP
	BNE DAGL5B
	DEC MAPTMP + 1
.DAGL5B
	DEC MAPTMP	
	JMP DAGLP5
.DAGSK3
	CLC ; NOW DO THE ADD
	LDY #0
	LDA (MPSCPT),Y
	ADC MPTMPC
	STA (MPSCPT),Y
	INY
	LDA (MPSCPT),Y
	ADC MPTMPC + 1
	STA (MPSCPT),Y
	LDA MAPGEN; RESTORE SOME VALUES
	STA MPSCPT
	LDA MAPGEN + 1
	STA MPSCPT + 1
	LDY #0
	TYA
	LDX #5
.DAGZLP
	STA (MPSCPT),Y
	INY
	DEX
	BNE DAGZLP
	PLA
	STA MAPTMP + 1
	STA CBSTA + 1
	PLA
	STA MAPTMP
	STA CBSTA
	JMP MMBWT
}

.CLRBLK
{
	;   DEALLOCATES ALL BLOCKS FROM A GIVEN ENTRY.
	;   THE ORIGINAL MAP BLOCK WILL BE DELETED IF A FLAG IS SET.
	;
	; ON ENTRY
	;     MPTMPA HOLDS THE SIN OF THE MAP BLOCK
	;     MPSCPT HOLDS THE OFFSET IN THE MAP BLOCK
	;     MPTMPE IF NON-ZERO IMPLIES MAP BLOCK TO BE DELETED
	;
	LDY #MPCYMP
	LDA (MAPPTR),Y
	STA MPCYPT
	INY
	LDA (MAPPTR),Y
	STA MPCYPT + 1
	CLC
	JSR RDMPBK; MAKE SURE MAP BLOCK IS IN STORE
	BNE CBSK2
	CLC
	LDA MAPTMP; GET POINTER TO MAP BLOCK
	STA MPMBPT
	ADC MPSCPT; GET CURRENT POSITION
	STA MPSCPT
	LDA MAPTMP + 1
	STA MPMBPT + 1
	ADC MPSCPT + 1
	STA MPSCPT + 1
.CBLP1
	LDY #0; CHECK IF END OF BLOCK
	LDA (MPSCPT),Y
	INY
	ORA (MPSCPT),Y
	INY
	ORA (MPSCPT),Y
	BNE CBSSK1; END OF MAP BLOCK REACHED
.CBCNT
	LDA MPTMPE
	BEQ CBSK2
	LDA DNDLTE
	BNE CBSK2
	JSR DAMPBK
.CBSK2
	RTS

.CBSSK1
	CLC
	LDA MPMBPT
	ADC #LO(LSTENT)
	TAX
	LDA MPMBPT + 1
	ADC #HI(LSTENT)
	CPX MPSCPT; CHECK FOR LAST ENTRY
	BNE CBDA1
	CMP MPSCPT + 1
	BNE CBDA1
	LDY #0; GET NEW SIN
	LDA (MPSCPT),Y
	STA MPTMPB
	INY
	LDA (MPSCPT),Y
	STA MPTMPB + 1
	INY
	LDA (MPSCPT),Y
	STA MPTMPB + 2

	LDY #4
	LDA #0
.CBSSJ
	STA (MPSCPT),Y;clear out this pointer
	DEY
	BPL CBSSJ;**14/9/84**
	JSR MMBWT;**20/5/87**

	JSR CBCNT; DEALLOCATE THE MAP BLOCK IF NEEDED
	LDA #0
	STA DNDLTE
	LDA #1
	STA MPTMPE
	LDA MPTMPB
	STA MPTMPA
	LDA MPTMPB + 1
	STA MPTMPA + 1
	LDA MPTMPB + 2
	STA MPTMPA + 2
	CLC
	JSR RDMPBK; READ IN NEW MAP BLOCK
	CLC
	LDA MAPTMP;TRANSFER POINTER
	STA MPMBPT
	ADC #LO(MBENTS); GET TO POINT TO START OF ENTRIES
	STA MPSCPT
	LDA MAPTMP + 1
	STA MPMBPT + 1
	ADC #HI(MBENTS)
	STA MPSCPT + 1
.CBDA1
	JSR DAGRP
	LDA SAVSC
	BNE CBNDL
	INC SAVSC
	JSR ENSMB
	JSR ULBM
.CBNDL
	CLC ; MOVE TO NEXT ENTRY
	LDA MPSCPT
	ADC #LO(ENSZ)
	STA MPSCPT
	LDA MPSCPT + 1
	ADC #HI(ENSZ)
	STA MPSCPT + 1
	JMP CBLP1
}

;.LNK
;UADE13
;:
